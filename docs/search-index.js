var searchIndex={};
searchIndex["base_conversion"] = {"doc":"","i":[[5,"lookup_digits_mod_at_position","base_conversion","",null,[[["u16"],["usize"],["u8"]]]],[5,"lookup_defined_for_mod","","",null,[[["u16"]],["bool"]]]],"p":[]};
searchIndex["fancy_garbling"] = {"doc":"`fancy-garbling` provides boolean and arithmetic garbling…","i":[[3,"BinaryBundle","fancy_garbling","Bundle which is explicitly binary representation.",null,null],[3,"Bundle","","A collection of wires, useful for the garbled gadgets…",null,null],[3,"CrtBundle","","Bundle which is explicitly CRT-representation.",null,null],[3,"Evaluator","","Streaming evaluator using a callback to receive…",null,null],[3,"Garbler","","Streams garbled circuit ciphertexts through a callback.",null,null],[4,"Wire","","The core wire-label type.",null,null],[13,"Mod2","","Representation of a `mod-2` wire.",0,null],[12,"val","fancy_garbling::Wire","A 128-bit value.",1,null],[13,"Mod3","fancy_garbling","Representation of a `mod-3` wire.",0,null],[12,"lsb","fancy_garbling::Wire","The least-significant bits of each `mod-3` element.",2,null],[12,"msb","","The most-significant bits of each `mod-3` element.",2,null],[13,"ModN","fancy_garbling","Representation of a `mod-q` wire.",0,null],[12,"q","fancy_garbling::Wire","The modulus of this wire-label.",3,null],[12,"ds","","A list of `mod-q` digits.",3,null],[0,"circuit","fancy_garbling","DSL for creating circuits compatible with fancy-garbling…",null,null],[3,"CircuitRef","fancy_garbling::circuit","The index and modulus of a gate in a circuit.",null,null],[3,"Circuit","","Static representation of the type of computation supported…",null,null],[3,"CircuitBuilder","","CircuitBuilder is used to build circuits.",null,null],[11,"new","","Make a new `Circuit` object.",4,[[["option",["usize"]],["usize"]],["circuit"]]],[11,"eval","","Evaluate the circuit using fancy object `f`.",4,[[["f"],["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"eval_plain","","Evaluate the circuit in plaintext.",4,[[["self"]],[["dummyerror"],["result",["vec","dummyerror"]],["vec",["u16"]]]]],[11,"print_info","","Print circuit info.",4,[[["self"]],[["dummyerror"],["result",["dummyerror"]]]]],[11,"num_garbler_inputs","","Return the number of garbler inputs.",4,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","Return the number of evaluator inputs.",4,[[["self"]],["usize"]]],[11,"noutputs","","Return the number of outputs.",4,[[["self"]],["usize"]]],[11,"modulus","","Return the modulus of the gate indexed by `i`.",4,[[["self"],["usize"]],["u16"]]],[11,"garbler_input_mod","","Return the modulus of the garbler input indexed by `i`.",4,[[["self"],["usize"]],["u16"]]],[11,"evaluator_input_mod","","Return the modulus of the evaluator input indexed by `i`.",4,[[["self"],["usize"]],["u16"]]],[11,"new","","Make a new `CircuitBuilder`.",5,[[],["self"]]],[11,"finish","","Finish circuit building, outputting the resulting circuit.",5,[[],["circuit"]]],[11,"garbler_input","","Get CircuitRef for a garbler input wire.",5,[[["u16"],["self"]],["circuitref"]]],[11,"evaluator_input","","Get CircuitRef for an evaluator input wire.",5,[[["u16"],["self"]],["circuitref"]]],[11,"garbler_inputs","","Get a vec of CircuitRefs for garbler inputs.",5,[[["self"]],[["vec",["circuitref"]],["circuitref"]]]],[11,"evaluator_inputs","","Get a vec of CircuitRefs for garbler inputs.",5,[[["self"]],[["vec",["circuitref"]],["circuitref"]]]],[11,"crt_garbler_input","","Get a CrtBundle for the garbler using composite modulus Q",5,[[["self"],["u128"]],[["crtbundle",["circuitref"]],["circuitref"]]]],[11,"crt_evaluator_input","","Get a CrtBundle for the evaluator using composite modulus Q",5,[[["self"],["u128"]],[["crtbundle",["circuitref"]],["circuitref"]]]],[11,"bin_garbler_input","","Get a BinaryBundle for the garbler with n bits.",5,[[["self"],["usize"]],[["binarybundle",["circuitref"]],["circuitref"]]]],[11,"bin_evaluator_input","","Get a BinaryBundle for the evaluator with n bits.",5,[[["self"],["usize"]],[["binarybundle",["circuitref"]],["circuitref"]]]],[0,"classic","fancy_garbling","Provides objects and functions for statically garbling and…",null,null],[3,"GarbledCircuit","fancy_garbling::classic","Static evaluator for a circuit, created by the `garble`…",null,null],[3,"Encoder","","Encode inputs statically.",null,null],[3,"GarbledWriter","","Implementation of the `Write` trait for use by `Garbler`.",null,null],[5,"garble","","Garble a circuit without streaming.",null,[[["circuit"]],[["result",["garblererror"]],["garblererror"]]]],[11,"new","","Create a new object from a vector of garbled gates and…",6,[[["vec",["block"]],["block"]],["self"]]],[11,"size","","The number of garbled rows and constant wires in the…",6,[[["self"]],["usize"]]],[11,"eval","","Evaluate the garbled circuit.",6,[[["circuit"],["self"]],[["result",["vec","evaluatorerror"]],["vec",["u16"]],["evaluatorerror"]]]],[11,"new","","Make a new `Encoder` from lists of garbler and evaluator…",7,[[["wire"],["hashmap",["u16","wire"]],["u16"],["vec",["wire"]]],["self"]]],[11,"num_garbler_inputs","","Output the number of garbler inputs.",7,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","Output the number of evaluator inputs.",7,[[["self"]],["usize"]]],[11,"encode_garbler_input","","Encode a single garbler input into its associated…",7,[[["u16"],["self"],["usize"]],["wire"]]],[11,"encode_evaluator_input","","Encode a single evaluator input into its associated…",7,[[["u16"],["self"],["usize"]],["wire"]]],[11,"encode_garbler_inputs","","Encode a slice of garbler inputs into their associated…",7,[[["self"]],[["wire"],["vec",["wire"]]]]],[11,"encode_evaluator_inputs","","Encode a slice of evaluator inputs into their associated…",7,[[["self"]],[["wire"],["vec",["wire"]]]]],[11,"new","","Make a new `GarbledWriter`.",8,[[["option",["usize"]],["usize"]],["self"]]],[0,"dummy","fancy_garbling","Dummy implementation of `Fancy`.",null,null],[3,"Dummy","fancy_garbling::dummy","Simple struct that performs the fancy computation over…",null,null],[3,"DummyVal","","Wrapper around `u16`.",null,null],[11,"new","","Create a new DummyVal.",9,[[["u16"]],["self"]]],[11,"val","","Extract the value.",9,[[["self"]],["u16"]]],[11,"new","","Create a new Dummy.",10,[[],["dummy"]]],[0,"errors","fancy_garbling","Errors that may be output by this library.",null,null],[4,"FancyError","fancy_garbling::errors","Errors that may occur when using the `Fancy` trait. These…",null,null],[13,"UnequalModuli","","Unequal moduli.",11,null],[13,"InvalidArg","","Invalid argument.",11,null],[13,"InvalidArgNum","","Invalid number of arguments.",11,null],[12,"got","fancy_garbling::errors::FancyError","Received number of arguments.",12,null],[12,"needed","","Expected number of arguments.",12,null],[13,"InvalidArgMod","fancy_garbling::errors","Invalid argument modulus.",11,null],[12,"got","fancy_garbling::errors::FancyError","Received modulus.",13,null],[12,"needed","","Expected modulus.",13,null],[13,"ArgNotBinary","fancy_garbling::errors","Expected binary argument.",11,null],[13,"NoTruthTable","","Truth table expected but none given.",11,null],[13,"InvalidTruthTable","","Projection truth table is invalid.",11,null],[13,"UninitializedValue","","Uninitialized value encountered.",11,null],[4,"DummyError","","Errors from the dummy fancy object.",null,null],[13,"NotEnoughGarblerInputs","","Not enough garbler inputs provided.",14,null],[13,"NotEnoughEvaluatorInputs","","Not enough evaluator inputs provided.",14,null],[13,"EncodingError","","Encoding error.",14,null],[13,"FancyError","","A fancy error has occurred.",14,null],[4,"EvaluatorError","","Errors from the evaluator.",null,null],[13,"NotEnoughGarblerInputs","","Not enough garbler inputs provided.",15,null],[13,"NotEnoughEvaluatorInputs","","Not enough evaluator inputs provided.",15,null],[13,"DecodingFailed","","Decoding failed.",15,null],[13,"CommunicationError","","A communication error has occurred.",15,null],[13,"FancyError","","A fancy error has occurred.",15,null],[4,"GarblerError","","Errors from the garbler.",null,null],[13,"CommunicationError","","An error occurred while processing a message.",16,null],[13,"AsymmetricHalfGateModuliMax8","","Asymmetric moduli error.",16,null],[13,"TruthTableRequired","","A truth table was missing.",16,null],[13,"DeltaRequired","","Delta required for wire reuse.",16,null],[13,"EncodingError","","Encoding error.",16,null],[13,"FancyError","","A fancy error has occurred.",16,null],[4,"CircuitBuilderError","","Errors emitted when building a circuit.",null,null],[13,"ReuseUndefined","","Reuse not supported.",17,null],[13,"FancyError","","A fancy error has occurred.",17,null],[4,"CircuitParserError","","Errors emitted by the circuit parser.",null,null],[13,"IoError","","An I/O error occurred.",18,null],[13,"RegexError","","A regular expression parsing error occurred.",18,null],[13,"ParseIntError","","An error occurred parsing an integer.",18,null],[13,"ParseLineError","","An error occurred parsing a line.",18,null],[13,"ParseGateError","","An error occurred parsing a gate type.",18,null],[4,"TwopacError","","Errors produced by `twopac`.",null,null],[13,"IoError","","An I/O error has occurred.",19,null],[13,"OtError","","An oblivious transfer error has occurred.",19,null],[13,"GarblerError","","The garbler produced an error.",19,null],[13,"EvaluatorError","","The evaluator produced an error.",19,null],[13,"FancyError","","Processing the garbled circuit produced an error.",19,null],[11,"new","fancy_garbling","Create a new binary bundle from a vector of wires.",20,[[["vec"]],["binarybundle"]]],[11,"extract","","Extract the underlying bundle from this binary bundle.",20,[[],["bundle"]]],[11,"new","","Create a new bundle from some wires.",21,[[["vec"]],["bundle"]]],[11,"moduli","","Return the moduli of all the wires in the bundle.",21,[[["self"]],[["u16"],["vec",["u16"]]]]],[11,"wires","","Extract the wires from this bundle.",21,[[["self"]]]],[11,"size","","Get the number of wires in this bundle.",21,[[["self"]],["usize"]]],[11,"is_binary","","Whether this bundle only contains residues in mod 2.",21,[[["self"]],["bool"]]],[11,"with_moduli","","Returns a new bundle only containing wires with matching…",21,[[["self"]],["bundle"]]],[11,"pad","","Pad the Bundle with val, n times.",21,[[["self"],["usize"],["w"]]]],[11,"extract","","Extract a wire from the Bundle, removing it and returning…",21,[[["self"],["usize"]],["w"]]],[11,"iter","","Access the underlying iterator",21,[[["self"]],["iter"]]],[11,"new","","Create a new CRT bundle from a vector of wires.",22,[[["vec"]],["crtbundle"]]],[11,"extract","","Extract the underlying bundle from this CRT bundle.",22,[[],["bundle"]]],[11,"composite_modulus","","Return the product of all the wires' moduli.",22,[[["self"]],["u128"]]],[11,"new","","Create a new `Evaluator`.",23,[[["c"]],["self"]]],[11,"read_wire","","Read a Wire from the reader.",23,[[["u16"],["self"]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"new","","Create a new garbler.",24,[[["c"],["rng"]],["self"]]],[11,"delta","","Create a delta if it has not been created yet for this…",24,[[["u16"],["self"]],["wire"]]],[11,"get_deltas","","Get the deltas, consuming the Garbler.",24,[[],[["u16"],["wire"],["hashmap",["u16","wire"]]]]],[11,"send_wire","","Send a wire over the established channel.",24,[[["wire"],["self"]],[["result",["garblererror"]],["garblererror"]]]],[11,"encode_wire","","Encode a wire, producing the zero wire as well as the…",24,[[["u16"],["self"]]]],[11,"encode_many_wires","","Encode many wires, producing zero wires as well as encoded…",24,[[["self"]],[["result",["garblererror"]],["garblererror"]]]],[11,"crt_encode_wire","","Encode a `CrtBundle`, producing zero wires as well as…",24,[[["self"],["u128"]],[["garblererror"],["result",["garblererror"]]]]],[11,"bin_encode_wire","","Encode a `BinaryBundle`, producing zero wires as well as…",24,[[["self"],["usize"],["u128"]],[["garblererror"],["result",["garblererror"]]]]],[0,"informer","","`Informer` runs a fancy computation and learns information…",null,null],[3,"Informer","fancy_garbling::informer","Implements `Fancy`. Used to learn information about a…",null,null],[12,"underlying","","The underlying fancy object.",25,null],[3,"InformerStats","","The statistics revealed by the informer.",null,null],[11,"num_garbler_inputs","","Number of garbler inputs in the fancy computation.",26,[[["self"]],["usize"]]],[11,"garbler_input_moduli","","Moduli of garbler inputs in the fancy computation.",26,[[["self"]],[["u16"],["vec",["u16"]]]]],[11,"num_evaluator_inputs","","Number of evaluator inputs in the fancy computation.",26,[[["self"]],["usize"]]],[11,"evaluator_input_moduli","","Moduli of evaluator inputs in the fancy computation.",26,[[["self"]],[["u16"],["vec",["u16"]]]]],[11,"num_consts","","Number of constants in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_outputs","","Number of outputs in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_output_ciphertexts","","Number of output ciphertexts.",26,[[["self"]],["usize"]]],[11,"num_adds","","Number of additions in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_subs","","Number of subtractions in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_cmuls","","Number of scalar multiplications in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_muls","","Number of multiplications in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_projs","","Number of projections in the fancy computation.",26,[[["self"]],["usize"]]],[11,"num_ciphertexts","","Number of ciphertexts in the fancy computation.",26,[[["self"]],["usize"]]],[11,"new","","Make a new `Informer`.",25,[[["f"]],["informer"]]],[11,"stats","","Get the statistics collected by the `Informer`",25,[[["self"]],["informerstats"]]],[11,"parse","fancy_garbling::circuit","Generates a new `Circuit` from file `filename`. The file…",4,[[["str"]],[["result",["error"]],["error"]]]],[0,"twopac","fancy_garbling","Implementations of two-party secure computation.",null,null],[0,"semihonest","fancy_garbling::twopac","Implementation of semi-honest two-party computation.",null,null],[3,"Evaluator","fancy_garbling::twopac::semihonest","Semi-honest evaluator.",null,null],[3,"Garbler","","Semi-honest garbler.",null,null],[11,"new","","Make a new `Evaluator`.",27,[[["c"],["rng"]],[["result",["twopacerror"]],["twopacerror"]]]],[11,"get_channel","","Get a reference to the internal channel.",27,[[["self"]],["c"]]],[11,"new","","Make a new `Garbler`.",28,[[["c"],["rng"]],[["result",["twopacerror"]],["twopacerror"]]]],[11,"get_channel","","Get a reference to the internal channel.",28,[[["self"]],["c"]]],[0,"util","fancy_garbling","Tools useful for interacting with `fancy-garbling`.",null,null],[5,"tweak","fancy_garbling::util","Tweak function for a single item.",null,[[["usize"]],["block"]]],[5,"tweak2","","Tweak function for two items.",null,[[["u64"]],["block"]]],[5,"output_tweak","","Compute the output tweak for a garbled gate where i is the…",null,[[["u16"],["usize"]],["block"]]],[5,"base_q_add_eq","","Add a base `q` slice `ys` into `xs`.",null,[[["u16"]]]],[5,"digits_per_u128","","Determine how many `mod q` digits fit into a `u128`…",null,[[["u16"]],["usize"]]],[5,"as_base_q_u128","","Convert `x` into base `q`.",null,[[["u16"],["u128"]],[["u16"],["vec",["u16"]]]]],[5,"as_mixed_radix","","Convert `x` into mixed radix form using the provided…",null,[[["u128"]],[["u16"],["vec",["u16"]]]]],[5,"from_base_q","","Convert little-endian base `q` digits into `u128`.",null,[[["u16"]],["u128"]]],[5,"from_mixed_radix","","Convert little-endian mixed radix digits into u128.",null,[[],["u128"]]],[5,"u128_to_bits","","Get the bits of a u128 encoded in 128 u16s, which is…",null,[[["usize"],["u128"]],[["u16"],["vec",["u16"]]]]],[5,"u128_from_bits","","Convert into a u128 from the \"bits\" as u16. Assumes each…",null,[[],["u128"]]],[5,"factor","","Factor using the primes in the global `PRIMES` array.…",null,[[["u128"]],[["u16"],["vec",["u16"]]]]],[5,"crt","","Compute the CRT representation of x with respect to the…",null,[[["u128"]],[["u16"],["vec",["u16"]]]]],[5,"crt_factor","","Compute the CRT representation of `x` with respect to the…",null,[[["u128"]],[["u16"],["vec",["u16"]]]]],[5,"crt_inv","","Compute the value x given a list of CRT primes and residues.",null,[[],["u128"]]],[5,"crt_inv_factor","","Compute the value `x` given a composite CRT modulus…",null,[[["u128"]],["u128"]]],[5,"inv","","Generic algorithm to invert inp_a mod inp_b. As ref so as…",null,[[["i128"]],["i128"]]],[5,"modulus_with_nprimes","","Primes skipping the modulus 2, which allows certain…",null,[[["usize"]],["u128"]]],[5,"modulus_with_width","","Generate a CRT modulus that support at least n-bit…",null,[[["u32"]],["u128"]]],[5,"primes_with_width","","Generate the factors of a CRT modulus that support at…",null,[[["u32"]],[["u16"],["vec",["u16"]]]]],[5,"base_modulus_with_width","","Generate a CRT modulus that support at least n-bit…",null,[[["u32"]],["u128"]]],[5,"base_primes_with_width","","Generate the factors of a CRT modulus that support at…",null,[[["u32"]],[["u16"],["vec",["u16"]]]]],[5,"product","","Generate a CRT modulus that support at least n-bit…",null,[[],["u128"]]],[5,"is_power_of_2","","Raise a u16 to a power mod some value. Returns `true` if…",null,[[["u16"]],["bool"]]],[17,"NPRIMES","","Number of primes supported by our library.",null,null],[17,"PRIMES","","Primes used in fancy garbling.",null,null],[8,"RngExt","","Extra Rng functionality, useful for `fancy-garbling`.",null,null],[11,"gen_bool","","Randomly generate a `bool`.",29,[[["self"]],["bool"]]],[11,"gen_u16","","Randomly generate a `u16`.",29,[[["self"]],["u16"]]],[11,"gen_u32","","Randomly generate a `u32`.",29,[[["self"]],["u32"]]],[11,"gen_u64","","Randomly generate a `u64`.",29,[[["self"]],["u64"]]],[11,"gen_usize","","Randomly generate a `usize`.",29,[[["self"]],["usize"]]],[11,"gen_u128","","Randomly generate a `u128`.",29,[[["self"]],["u128"]]],[11,"gen_block","","Randomly generate a `Block`.",29,[[["self"]],["block"]]],[11,"gen_usable_block","","Randomly generate a valid `Block`.",29,[[["u16"],["self"]],["block"]]],[11,"gen_prime","","Randomly generate a prime (among the set of supported…",29,[[["self"]],["u16"]]],[11,"gen_modulus","","Randomly generate a (supported) modulus.",29,[[["self"]],["u16"]]],[11,"gen_usable_composite_modulus","","Randomly generate a valid composite modulus.",29,[[["self"]],["u128"]]],[11,"gen_usable_factors","","Randomly generate a vector of valid factor",29,[[["self"]],[["u16"],["vec",["u16"]]]]],[11,"digits","fancy_garbling","Get the digits of the wire.",0,[[["self"]],[["u16"],["vec",["u16"]]]]],[11,"from_block","","Unpack the wire represented by a `Block` with modulus `q`.…",0,[[["block"],["u16"]],["self"]]],[11,"as_block","","Pack the wire into a `Block`.",0,[[["self"]],["block"]]],[11,"zero","","The zero wire with modulus `q`.",0,[[["u16"]],["self"]]],[11,"rand_delta","","Get a random wire label mod `q`, with the first digit set…",0,[[["u16"],["r"]],["self"]]],[11,"color","","Get the color digit of the wire.",0,[[["self"]],["u16"]]],[11,"plus","","Add two wires digit-wise, returning a new wire.",0,[[["self"]],["self"]]],[11,"plus_eq","","Add another wire digit-wise into this one. Assumes that…",0,[[["wire"],["self"]],["wire"]]],[11,"plus_mov","","Add another wire into this one, consuming it for chained…",0,[[["wire"]],["wire"]]],[11,"cmul","","Multiply each digit by a constant `c mod q`, returning a…",0,[[["u16"],["self"]],["self"]]],[11,"cmul_eq","","Multiply each digit by a constant `c mod q`.",0,[[["u16"],["self"]],["wire"]]],[11,"cmul_mov","","Multiply each digit by a constant `c mod q`, consuming it…",0,[[["u16"]],["wire"]]],[11,"negate","","Negate all the digits `mod q`, returning a new wire.",0,[[["self"]],["self"]]],[11,"negate_eq","","Negate all the digits mod q.",0,[[["self"]],["wire"]]],[11,"negate_mov","","Negate all the digits `mod q`, consuming it for chained…",0,[[],["wire"]]],[11,"minus","","Subtract two wires, returning the result.",0,[[["wire"],["self"]],["wire"]]],[11,"minus_eq","","Subtract a wire from this one.",0,[[["wire"],["self"]],["wire"]]],[11,"minus_mov","","Subtract a wire from this one, consuming it for chained…",0,[[["wire"]],["wire"]]],[11,"rand","","Get a random wire `mod q`.",0,[[["u16"],["r"]],["wire"]]],[11,"hash","","Compute the hash of this wire.",0,[[["block"],["self"]],["block"]]],[11,"hashback","","Compute the hash of this wire, converting the result back…",0,[[["block"],["u16"],["self"]],["wire"]]],[8,"BinaryGadgets","","Extension trait for `Fancy` providing gadgets that operate…",null,null],[11,"bin_constant_bundle","","Create a constant bundle using base 2 inputs.",30,[[["self"],["usize"],["u128"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_output","","Output a binary bundle and interpret the result as a `u128`.",30,[[["self"],["binarybundle"]],[["option",["u128"]],["result",["option"]]]]],[11,"bin_outputs","","Output a slice of binary bundles and interpret the results…",30,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"bin_xor","","Xor the bits of two bundles together pairwise.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_and","","And the bits of two bundles together pairwise.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_or","","Or the bits of two bundles together pairwise.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_addition","","Binary addition. Returns the result and the carry.",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_addition_no_carry","","Binary addition. Avoids creating extra gates for the final…",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_multiplication_lower_half","","Binary multiplication.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_twos_complement","","Compute the twos complement of the input bundle (which…",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_subtraction","","Subtract two binary bundles. Returns the result and…",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else…",30,[[["usize"],["u128"],["self"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_cmul","","Write the constant in binary and that gives you the shift…",30,[[["usize"],["u128"],["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_abs","","Compute the absolute value of a binary bundle.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_lt","","Returns 1 if `x < y`.",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_geq","","Returns 1 if `x >= y`.",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_max","","Compute the maximum bundle in `xs`.",30,[[["self"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_demux","","Demux a binary bundle into a unary vector.",30,[[["self"],["binarybundle"]],[["result",["vec"]],["vec"]]]],[8,"BundleGadgets","","Extension trait for Fancy which provides Bundle…",null,null],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",31,[[["self"]],[["bundle"],["result",["bundle"]]]]],[11,"output_bundle","","Output the wires that make up a bundle.",31,[[["self"],["bundle"]],[["option",["vec"]],["result",["option"]]]]],[11,"output_bundles","","Output a slice of bundles.",31,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"add_bundles","","Add two wire bundles pairwise, zipping addition.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"mul_bundles","","Multiply each wire in `x` with each wire in `y`, pairwise.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"mixed_radix_addition","","Mixed radix addition.",31,[[["self"]],[["bundle"],["result",["bundle"]]]]],[11,"mixed_radix_addition_msb_only","","Mixed radix addition only returning the MSB.",31,[[["self"]],["result"]]],[11,"multiplex","","If b=0 then return x, else return y.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"mask","","If b=0 then return 0, else return x.",31,[[["bundle"],["self"]],[["bundle"],["result",["bundle"]]]]],[11,"shift","","Shift residues, replacing them with zeros in the modulus…",31,[[["self"],["usize"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",31,[[["self"],["bundle"]],["result"]]],[8,"CrtGadgets","","Extension trait for `Fancy` providing advanced CRT gadgets…",null,null],[11,"crt_constant_bundle","","Creates a bundle of constant wires for the CRT…",32,[[["self"],["u128"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_output","","Output a CRT bundle and interpret it mod Q.",32,[[["self"],["crtbundle"]],[["option",["u128"]],["result",["option"]]]]],[11,"crt_outputs","","Output a slice of CRT bundles and interpret the outputs…",32,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"crt_add","","Add two CRT bundles.",32,[[["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_sub","","Subtract two CRT bundles.",32,[[["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_cmul","","Multiplies each wire in `x` by the corresponding residue…",32,[[["u128"],["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_mul","","Multiply `x` with `y`.",32,[[["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_cexp","","Exponentiate `x` by the constant `c`.",32,[[["u16"],["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_rem","","Compute the remainder with respect to modulus `p`.",32,[[["u16"],["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_fractional_mixed_radix","","Helper function for advanced gadgets, returns the MSB of…",32,[[["self"],["crtbundle"]],["result"]]],[11,"crt_relu","","Compute `max(x,0)`.",32,[[["str"],["option"],["crtbundle"],["self"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_sign","","Return 0 if `x` is positive and 1 if `x` is negative.",32,[[["str"],["self"],["crtbundle"]],["result"]]],[11,"crt_sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is…",32,[[["str"],["option"],["crtbundle"],["self"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_lt","","Returns 1 if `x < y`.",32,[[["str"],["self"],["crtbundle"]],["result"]]],[11,"crt_geq","","Returns 1 if `x >= y`.",32,[[["str"],["self"],["crtbundle"]],["result"]]],[11,"crt_max","","Compute the maximum bundle in `xs`.",32,[[["str"],["self"]],[["result",["crtbundle"]],["crtbundle"]]]],[8,"FancyInput","","Convenience functions for encoding input to Fancy objects.",null,null],[16,"Item","","The type that this Fancy object operates over.",33,null],[16,"Error","","The type of error that this Fancy object emits.",33,null],[10,"encode_many","","Encode many values where the actual input is known.",33,[[["self"]],[["result",["vec"]],["vec"]]]],[10,"receive_many","","Receive many values where the input is not known.",33,[[["self"]],[["result",["vec"]],["vec"]]]],[11,"encode","","Encode a single value.",33,[[["u16"],["self"]],["result"]]],[11,"receive","","Receive a single value.",33,[[["u16"],["self"]],["result"]]],[11,"encode_bundle","","Encode a bundle.",33,[[["self"]],[["result",["bundle"]],["bundle"]]]],[11,"receive_bundle","","Receive a bundle.",33,[[["self"]],[["result",["bundle"]],["bundle"]]]],[11,"encode_bundles","","Encode many input bundles.",33,[[["self"]],[["result",["vec"]],["vec",["bundle"]]]]],[11,"receive_many_bundles","","Receive many input bundles.",33,[[["self"]],[["result",["vec"]],["vec",["bundle"]]]]],[11,"crt_encode","","Encode a CRT input bundle.",33,[[["self"],["u128"]],[["crtbundle"],["result",["crtbundle"]]]]],[11,"crt_receive","","Receive an CRT input bundle.",33,[[["self"],["u128"]],[["crtbundle"],["result",["crtbundle"]]]]],[11,"crt_encode_many","","Encode many CRT input bundles.",33,[[["self"],["u128"]],[["vec",["crtbundle"]],["result",["vec"]]]]],[11,"crt_receive_many","","Receive many CRT input bundles.",33,[[["self"],["usize"],["u128"]],[["vec",["crtbundle"]],["result",["vec"]]]]],[11,"bin_encode","","Encode a binary input bundle.",33,[[["self"],["usize"],["u128"]],[["result",["binarybundle"]],["binarybundle"]]]],[11,"bin_receive","","Receive an binary input bundle.",33,[[["self"],["usize"]],[["result",["binarybundle"]],["binarybundle"]]]],[11,"bin_encode_many","","Encode many binary input bundles.",33,[[["self"],["usize"]],[["vec",["binarybundle"]],["result",["vec"]]]]],[11,"bin_receive_many","","Receive many binary input bundles.",33,[[["self"],["usize"]],[["vec",["binarybundle"]],["result",["vec"]]]]],[8,"FancyReveal","","Trait to describe Fancy objects which can reveal outputs…",null,null],[10,"reveal","","Reveal the contents of `x` to all parties.",34,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"reveal_many","","Reveal a slice of items to all parties.",34,[[["self"]],[["result",["vec"]],["vec",["u16"]]]]],[11,"reveal_bundle","","Reveal a bundle to all parties.",34,[[["self"],["bundle"]],[["result",["vec"]],["vec",["u16"]]]]],[11,"reveal_many_bundles","","Reveal many bundles to all parties.",34,[[["self"]],[["vec",["vec"]],["result",["vec"]]]]],[11,"crt_reveal","","Reveal a CRT bundle to all parties.",34,[[["self"],["crtbundle"]],[["result",["u128"]],["u128"]]]],[11,"crt_reveal_many","","Reveal many CRT bundles to all parties.",34,[[["self"]],[["result",["vec"]],["vec",["u128"]]]]],[11,"bin_reveal","","Reveal a binary bundle to all parties.",34,[[["self"],["binarybundle"]],[["result",["u128"]],["u128"]]]],[11,"bin_reveal_many","","Reveal many binary bundles to all parties.",34,[[["self"]],[["result",["vec"]],["vec",["u128"]]]]],[8,"HasModulus","","An object that has some modulus. Basic object of `Fancy`…",null,null],[10,"modulus","","The modulus of the wire.",35,[[["self"]],["u16"]]],[8,"Fancy","","DSL for the basic computations supported by…",null,null],[16,"Item","","The underlying wire datatype created by an object…",36,null],[16,"Error","","Errors which may be thrown by the users of Fancy.",36,null],[10,"constant","","Create a constant `x` with modulus `q`.",36,[[["u16"],["self"]],["result"]]],[10,"add","","Add `x` and `y`.",36,[[["self"]],["result"]]],[10,"sub","","Subtract `x` and `y`.",36,[[["self"]],["result"]]],[10,"cmul","","Multiply `x` times the constant `c`.",36,[[["u16"],["self"]],["result"]]],[10,"mul","","Multiply `x` and `y`.",36,[[["self"]],["result"]]],[10,"proj","","Project `x` according to the truth table `tt`. Resulting…",36,[[["vec",["u16"]],["u16"],["self"],["option",["vec"]]],["result"]]],[10,"output","","Process this wire as output. Some `Fancy` implementors…",36,[[["self"]],[["option",["u16"]],["result",["option"]]]]],[11,"add_many","","Sum up a slice of wires.",36,[[["self"]],["result"]]],[11,"xor","","Xor is just addition, with the requirement that `x` and…",36,[[["self"]],["result"]]],[11,"negate","","Negate by xoring `x` with `1`.",36,[[["self"]],["result"]]],[11,"and","","And is just multiplication, with the requirement that `x`…",36,[[["self"]],["result"]]],[11,"or","","Or uses Demorgan's Rule implemented with multiplication…",36,[[["self"]],["result"]]],[11,"and_many","","Returns 1 if all wires equal 1.",36,[[["self"]],["result"]]],[11,"or_many","","Returns 1 if any wire equals 1.",36,[[["self"]],["result"]]],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a…",36,[[["u16"],["self"]],["result"]]],[11,"adder","","Binary adder. Returns the result and the carry.",36,[[["self"],["option"]],["result"]]],[11,"mux","","If `b = 0` returns `x` else `y`.",36,[[["self"]],["result"]]],[11,"mux_constant_bits","","If `x = 0` returns the constant `b1` else return `b2`.…",36,[[["self"],["bool"]],["result"]]],[11,"outputs","","Output a slice of wires.",36,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,[[["self"],["t"]]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"into_bits","","",20,[[],["u"]]],[11,"from_cast","","",20,[[["t"]],["t"]]],[11,"cast","","",20,[[],["u"]]],[11,"from_bits","","",20,[[["t"]],["t"]]],[11,"vzip","","",20,[[],["v"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"to_owned","","",21,[[["self"]],["t"]]],[11,"clone_into","","",21,[[["self"],["t"]]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"into_bits","","",21,[[],["u"]]],[11,"from_cast","","",21,[[["t"]],["t"]]],[11,"cast","","",21,[[],["u"]]],[11,"from_bits","","",21,[[["t"]],["t"]]],[11,"vzip","","",21,[[],["v"]]],[11,"from","","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"to_owned","","",22,[[["self"]],["t"]]],[11,"clone_into","","",22,[[["self"],["t"]]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"into_bits","","",22,[[],["u"]]],[11,"from_cast","","",22,[[["t"]],["t"]]],[11,"cast","","",22,[[],["u"]]],[11,"from_bits","","",22,[[["t"]],["t"]]],[11,"vzip","","",22,[[],["v"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"into_bits","","",23,[[],["u"]]],[11,"from_cast","","",23,[[["t"]],["t"]]],[11,"cast","","",23,[[],["u"]]],[11,"from_bits","","",23,[[["t"]],["t"]]],[11,"vzip","","",23,[[],["v"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"into","","",24,[[],["u"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"try_into","","",24,[[],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"type_id","","",24,[[["self"]],["typeid"]]],[11,"into_bits","","",24,[[],["u"]]],[11,"from_cast","","",24,[[["t"]],["t"]]],[11,"cast","","",24,[[],["u"]]],[11,"from_bits","","",24,[[["t"]],["t"]]],[11,"vzip","","",24,[[],["v"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"into_bits","","",0,[[],["u"]]],[11,"from_cast","","",0,[[["t"]],["t"]]],[11,"cast","","",0,[[],["u"]]],[11,"from_bits","","",0,[[["t"]],["t"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","fancy_garbling::circuit","",37,[[["t"]],["t"]]],[11,"into","","",37,[[],["u"]]],[11,"to_owned","","",37,[[["self"]],["t"]]],[11,"clone_into","","",37,[[["self"],["t"]]]],[11,"to_string","","",37,[[["self"]],["string"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"try_into","","",37,[[],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"type_id","","",37,[[["self"]],["typeid"]]],[11,"into_bits","","",37,[[],["u"]]],[11,"from_cast","","",37,[[["t"]],["t"]]],[11,"cast","","",37,[[],["u"]]],[11,"from_bits","","",37,[[["t"]],["t"]]],[11,"vzip","","",37,[[],["v"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,[[["self"],["t"]]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"into_bits","","",4,[[],["u"]]],[11,"from_cast","","",4,[[["t"]],["t"]]],[11,"cast","","",4,[[],["u"]]],[11,"from_bits","","",4,[[["t"]],["t"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"into_bits","","",5,[[],["u"]]],[11,"from_cast","","",5,[[["t"]],["t"]]],[11,"cast","","",5,[[],["u"]]],[11,"from_bits","","",5,[[["t"]],["t"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","fancy_garbling::classic","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"into_bits","","",6,[[],["u"]]],[11,"from_cast","","",6,[[["t"]],["t"]]],[11,"cast","","",6,[[],["u"]]],[11,"from_bits","","",6,[[["t"]],["t"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"into_bits","","",7,[[],["u"]]],[11,"from_cast","","",7,[[["t"]],["t"]]],[11,"cast","","",7,[[],["u"]]],[11,"from_bits","","",7,[[["t"]],["t"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"into_bits","","",8,[[],["u"]]],[11,"from_cast","","",8,[[["t"]],["t"]]],[11,"cast","","",8,[[],["u"]]],[11,"from_bits","","",8,[[["t"]],["t"]]],[11,"vzip","","",8,[[],["v"]]],[11,"from","fancy_garbling::dummy","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"into_bits","","",10,[[],["u"]]],[11,"from_cast","","",10,[[["t"]],["t"]]],[11,"cast","","",10,[[],["u"]]],[11,"from_bits","","",10,[[["t"]],["t"]]],[11,"vzip","","",10,[[],["v"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,[[["self"],["t"]]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"into_bits","","",9,[[],["u"]]],[11,"from_cast","","",9,[[["t"]],["t"]]],[11,"cast","","",9,[[],["u"]]],[11,"from_bits","","",9,[[["t"]],["t"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","fancy_garbling::errors","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"into_bits","","",11,[[],["u"]]],[11,"from_cast","","",11,[[["t"]],["t"]]],[11,"cast","","",11,[[],["u"]]],[11,"from_bits","","",11,[[["t"]],["t"]]],[11,"vzip","","",11,[[],["v"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"into_bits","","",14,[[],["u"]]],[11,"from_cast","","",14,[[["t"]],["t"]]],[11,"cast","","",14,[[],["u"]]],[11,"from_bits","","",14,[[["t"]],["t"]]],[11,"vzip","","",14,[[],["v"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"into_bits","","",15,[[],["u"]]],[11,"from_cast","","",15,[[["t"]],["t"]]],[11,"cast","","",15,[[],["u"]]],[11,"from_bits","","",15,[[["t"]],["t"]]],[11,"vzip","","",15,[[],["v"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_string","","",16,[[["self"]],["string"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"into_bits","","",16,[[],["u"]]],[11,"from_cast","","",16,[[["t"]],["t"]]],[11,"cast","","",16,[[],["u"]]],[11,"from_bits","","",16,[[["t"]],["t"]]],[11,"vzip","","",16,[[],["v"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"into_bits","","",17,[[],["u"]]],[11,"from_cast","","",17,[[["t"]],["t"]]],[11,"cast","","",17,[[],["u"]]],[11,"from_bits","","",17,[[["t"]],["t"]]],[11,"vzip","","",17,[[],["v"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"into_bits","","",18,[[],["u"]]],[11,"from_cast","","",18,[[["t"]],["t"]]],[11,"cast","","",18,[[],["u"]]],[11,"from_bits","","",18,[[["t"]],["t"]]],[11,"vzip","","",18,[[],["v"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"into_bits","","",19,[[],["u"]]],[11,"from_cast","","",19,[[["t"]],["t"]]],[11,"cast","","",19,[[],["u"]]],[11,"from_bits","","",19,[[["t"]],["t"]]],[11,"vzip","","",19,[[],["v"]]],[11,"from","fancy_garbling::informer","",25,[[["t"]],["t"]]],[11,"into","","",25,[[],["u"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"try_into","","",25,[[],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"type_id","","",25,[[["self"]],["typeid"]]],[11,"into_bits","","",25,[[],["u"]]],[11,"from_cast","","",25,[[["t"]],["t"]]],[11,"cast","","",25,[[],["u"]]],[11,"from_bits","","",25,[[["t"]],["t"]]],[11,"vzip","","",25,[[],["v"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"into","","",26,[[],["u"]]],[11,"to_owned","","",26,[[["self"]],["t"]]],[11,"clone_into","","",26,[[["self"],["t"]]]],[11,"to_string","","",26,[[["self"]],["string"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"try_into","","",26,[[],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"type_id","","",26,[[["self"]],["typeid"]]],[11,"into_bits","","",26,[[],["u"]]],[11,"from_cast","","",26,[[["t"]],["t"]]],[11,"cast","","",26,[[],["u"]]],[11,"from_bits","","",26,[[["t"]],["t"]]],[11,"vzip","","",26,[[],["v"]]],[11,"from","fancy_garbling::twopac::semihonest","",27,[[["t"]],["t"]]],[11,"into","","",27,[[],["u"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"try_into","","",27,[[],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"type_id","","",27,[[["self"]],["typeid"]]],[11,"into_bits","","",27,[[],["u"]]],[11,"from_cast","","",27,[[["t"]],["t"]]],[11,"cast","","",27,[[],["u"]]],[11,"from_bits","","",27,[[["t"]],["t"]]],[11,"vzip","","",27,[[],["v"]]],[11,"from","","",28,[[["t"]],["t"]]],[11,"into","","",28,[[],["u"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"try_into","","",28,[[],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"type_id","","",28,[[["self"]],["typeid"]]],[11,"into_bits","","",28,[[],["u"]]],[11,"from_cast","","",28,[[["t"]],["t"]]],[11,"cast","","",28,[[],["u"]]],[11,"from_bits","","",28,[[["t"]],["t"]]],[11,"vzip","","",28,[[],["v"]]],[11,"encode","fancy_garbling::dummy","Encode a single dummy value.",10,[[["u16"],["self"]],[["result",["dummyval","dummyerror"]],["dummyerror"],["dummyval"]]]],[11,"encode_many","","Encode a slice of inputs and a slice of moduli as DummyVals.",10,[[["self"]],[["dummyerror"],["result",["vec","dummyerror"]],["vec",["dummyval"]]]]],[11,"receive_many","","",10,[[["self"]],[["dummyerror"],["result",["vec","dummyerror"]],["vec",["dummyval"]]]]],[11,"receive_many","fancy_garbling::informer","",25,[[["self"]],[["result",["vec"]],["vec"]]]],[11,"encode_many","","",25,[[["self"]],[["result",["vec"]],["vec"]]]],[11,"receive","fancy_garbling::twopac::semihonest","Receive a garbler input wire.",27,[[["u16"],["self"]],[["result",["wire","twopacerror"]],["twopacerror"],["wire"]]]],[11,"receive_many","","Receive garbler input wires.",27,[[["self"]],[["vec",["wire"]],["twopacerror"],["result",["vec","twopacerror"]]]]],[11,"encode_many","","Perform OT and obtain wires for the evaluator's inputs.",27,[[["self"]],[["vec",["wire"]],["twopacerror"],["result",["vec","twopacerror"]]]]],[11,"encode","","",28,[[["u16"],["self"]],[["result",["wire","twopacerror"]],["twopacerror"],["wire"]]]],[11,"encode_many","","",28,[[["self"]],[["vec",["wire"]],["twopacerror"],["result",["vec","twopacerror"]]]]],[11,"receive_many","","",28,[[["self"]],[["vec",["wire"]],["twopacerror"],["result",["vec","twopacerror"]]]]],[11,"reveal","fancy_garbling::dummy","",10,[[["self"],["dummyval"]],[["u16"],["result",["u16","dummyerror"]],["dummyerror"]]]],[11,"reveal","fancy_garbling","",23,[[["wire"],["self"]],[["u16"],["result",["u16","evaluatorerror"]],["evaluatorerror"]]]],[11,"reveal","","",24,[[["wire"],["self"]],[["u16"],["result",["u16","garblererror"]],["garblererror"]]]],[11,"reveal","fancy_garbling::informer","",25,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"reveal","fancy_garbling::twopac::semihonest","",27,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"reveal","","",28,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"modulus","fancy_garbling::circuit","",37,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::dummy","",9,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling","",0,[[["self"]],["u16"]]],[11,"constant","fancy_garbling::circuit","",5,[[["u16"],["self"]],[["circuitref"],["result",["circuitref"]]]]],[11,"add","","",5,[[["self"],["circuitref"]],[["circuitref"],["result",["circuitref"]]]]],[11,"sub","","",5,[[["self"],["circuitref"]],[["circuitref"],["result",["circuitref"]]]]],[11,"cmul","","",5,[[["u16"],["self"],["circuitref"]],[["circuitref"],["result",["circuitref"]]]]],[11,"proj","","",5,[[["circuitref"],["vec",["u16"]],["u16"],["self"],["option",["vec"]]],[["circuitref"],["result",["circuitref"]]]]],[11,"mul","","",5,[[["self"],["circuitref"]],[["circuitref"],["result",["circuitref"]]]]],[11,"output","","",5,[[["self"],["circuitref"]],[["option",["u16"]],["result",["option"]]]]],[11,"constant","fancy_garbling::dummy","",10,[[["u16"],["self"]],[["result",["dummyval"]],["dummyval"]]]],[11,"add","","",10,[[["self"],["dummyval"]],[["result",["dummyval"]],["dummyval"]]]],[11,"sub","","",10,[[["self"],["dummyval"]],[["result",["dummyval"]],["dummyval"]]]],[11,"cmul","","",10,[[["u16"],["self"],["dummyval"]],[["result",["dummyval"]],["dummyval"]]]],[11,"mul","","",10,[[["self"],["dummyval"]],[["result",["dummyval"]],["dummyval"]]]],[11,"proj","","",10,[[["vec",["u16"]],["u16"],["self"],["option",["vec"]],["dummyval"]],[["result",["dummyval"]],["dummyval"]]]],[11,"output","","",10,[[["self"],["dummyval"]],[["option",["u16"]],["result",["option"]]]]],[11,"constant","fancy_garbling","",23,[[["u16"],["self"]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"add","","",23,[[["wire"],["self"]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"sub","","",23,[[["wire"],["self"]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"cmul","","",23,[[["wire"],["self"],["u16"]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"mul","","",23,[[["wire"],["self"]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"proj","","",23,[[["wire"],["vec",["u16"]],["u16"],["self"],["option",["vec"]]],[["evaluatorerror"],["result",["wire","evaluatorerror"]],["wire"]]]],[11,"output","","",23,[[["wire"],["self"]],[["evaluatorerror"],["result",["option","evaluatorerror"]],["option",["u16"]]]]],[11,"constant","","",24,[[["u16"],["self"]],[["wire"],["garblererror"],["result",["wire","garblererror"]]]]],[11,"add","","",24,[[["wire"],["self"]],[["wire"],["garblererror"],["result",["wire","garblererror"]]]]],[11,"sub","","",24,[[["wire"],["self"]],[["wire"],["garblererror"],["result",["wire","garblererror"]]]]],[11,"cmul","","",24,[[["wire"],["self"],["u16"]],[["wire"],["garblererror"],["result",["wire","garblererror"]]]]],[11,"mul","","",24,[[["wire"],["self"]],[["wire"],["garblererror"],["result",["wire","garblererror"]]]]],[11,"proj","","",24,[[["wire"],["vec",["u16"]],["u16"],["self"],["option",["vec"]]],[["wire"],["garblererror"],["result",["wire","garblererror"]]]]],[11,"output","","",24,[[["wire"],["self"]],[["garblererror"],["result",["option","garblererror"]],["option",["u16"]]]]],[11,"constant","fancy_garbling::informer","",25,[[["u16"],["self"]],["result"]]],[11,"add","","",25,[[["self"]],["result"]]],[11,"sub","","",25,[[["self"]],["result"]]],[11,"cmul","","",25,[[["u16"],["self"]],["result"]]],[11,"mul","","",25,[[["self"]],["result"]]],[11,"proj","","",25,[[["vec",["u16"]],["u16"],["self"],["option",["vec"]]],["result"]]],[11,"output","","",25,[[["self"]],[["option",["u16"]],["result",["option"]]]]],[11,"constant","fancy_garbling::twopac::semihonest","",27,[[["u16"],["self"]],["result"]]],[11,"add","","",27,[[["wire"],["self"]],["result"]]],[11,"sub","","",27,[[["wire"],["self"]],["result"]]],[11,"cmul","","",27,[[["wire"],["self"],["u16"]],["result"]]],[11,"mul","","",27,[[["wire"],["self"]],["result"]]],[11,"proj","","",27,[[["wire"],["vec",["u16"]],["u16"],["self"],["option",["vec"]]],["result"]]],[11,"output","","",27,[[["wire"],["self"]],[["option",["u16"]],["result",["option"]]]]],[11,"constant","","",28,[[["u16"],["self"]],["result"]]],[11,"add","","",28,[[["wire"],["self"]],["result"]]],[11,"sub","","",28,[[["wire"],["self"]],["result"]]],[11,"cmul","","",28,[[["wire"],["self"],["u16"]],["result"]]],[11,"mul","","",28,[[["wire"],["self"]],["result"]]],[11,"proj","","",28,[[["wire"],["vec",["u16"]],["u16"],["self"],["option",["vec"]]],["result"]]],[11,"output","","",28,[[["self"]],[["option",["u16"]],["result",["option"]]]]],[11,"from","fancy_garbling::errors","",14,[[["fancyerror"]],["dummyerror"]]],[11,"from","","",15,[[["fancyerror"]],["self"]]],[11,"from","","",15,[[["error"]],["self"]]],[11,"from","","",15,[[["recverror"]],["self"]]],[11,"from","","",16,[[["fancyerror"]],["self"]]],[11,"from","","",16,[[["error"]],["self"]]],[11,"from","","",16,[[["vec",["block"]],["senderror",["vec"]]],["self"]]],[11,"from","","",17,[[["fancyerror"]],["self"]]],[11,"from","","",18,[[["error"]],["circuitparsererror"]]],[11,"from","","",18,[[["error"]],["circuitparsererror"]]],[11,"from","","",18,[[["parseinterror"]],["circuitparsererror"]]],[11,"from","","",19,[[["error"]],["twopacerror"]]],[11,"from","","",19,[[["error"]],["twopacerror"]]],[11,"from","","",19,[[["evaluatorerror"]],["twopacerror"]]],[11,"from","","",19,[[["garblererror"]],["twopacerror"]]],[11,"from","","",19,[[["fancyerror"]],["twopacerror"]]],[11,"from","","",16,[[["twopacerror"]],["garblererror"]]],[11,"from","","",15,[[["twopacerror"]],["evaluatorerror"]]],[11,"from","fancy_garbling","",20,[[["bundle"]],["binarybundle"]]],[11,"from","","",22,[[["bundle"]],["crtbundle"]]],[11,"clone","fancy_garbling::circuit","",37,[[["self"]],["circuitref"]]],[11,"clone","","",4,[[["self"]],["circuit"]]],[11,"clone","fancy_garbling::dummy","",9,[[["self"]],["dummyval"]]],[11,"clone","fancy_garbling","",20,[[["self"]],["binarybundle"]]],[11,"clone","","",21,[[["self"]],["bundle"]]],[11,"clone","","",22,[[["self"]],["crtbundle"]]],[11,"clone","fancy_garbling::informer","",26,[[["self"]],["informerstats"]]],[11,"clone","fancy_garbling","",0,[[["self"]],["wire"]]],[11,"default","","",0,[[],["self"]]],[11,"eq","fancy_garbling::circuit","",37,[[["circuitref"],["self"]],["bool"]]],[11,"ne","","",37,[[["circuitref"],["self"]],["bool"]]],[11,"eq","","",4,[[["circuit"],["self"]],["bool"]]],[11,"ne","","",4,[[["circuit"],["self"]],["bool"]]],[11,"eq","fancy_garbling","",0,[[["wire"],["self"]],["bool"]]],[11,"ne","","",0,[[["wire"],["self"]],["bool"]]],[11,"deref","","",20,[[["self"]],["bundle"]]],[11,"deref","","",22,[[["self"]],["bundle"]]],[11,"deref","fancy_garbling::twopac::semihonest","",28,[[["self"]]]],[11,"deref_mut","","",28,[[["self"]],["gb"]]],[11,"fmt","fancy_garbling::circuit","",37,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::classic","",6,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",7,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",8,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::dummy","",9,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::errors","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::informer","",26,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::circuit","",37,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::errors","",11,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","fancy_garbling::informer","Print information about the fancy computation.",26,[[["formatter"],["self"]],["result"]]],[11,"index","fancy_garbling","",21,[[["self"],["usize"]]]],[11,"write","fancy_garbling::classic","",8,[[["self"]],[["result",["usize"]],["usize"]]]],[11,"flush","","",8,[[["self"]],["result"]]],[11,"deserialize","fancy_garbling::circuit","",37,[[["__d"]],["result"]]],[11,"deserialize","","",4,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling::classic","",6,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling","",0,[[["__d"]],["result"]]],[11,"serialize","fancy_garbling::circuit","",37,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling::classic","",6,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling","",0,[[["self"],["__s"]],["result"]]],[11,"bin_constant_bundle","","Create a constant bundle using base 2 inputs.",30,[[["self"],["usize"],["u128"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_output","","Output a binary bundle and interpret the result as a `u128`.",30,[[["self"],["binarybundle"]],[["option",["u128"]],["result",["option"]]]]],[11,"bin_outputs","","Output a slice of binary bundles and interpret the results…",30,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"bin_xor","","Xor the bits of two bundles together pairwise.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_and","","And the bits of two bundles together pairwise.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_or","","Or the bits of two bundles together pairwise.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_addition","","Binary addition. Returns the result and the carry.",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_addition_no_carry","","Binary addition. Avoids creating extra gates for the final…",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_multiplication_lower_half","","Binary multiplication.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_twos_complement","","Compute the twos complement of the input bundle (which…",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_subtraction","","Subtract two binary bundles. Returns the result and…",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else…",30,[[["usize"],["u128"],["self"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_cmul","","Write the constant in binary and that gives you the shift…",30,[[["usize"],["u128"],["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_abs","","Compute the absolute value of a binary bundle.",30,[[["self"],["binarybundle"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_lt","","Returns 1 if `x < y`.",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_geq","","Returns 1 if `x >= y`.",30,[[["self"],["binarybundle"]],["result"]]],[11,"bin_max","","Compute the maximum bundle in `xs`.",30,[[["self"]],[["binarybundle"],["result",["binarybundle"]]]]],[11,"bin_demux","","Demux a binary bundle into a unary vector.",30,[[["self"],["binarybundle"]],[["result",["vec"]],["vec"]]]],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",31,[[["self"]],[["bundle"],["result",["bundle"]]]]],[11,"output_bundle","","Output the wires that make up a bundle.",31,[[["self"],["bundle"]],[["option",["vec"]],["result",["option"]]]]],[11,"output_bundles","","Output a slice of bundles.",31,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"add_bundles","","Add two wire bundles pairwise, zipping addition.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"mul_bundles","","Multiply each wire in `x` with each wire in `y`, pairwise.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"mixed_radix_addition","","Mixed radix addition.",31,[[["self"]],[["bundle"],["result",["bundle"]]]]],[11,"mixed_radix_addition_msb_only","","Mixed radix addition only returning the MSB.",31,[[["self"]],["result"]]],[11,"multiplex","","If b=0 then return x, else return y.",31,[[["self"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"mask","","If b=0 then return 0, else return x.",31,[[["bundle"],["self"]],[["bundle"],["result",["bundle"]]]]],[11,"shift","","Shift residues, replacing them with zeros in the modulus…",31,[[["self"],["usize"],["bundle"]],[["bundle"],["result",["bundle"]]]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",31,[[["self"],["bundle"]],["result"]]],[11,"crt_constant_bundle","","Creates a bundle of constant wires for the CRT…",32,[[["self"],["u128"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_output","","Output a CRT bundle and interpret it mod Q.",32,[[["self"],["crtbundle"]],[["option",["u128"]],["result",["option"]]]]],[11,"crt_outputs","","Output a slice of CRT bundles and interpret the outputs…",32,[[["self"]],[["option",["vec"]],["result",["option"]]]]],[11,"crt_add","","Add two CRT bundles.",32,[[["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_sub","","Subtract two CRT bundles.",32,[[["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_cmul","","Multiplies each wire in `x` by the corresponding residue…",32,[[["u128"],["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_mul","","Multiply `x` with `y`.",32,[[["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_cexp","","Exponentiate `x` by the constant `c`.",32,[[["u16"],["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_rem","","Compute the remainder with respect to modulus `p`.",32,[[["u16"],["self"],["crtbundle"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_fractional_mixed_radix","","Helper function for advanced gadgets, returns the MSB of…",32,[[["self"],["crtbundle"]],["result"]]],[11,"crt_relu","","Compute `max(x,0)`.",32,[[["str"],["option"],["crtbundle"],["self"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_sign","","Return 0 if `x` is positive and 1 if `x` is negative.",32,[[["str"],["self"],["crtbundle"]],["result"]]],[11,"crt_sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is…",32,[[["str"],["option"],["crtbundle"],["self"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"crt_lt","","Returns 1 if `x < y`.",32,[[["str"],["self"],["crtbundle"]],["result"]]],[11,"crt_geq","","Returns 1 if `x >= y`.",32,[[["str"],["self"],["crtbundle"]],["result"]]],[11,"crt_max","","Compute the maximum bundle in `xs`.",32,[[["str"],["self"]],[["result",["crtbundle"]],["crtbundle"]]]],[11,"encode","","Encode a single value.",33,[[["u16"],["self"]],["result"]]],[11,"receive","","Receive a single value.",33,[[["u16"],["self"]],["result"]]],[11,"encode_bundle","","Encode a bundle.",33,[[["self"]],[["result",["bundle"]],["bundle"]]]],[11,"receive_bundle","","Receive a bundle.",33,[[["self"]],[["result",["bundle"]],["bundle"]]]],[11,"encode_bundles","","Encode many input bundles.",33,[[["self"]],[["result",["vec"]],["vec",["bundle"]]]]],[11,"receive_many_bundles","","Receive many input bundles.",33,[[["self"]],[["result",["vec"]],["vec",["bundle"]]]]],[11,"crt_encode","","Encode a CRT input bundle.",33,[[["self"],["u128"]],[["crtbundle"],["result",["crtbundle"]]]]],[11,"crt_receive","","Receive an CRT input bundle.",33,[[["self"],["u128"]],[["crtbundle"],["result",["crtbundle"]]]]],[11,"crt_encode_many","","Encode many CRT input bundles.",33,[[["self"],["u128"]],[["vec",["crtbundle"]],["result",["vec"]]]]],[11,"crt_receive_many","","Receive many CRT input bundles.",33,[[["self"],["usize"],["u128"]],[["vec",["crtbundle"]],["result",["vec"]]]]],[11,"bin_encode","","Encode a binary input bundle.",33,[[["self"],["usize"],["u128"]],[["result",["binarybundle"]],["binarybundle"]]]],[11,"bin_receive","","Receive an binary input bundle.",33,[[["self"],["usize"]],[["result",["binarybundle"]],["binarybundle"]]]],[11,"bin_encode_many","","Encode many binary input bundles.",33,[[["self"],["usize"]],[["vec",["binarybundle"]],["result",["vec"]]]]],[11,"bin_receive_many","","Receive many binary input bundles.",33,[[["self"],["usize"]],[["vec",["binarybundle"]],["result",["vec"]]]]],[11,"reveal_many","","Reveal a slice of items to all parties.",34,[[["self"]],[["result",["vec"]],["vec",["u16"]]]]],[11,"reveal_bundle","","Reveal a bundle to all parties.",34,[[["self"],["bundle"]],[["result",["vec"]],["vec",["u16"]]]]],[11,"reveal_many_bundles","","Reveal many bundles to all parties.",34,[[["self"]],[["vec",["vec"]],["result",["vec"]]]]],[11,"crt_reveal","","Reveal a CRT bundle to all parties.",34,[[["self"],["crtbundle"]],[["result",["u128"]],["u128"]]]],[11,"crt_reveal_many","","Reveal many CRT bundles to all parties.",34,[[["self"]],[["result",["vec"]],["vec",["u128"]]]]],[11,"bin_reveal","","Reveal a binary bundle to all parties.",34,[[["self"],["binarybundle"]],[["result",["u128"]],["u128"]]]],[11,"bin_reveal_many","","Reveal many binary bundles to all parties.",34,[[["self"]],[["result",["vec"]],["vec",["u128"]]]]],[11,"add_many","","Sum up a slice of wires.",36,[[["self"]],["result"]]],[11,"xor","","Xor is just addition, with the requirement that `x` and…",36,[[["self"]],["result"]]],[11,"negate","","Negate by xoring `x` with `1`.",36,[[["self"]],["result"]]],[11,"and","","And is just multiplication, with the requirement that `x`…",36,[[["self"]],["result"]]],[11,"or","","Or uses Demorgan's Rule implemented with multiplication…",36,[[["self"]],["result"]]],[11,"and_many","","Returns 1 if all wires equal 1.",36,[[["self"]],["result"]]],[11,"or_many","","Returns 1 if any wire equals 1.",36,[[["self"]],["result"]]],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a…",36,[[["u16"],["self"]],["result"]]],[11,"adder","","Binary adder. Returns the result and the carry.",36,[[["self"],["option"]],["result"]]],[11,"mux","","If `b = 0` returns `x` else `y`.",36,[[["self"]],["result"]]],[11,"mux_constant_bits","","If `x = 0` returns the constant `b1` else return `b2`.…",36,[[["self"],["bool"]],["result"]]],[11,"outputs","","Output a slice of wires.",36,[[["self"]],[["option",["vec"]],["result",["option"]]]]]],"p":[[4,"Wire"],[13,"Mod2"],[13,"Mod3"],[13,"ModN"],[3,"Circuit"],[3,"CircuitBuilder"],[3,"GarbledCircuit"],[3,"Encoder"],[3,"GarbledWriter"],[3,"DummyVal"],[3,"Dummy"],[4,"FancyError"],[13,"InvalidArgNum"],[13,"InvalidArgMod"],[4,"DummyError"],[4,"EvaluatorError"],[4,"GarblerError"],[4,"CircuitBuilderError"],[4,"CircuitParserError"],[4,"TwopacError"],[3,"BinaryBundle"],[3,"Bundle"],[3,"CrtBundle"],[3,"Evaluator"],[3,"Garbler"],[3,"Informer"],[3,"InformerStats"],[3,"Evaluator"],[3,"Garbler"],[8,"RngExt"],[8,"BinaryGadgets"],[8,"BundleGadgets"],[8,"CrtGadgets"],[8,"FancyInput"],[8,"FancyReveal"],[8,"HasModulus"],[8,"Fancy"],[3,"CircuitRef"]]};
searchIndex["ocelot"] = {"doc":"`ocelot`: A rust library for oblivious transfer","i":[[4,"Error","ocelot","Errors produced by `ocelot`.",null,null],[13,"InvalidInputLength","","The input length is invalid.",0,null],[13,"IoError","","An I/O error has occurred.",0,null],[13,"Other","","Some other error, given by `String`.",0,null],[13,"CoinTossError","","Coin tossing failed.",0,null],[0,"oprf","","Oblivious PRF traits + instantiations.",null,null],[0,"kkrt","ocelot::oprf","Implementation of the batched, related-key oblivious…",null,null],[3,"Sender","ocelot::oprf::kkrt","KKRT oblivious PRF sender.",null,null],[3,"Receiver","","KKRT oblivious PRF receiver.",null,null],[11,"encode","","Encode `input` into `output`. This is not the same as the…",1,[[["self"]]]],[0,"kmprt","ocelot::oprf","Implementation of the hash-based multi-use OPPRF of…",null,null],[3,"Sender","ocelot::oprf::kmprt","KMPRT hashing-based OPPRF sender.",null,null],[3,"Receiver","","KMPRT oblivious programmable PRF receiver.",null,null],[11,"init","","Initialize the OPPRF sender.",2,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","Run the OPPRF for `ninputs` inputs with the pairs given in…",2,[[["usize"],["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"init","","Initialize the OPPRF receiver.",3,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","Run the OPPRF on inputs provided by the `inputs` slice.",3,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec",["block512"]],["error"]]]],[6,"KkrtSender","ocelot::oprf","KKRT oblivious PRF sender using ALSZ OT extension with…",null,null],[6,"KkrtReceiver","","KKRT oblivious PRF receiver using ALSZ OT extension with…",null,null],[6,"KmprtSender","","KMPRT hash-based OPPRF sender, using KKRT as the…",null,null],[6,"KmprtReceiver","","KMPRT hash-based OPPRF receiver, using KKRT as the…",null,null],[8,"ObliviousPrf","","Trait containing the associated types used by an oblivious…",null,null],[16,"Seed","","PRF seed.",4,null],[16,"Input","","PRF input.",4,null],[16,"Output","","PRF output.",4,null],[8,"Sender","","Trait for an oblivious PRF sender.",null,null],[10,"init","","Runs any one-time initialization.",5,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[10,"send","","Runs `m` OPRF instances as the sender, returning the OPRF…",5,[[["usize"],["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[10,"compute","","Computes the oblivious PRF on seed `seed` and input `input`.",5,[[["self"]]]],[8,"Receiver","","Trait for an oblivious PRF receiver.",null,null],[10,"init","","Runs any one-time initialization.",6,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[10,"receive","","Runs the oblivious PRF on inputs `inputs`, returning the…",6,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["error"],["vec"]]]],[0,"ot","ocelot","Oblivious transfer traits + instantiations.",null,null],[0,"alsz","ocelot::ot","Implementation of the Asharov-Lindell-Schneider-Zohner…",null,null],[3,"Sender","ocelot::ot::alsz","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[0,"chou_orlandi","ocelot::ot","Implementation of the Chou-Orlandi oblivious transfer…",null,null],[3,"Sender","ocelot::ot::chou_orlandi","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[0,"dummy","ocelot::ot","Implementation of an entirely insecure oblivious transfer…",null,null],[3,"Sender","ocelot::ot::dummy","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[0,"kos","ocelot::ot","Implementation of the Keller-Orsini-Scholl oblivious…",null,null],[3,"Sender","ocelot::ot::kos","Oblivious transfer extension sender.",null,null],[3,"Receiver","","Oblivious transfer extension receiver.",null,null],[0,"naor_pinkas","ocelot::ot","Implementation of the Naor-Pinkas oblivious transfer…",null,null],[3,"Sender","ocelot::ot::naor_pinkas","Oblivious transfer sender.",null,null],[3,"Receiver","","Oblivious transfer receiver.",null,null],[6,"ChouOrlandiSender","ocelot::ot","Instantiation of the Chou-Orlandi OT sender.",null,null],[6,"ChouOrlandiReceiver","","Instantiation of the Chou-Orlandi OT receiver.",null,null],[6,"DummySender","","Instantiation of the dummy OT sender.",null,null],[6,"DummyReceiver","","Instantiation of the dummy OT receiver.",null,null],[6,"NaorPinkasSender","","Instantiation of the Naor-Pinkas OT sender.",null,null],[6,"NaorPinkasReceiver","","Instantiation of the Naor-Pinkas OT receiver.",null,null],[6,"AlszSender","","Instantiation of the ALSZ OT extension sender, using…",null,null],[6,"AlszReceiver","","Instantiation of the ALSZ OT extension receiver, using…",null,null],[6,"KosSender","","Instantiation of the KOS OT extension sender, using…",null,null],[6,"KosReceiver","","Instantiation of the KOS OT extension receiver, using…",null,null],[8,"Sender","","Trait for one-out-of-two oblivious transfer from the…",null,null],[16,"Msg","","Message type, restricted to types that are…",7,null],[10,"init","","Runs any one-time initialization to create the oblivious…",7,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[10,"send","","Sends messages.",7,[[["c"],["self"],["rng"]],[["result",["error"]],["error"]]]],[8,"Receiver","","Trait for one-out-of-two oblivious transfer from the…",null,null],[16,"Msg","","Message type, restricted to types that are…",8,null],[10,"init","","Runs any one-time initialization to create the oblivious…",8,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[10,"receive","","Receives messages.",8,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[8,"CorrelatedSender","","Trait for one-out-of-two correlated oblivious transfer…",null,null],[10,"send_correlated","","Correlated oblivious transfer send. Takes as input an…",9,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[8,"CorrelatedReceiver","","Trait for one-out-of-two correlated oblivious transfer…",null,null],[10,"receive_correlated","","Correlated oblivious transfer receive.",10,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[8,"RandomSender","","Trait for one-out-of-two random oblivious transfer from…",null,null],[10,"send_random","","Random oblivious transfer send. Returns a vector of tuples…",11,[[["usize"],["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[8,"RandomReceiver","","Trait for one-out-of-two random oblivious transfer from…",null,null],[10,"receive_random","","Random oblivious transfer receive.",12,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"from","ocelot","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"into_bits","","",0,[[],["u"]]],[11,"from_cast","","",0,[[["t"]],["t"]]],[11,"cast","","",0,[[],["u"]]],[11,"from_bits","","",0,[[["t"]],["t"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","ocelot::oprf::kkrt","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"into_bits","","",1,[[],["u"]]],[11,"from_cast","","",1,[[["t"]],["t"]]],[11,"cast","","",1,[[],["u"]]],[11,"from_bits","","",1,[[["t"]],["t"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"into_bits","","",13,[[],["u"]]],[11,"from_cast","","",13,[[["t"]],["t"]]],[11,"cast","","",13,[[],["u"]]],[11,"from_bits","","",13,[[["t"]],["t"]]],[11,"vzip","","",13,[[],["v"]]],[11,"from","ocelot::oprf::kmprt","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"into_bits","","",2,[[],["u"]]],[11,"from_cast","","",2,[[["t"]],["t"]]],[11,"cast","","",2,[[],["u"]]],[11,"from_bits","","",2,[[["t"]],["t"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"into_bits","","",3,[[],["u"]]],[11,"from_cast","","",3,[[["t"]],["t"]]],[11,"cast","","",3,[[],["u"]]],[11,"from_bits","","",3,[[["t"]],["t"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","ocelot::ot::alsz","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"to_string","","",14,[[["self"]],["string"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"into_bits","","",14,[[],["u"]]],[11,"from_cast","","",14,[[["t"]],["t"]]],[11,"cast","","",14,[[],["u"]]],[11,"from_bits","","",14,[[["t"]],["t"]]],[11,"vzip","","",14,[[],["v"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"into","","",15,[[],["u"]]],[11,"to_string","","",15,[[["self"]],["string"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"try_into","","",15,[[],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"type_id","","",15,[[["self"]],["typeid"]]],[11,"into_bits","","",15,[[],["u"]]],[11,"from_cast","","",15,[[["t"]],["t"]]],[11,"cast","","",15,[[],["u"]]],[11,"from_bits","","",15,[[["t"]],["t"]]],[11,"vzip","","",15,[[],["v"]]],[11,"from","ocelot::ot::chou_orlandi","",16,[[["t"]],["t"]]],[11,"into","","",16,[[],["u"]]],[11,"to_string","","",16,[[["self"]],["string"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"try_into","","",16,[[],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"type_id","","",16,[[["self"]],["typeid"]]],[11,"into_bits","","",16,[[],["u"]]],[11,"from_cast","","",16,[[["t"]],["t"]]],[11,"cast","","",16,[[],["u"]]],[11,"from_bits","","",16,[[["t"]],["t"]]],[11,"vzip","","",16,[[],["v"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"into","","",17,[[],["u"]]],[11,"to_string","","",17,[[["self"]],["string"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"try_into","","",17,[[],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"type_id","","",17,[[["self"]],["typeid"]]],[11,"into_bits","","",17,[[],["u"]]],[11,"from_cast","","",17,[[["t"]],["t"]]],[11,"cast","","",17,[[],["u"]]],[11,"from_bits","","",17,[[["t"]],["t"]]],[11,"vzip","","",17,[[],["v"]]],[11,"from","ocelot::ot::dummy","",18,[[["t"]],["t"]]],[11,"into","","",18,[[],["u"]]],[11,"to_string","","",18,[[["self"]],["string"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"try_into","","",18,[[],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"type_id","","",18,[[["self"]],["typeid"]]],[11,"into_bits","","",18,[[],["u"]]],[11,"from_cast","","",18,[[["t"]],["t"]]],[11,"cast","","",18,[[],["u"]]],[11,"from_bits","","",18,[[["t"]],["t"]]],[11,"vzip","","",18,[[],["v"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"into","","",19,[[],["u"]]],[11,"to_string","","",19,[[["self"]],["string"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"try_into","","",19,[[],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"type_id","","",19,[[["self"]],["typeid"]]],[11,"into_bits","","",19,[[],["u"]]],[11,"from_cast","","",19,[[["t"]],["t"]]],[11,"cast","","",19,[[],["u"]]],[11,"from_bits","","",19,[[["t"]],["t"]]],[11,"vzip","","",19,[[],["v"]]],[11,"from","ocelot::ot::kos","",20,[[["t"]],["t"]]],[11,"into","","",20,[[],["u"]]],[11,"to_string","","",20,[[["self"]],["string"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"try_into","","",20,[[],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"type_id","","",20,[[["self"]],["typeid"]]],[11,"into_bits","","",20,[[],["u"]]],[11,"from_cast","","",20,[[["t"]],["t"]]],[11,"cast","","",20,[[],["u"]]],[11,"from_bits","","",20,[[["t"]],["t"]]],[11,"vzip","","",20,[[],["v"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"into","","",21,[[],["u"]]],[11,"to_string","","",21,[[["self"]],["string"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"try_into","","",21,[[],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"type_id","","",21,[[["self"]],["typeid"]]],[11,"into_bits","","",21,[[],["u"]]],[11,"from_cast","","",21,[[["t"]],["t"]]],[11,"cast","","",21,[[],["u"]]],[11,"from_bits","","",21,[[["t"]],["t"]]],[11,"vzip","","",21,[[],["v"]]],[11,"from","ocelot::ot::naor_pinkas","",22,[[["t"]],["t"]]],[11,"into","","",22,[[],["u"]]],[11,"to_string","","",22,[[["self"]],["string"]]],[11,"try_from","","",22,[[["u"]],["result"]]],[11,"try_into","","",22,[[],["result"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"type_id","","",22,[[["self"]],["typeid"]]],[11,"into_bits","","",22,[[],["u"]]],[11,"from_cast","","",22,[[["t"]],["t"]]],[11,"cast","","",22,[[],["u"]]],[11,"from_bits","","",22,[[["t"]],["t"]]],[11,"vzip","","",22,[[],["v"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"into","","",23,[[],["u"]]],[11,"to_string","","",23,[[["self"]],["string"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"try_into","","",23,[[],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"type_id","","",23,[[["self"]],["typeid"]]],[11,"into_bits","","",23,[[],["u"]]],[11,"from_cast","","",23,[[["t"]],["t"]]],[11,"cast","","",23,[[],["u"]]],[11,"from_bits","","",23,[[["t"]],["t"]]],[11,"vzip","","",23,[[],["v"]]],[11,"init","ocelot::oprf::kkrt","",1,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","",1,[[["usize"],["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"compute","","",1,[[["self"]]]],[11,"init","","",13,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","",13,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["error"],["vec"]]]],[11,"init","ocelot::ot::alsz","",14,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","",14,[[["c"],["self"],["rng"]],[["result",["error"]],["error"]]]],[11,"init","ocelot::ot::chou_orlandi","",16,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","",16,[[["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"init","ocelot::ot::dummy","",18,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","",18,[[["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"init","ocelot::ot::kos","",20,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","",20,[[["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"init","ocelot::ot::naor_pinkas","",22,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"send","","",22,[[["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"init","ocelot::ot::alsz","",15,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","",15,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"init","ocelot::ot::chou_orlandi","",17,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","",17,[[["rng"],["c"],["self"]],[["error"],["vec",["block"]],["result",["vec","error"]]]]],[11,"init","ocelot::ot::dummy","",19,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","",19,[[["rng"],["c"],["self"]],[["error"],["vec",["block"]],["result",["vec","error"]]]]],[11,"init","ocelot::ot::kos","",21,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","",21,[[["rng"],["c"],["self"]],[["error"],["vec",["block"]],["result",["vec","error"]]]]],[11,"init","ocelot::ot::naor_pinkas","",23,[[["c"],["rng"]],[["error"],["result",["error"]]]]],[11,"receive","","",23,[[["rng"],["c"],["self"]],[["error"],["vec",["block"]],["result",["vec","error"]]]]],[11,"send_correlated","ocelot::ot::alsz","",14,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"send_correlated","ocelot::ot::kos","",20,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"receive_correlated","ocelot::ot::alsz","",15,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"receive_correlated","ocelot::ot::kos","",21,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"send_random","ocelot::ot::alsz","",14,[[["usize"],["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"send_random","ocelot::ot::kos","",20,[[["usize"],["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"receive_random","ocelot::ot::alsz","",15,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"receive_random","ocelot::ot::kos","",21,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["vec"],["error"]]]],[11,"from","ocelot","",0,[[["error"]],["error"]]],[11,"from","","",0,[[["error"]],["error"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","ocelot::ot::alsz","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",15,[[["formatter"],["self"]],["result"]]],[11,"fmt","ocelot::ot::chou_orlandi","",16,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",17,[[["formatter"],["self"]],["result"]]],[11,"fmt","ocelot::ot::dummy","",18,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",19,[[["formatter"],["self"]],["result"]]],[11,"fmt","ocelot::ot::kos","",20,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",21,[[["formatter"],["self"]],["result"]]],[11,"fmt","ocelot::ot::naor_pinkas","",22,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",23,[[["formatter"],["self"]],["result"]]]],"p":[[4,"Error"],[3,"Sender"],[3,"Sender"],[3,"Receiver"],[8,"ObliviousPrf"],[8,"Sender"],[8,"Receiver"],[8,"Sender"],[8,"Receiver"],[8,"CorrelatedSender"],[8,"CorrelatedReceiver"],[8,"RandomSender"],[8,"RandomReceiver"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"Receiver"]]};
searchIndex["popsicle"] = {"doc":"`popsicle`: A rust library for private set intersection","i":[[4,"Error","popsicle","Errors produced by the private set intersection protocols.",null,null],[13,"CoinTossError","","Coin tossing failed.",0,null],[13,"OprfError","","The underlying oblivious PRF failed.",0,null],[13,"IoError","","An input/output error occurred.",0,null],[13,"CuckooHashFull","","The cuckoo hash is full.",0,null],[13,"InvalidCuckooSetSize","","The provided cuckoo hash set size is invalid.",0,null],[13,"InvalidCuckooParameters","","The provided cuckoo hash parameters are invalid.",0,null],[12,"nitems","popsicle::Error","Number of items.",1,null],[12,"nhashes","","Number of hashes.",1,null],[13,"PsiProtocolError","popsicle","An error occurred in the PSI protocol.",0,null],[13,"InvalidPayloadsLength","","Not enough payloads.",0,null],[13,"SSLError","","SSL Error",0,null],[13,"TwopcError","","An error occurred in the underlying 2PC protocol.",0,null],[0,"kmprt","","Implementation of the…",null,null],[3,"Sender","popsicle::kmprt","KMPRT sender - there can be many of these.",null,null],[3,"Receiver","","KMPRT receiver - there can only be one of these.",null,null],[6,"PartyId","","The party number for each party.",null,null],[0,"psty","popsicle","Implementation of the Pinkas-Schneider-Tkachenko-Yanai…",null,null],[3,"Sender","popsicle::psty","Private set intersection sender.",null,null],[3,"SenderState","","State of the sender.",null,null],[3,"Receiver","","Private set intersection receiver.",null,null],[3,"ReceiverState","","State of the receiver.",null,null],[6,"Msg","","The type of values in the sender and receiver's sets.",null,null],[0,"psz","popsicle","Implementation of the Pinkas-Schneider-Zohner private set…",null,null],[3,"Sender","popsicle::psz","Private set intersection sender.",null,null],[3,"Receiver","","Private set intersection receiver.",null,null],[6,"Sender","popsicle","Private set intersection sender.",null,null],[6,"Receiver","","Private set intersection receiver.",null,null],[6,"ExtendedSender","","Extended private set intersection sender.",null,null],[6,"ExtendedReceiver","","Extended private set intersection receiver.",null,null],[6,"MultiPartySender","","Multi-party private set intersection sender.",null,null],[6,"MultiPartyReceiver","","Multi-party private set intersection receiver.",null,null],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"into_bits","","",0,[[],["u"]]],[11,"from_cast","","",0,[[["t"]],["t"]]],[11,"cast","","",0,[[],["u"]]],[11,"from_bits","","",0,[[["t"]],["t"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","popsicle::kmprt","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"into_bits","","",2,[[],["u"]]],[11,"from_cast","","",2,[[["t"]],["t"]]],[11,"cast","","",2,[[],["u"]]],[11,"from_bits","","",2,[[["t"]],["t"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"into_bits","","",3,[[],["u"]]],[11,"from_cast","","",3,[[["t"]],["t"]]],[11,"cast","","",3,[[],["u"]]],[11,"from_bits","","",3,[[["t"]],["t"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","popsicle::psty","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"into_bits","","",4,[[],["u"]]],[11,"from_cast","","",4,[[["t"]],["t"]]],[11,"cast","","",4,[[],["u"]]],[11,"from_bits","","",4,[[["t"]],["t"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"into_bits","","",5,[[],["u"]]],[11,"from_cast","","",5,[[["t"]],["t"]]],[11,"cast","","",5,[[],["u"]]],[11,"from_bits","","",5,[[["t"]],["t"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"into_bits","","",6,[[],["u"]]],[11,"from_cast","","",6,[[["t"]],["t"]]],[11,"cast","","",6,[[],["u"]]],[11,"from_bits","","",6,[[["t"]],["t"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"into_bits","","",7,[[],["u"]]],[11,"from_cast","","",7,[[["t"]],["t"]]],[11,"cast","","",7,[[],["u"]]],[11,"from_bits","","",7,[[["t"]],["t"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","popsicle::psz","",8,[[["t"]],["t"]]],[11,"into","","",8,[[],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"try_into","","",8,[[],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"type_id","","",8,[[["self"]],["typeid"]]],[11,"into_bits","","",8,[[],["u"]]],[11,"from_cast","","",8,[[["t"]],["t"]]],[11,"cast","","",8,[[],["u"]]],[11,"from_bits","","",8,[[["t"]],["t"]]],[11,"vzip","","",8,[[],["v"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"into_bits","","",9,[[],["u"]]],[11,"from_cast","","",9,[[["t"]],["t"]]],[11,"cast","","",9,[[],["u"]]],[11,"from_bits","","",9,[[["t"]],["t"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","popsicle","",0,[[["errorstack"]],["error"]]],[11,"from","","",0,[[["error"]],["error"]]],[11,"from","","",0,[[["error"]],["error"]]],[11,"from","","",0,[[["error"]],["error"]]],[11,"from","","",0,[[["twopacerror"]],["error"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"init","popsicle::kmprt","Initialize a PSI sender.",2,[[["rng"],["partyid"]],[["result",["error"]],["error"]]]],[11,"send","","Send inputs to all parties and particpate in one party…",2,[[["rng"],["self"]],[["result",["error"]],["error"]]]],[11,"init","","Initialize the PSI receiver.",3,[[["rng"]],[["result",["error"]],["error"]]]],[11,"receive","","Send inputs and receive result - only one party should…",3,[[["rng"],["self"]],[["result",["vec","error"]],["error"],["vec",["block"]]]]],[11,"init","popsicle::psty","Initialize the PSI sender.",4,[[["c"],["rng"]],[["result",["error"]],["error"]]]],[11,"send","","Run the PSI protocol over `inputs`.",4,[[["rng"],["c"],["self"]],[["error"],["senderstate"],["result",["senderstate","error"]]]]],[11,"compute_setup","","Run the setup phase, producing a garbler for the next stage.",5,[[["c"],["self"],["rng"]],[["result",["error"]],["error"]]]],[11,"compute_intersection","","Compute the intersection.",5,[[["c"],["self"],["rng"]],[["result",["error"]],["error"]]]],[11,"compute_cardinality","","Compute the cardinality of the intersection.",5,[[["c"],["self"],["rng"]],[["result",["error"]],["error"]]]],[11,"receive_payloads","","Receive encrypted payloads from the Sender.",5,[[["c"],["self"],["usize"]],[["error"],["vec",["vec"]],["result",["vec","error"]]]]],[11,"init","","Initialize the PSI receiver.",6,[[["c"],["rng"]],[["result",["error"]],["error"]]]],[11,"receive","","Run the PSI protocol over `inputs`.",6,[[["rng"],["c"],["self"]],[["error"],["result",["receiverstate","error"]],["receiverstate"]]]],[11,"compute_setup","","Run the setup phase, producing an evaluator for the next…",7,[[["c"],["self"],["rng"]],[["error"],["result",["error"]]]]],[11,"compute_intersection","","Compute the intersection.",7,[[["c"],["self"],["rng"]],[["result",["vec","error"]],["vec",["msg"]],["error"]]]],[11,"compute_cardinality","","Compute the cardinality of the intersection.",7,[[["c"],["self"],["rng"]],[["error"],["result",["usize","error"]],["usize"]]]],[11,"send_payloads","","Send encrypted payloads to the Receiver, who can only…",7,[[["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"init","popsicle::psz","Initialize the PSI sender.",8,[[["c"],["rng"]],[["result",["error"]],["error"]]]],[11,"send","","Run the PSI protocol over `inputs`.",8,[[["rng"],["c"],["self"]],[["result",["error"]],["error"]]]],[11,"send_payloads","","Run the PSI protocol over `inputs`. Returns a random key…",8,[[["rng"],["c"],["self"]],[["result",["vec","error"]],["error"],["vec",["block"]]]]],[11,"init","","Initialize the PSI receiver.",9,[[["c"],["rng"]],[["result",["error"]],["error"]]]],[11,"receive","","Run the PSI protocol over `inputs`.",9,[[["rng"],["c"],["self"]],[["error"],["vec",["vec"]],["result",["vec","error"]]]]],[11,"receive_payloads","","Run the PSI protocol over `inputs`, receiving a vector of…",9,[[["rng"],["c"],["self"]],[["hashmap",["vec","block"]],["result",["hashmap","error"]],["error"]]]]],"p":[[4,"Error"],[13,"InvalidCuckooParameters"],[3,"Sender"],[3,"Receiver"],[3,"Sender"],[3,"SenderState"],[3,"Receiver"],[3,"ReceiverState"],[3,"Sender"],[3,"Receiver"]]};
searchIndex["scuttlebutt"] = {"doc":"The `scuttlebutt` multi-party computation utilities…","i":[[3,"Aes128","scuttlebutt","AES-128, encryption only.",null,null],[3,"Aes256","","AES-256, encryption only.",null,null],[3,"Block","","A 128-bit chunk.",null,null],[12,"0","","",0,null],[3,"Block512","","A 512-bit value.",null,null],[3,"HashChannel","","An instantiation of the `AbstractChannel` trait which…",null,null],[3,"SyncChannel","","A channel that implements `AbstractChannel` as well as…",null,null],[3,"TrackChannel","","A channel for tracking the number of bits read/written.",null,null],[3,"AesHash","","AES-based correlation-robust hash function.",null,null],[3,"AesRng","","Implementation of a random number generator based on…",null,null],[5,"track_unix_channel_pair","","Convenience function to create a pair of TrackUnixChannels…",null,[[]]],[5,"unix_channel_pair","","Convenience function to create a pair of UnixChannels for…",null,[[]]],[11,"new","","Create a new `Aes128` object, using `key` as the AES key.",1,[[["block"]],["self"]]],[11,"encrypt","","Encrypt a block, outputting the ciphertext.",1,[[["self"],["block"]],["block"]]],[11,"encrypt4","","Encrypt four blocks at a time, outputting the ciphertexts.",1,[[["self"]]]],[11,"encrypt8","","Encrypt eight blocks at a time, outputting the ciphertexts.",1,[[["self"]]]],[11,"new","","Make a new `Aes256` object with key `key`.",2,[[],["self"]]],[11,"encrypt","","Encrypt block `m`.",2,[[["self"],["block"]],["block"]]],[11,"as_ptr","","Convert into a pointer.",0,[[["self"]]]],[11,"as_mut_ptr","","Convert into a mutable pointer.",0,[[["self"]]]],[11,"clmul","","Carryless multiplication.",0,[[]]],[11,"hash_pt","","Hash an elliptic curve point `pt` and tweak `tweak`.",0,[[["usize"],["ristrettopoint"]],["self"]]],[11,"lsb","","Return the least significant bit.",0,[[["self"]],["bool"]]],[11,"set_lsb","","Set the least significant bit.",0,[[["self"]],["block"]]],[11,"flip","","Flip all bits.",0,[[["self"]],["self"]]],[11,"try_from_slice","","Try to create a `Block` from a slice of bytes. The slice…",0,[[],["option"]]],[11,"prefix","","Return the first `n` bytes, where `n` must be `<= 64`.",3,[[["self"],["usize"]]]],[11,"prefix_mut","","Return the first `n` bytes as mutable, where `n` must be…",3,[[["self"],["usize"]]]],[0,"bloomfilter","","Implementation of a bloom filter.",null,null],[3,"BloomFilter","scuttlebutt::bloomfilter","Simple implementation of a Bloom Filter. Which is…",null,null],[11,"new","","Create a new BloomFilter with `size` entries, using…",4,[[["usize"]],["self"]]],[11,"compute_expansion","","Compute required expansion for false positive probability…",4,[[["f64"]],["f64"]]],[11,"compute_nhashes","","Compute required number of hash functions for false…",4,[[["f64"]],["usize"]]],[11,"with_false_positive_prob","","Create a new BloomFilter with false positive probability…",4,[[["f64"],["usize"]],["self"]]],[11,"len","","Get the number of bins in this BloomFilter.",4,[[["self"]],["usize"]]],[11,"nhashes","","Get the number of hash functions in this BloomFilter.",4,[[["self"]],["usize"]]],[11,"bins","","Get bloom filter bins.",4,[[["self"]]]],[11,"as_bytes","","Get bloom filter bins packed in bytes.",4,[[["self"]],[["vec",["u8"]],["u8"]]]],[11,"from_bytes","","Create bloom filter from bytes.",4,[[["usize"]],["self"]]],[11,"bin","","Compute the bin that this value would go to in a…",4,[[["v"],["usize"]],["usize"]]],[11,"insert","","Insert an item into the BloomFilter.",4,[[["self"],["v"]]]],[11,"contains","","Check whether an item exists in the BloomFilter.",4,[[["self"],["v"]],["bool"]]],[0,"channel","scuttlebutt","Module for encapsulating communication channels for…",null,null],[3,"HashChannel","scuttlebutt::channel","An instantiation of the `AbstractChannel` trait which…",null,null],[3,"SyncChannel","","A channel that implements `AbstractChannel` as well as…",null,null],[3,"TrackChannel","","A channel for tracking the number of bits read/written.",null,null],[3,"Channel","","A standard read/write channel that implements…",null,null],[5,"track_unix_channel_pair","","Convenience function to create a pair of TrackUnixChannels…",null,[[]]],[5,"unix_channel_pair","","Convenience function to create a pair of UnixChannels for…",null,[[]]],[11,"new","scuttlebutt","Make a new `HashChannel` from a `reader` and a `writer`.",5,[[["w"],["r"]],["self"]]],[11,"finish","","Consume the channel and output the hash of all the…",5,[[]]],[11,"new","","Make a new `Channel` from a `reader` and a `writer`.",6,[[["w"],["r"]],["self"]]],[11,"reader","","Return a reader object wrapped in `Arc<Mutex<R>>`.",6,[[],[["mutex"],["arc",["mutex"]]]]],[11,"writer","","Return a writer object wrapped in `Arc<Mutex<W>>`.",6,[[],[["arc",["mutex"]],["mutex"]]]],[11,"new","","Make a new `TrackChannel` from a `reader` and a `writer`.",7,[[["w"],["r"]],["self"]]],[11,"clear","","Clear the number of bits read/written.",7,[[["self"]]]],[11,"kilobits_written","","Return the number of kilobits written to the channel.",7,[[["self"]],["f64"]]],[11,"kilobits_read","","Return the number of kilobits read from the channel.",7,[[["self"]],["f64"]]],[11,"total_kilobits","","Return the total amount of communication on the channel.",7,[[["self"]],["f64"]]],[11,"kilobytes_written","","Return the number of kilobytes written to the channel.",7,[[["self"]],["f64"]]],[11,"kilobytes_read","","Return the number of kilobytes read from the channel.",7,[[["self"]],["f64"]]],[11,"total_kilobytes","","Return the total amount of communication on the channel as…",7,[[["self"]],["f64"]]],[6,"TrackUnixChannel","scuttlebutt::channel","A TrackChannel which uses UnixStreams.",null,null],[6,"UnixChannel","","A SyncChannel which uses UnixStreams.",null,null],[8,"AbstractChannel","","A trait for managing I/O. `AbstractChannel`s are clonable,…",null,null],[10,"read_bytes","","Read a slice of `u8`s from the channel.",8,[[["self"]],["result"]]],[10,"write_bytes","","Write a slice of `u8`s to the channel.",8,[[["self"]],["result"]]],[10,"flush","","Flush the channel.",8,[[["self"]],["result"]]],[10,"clone","","Clone the channel.",8,[[["self"]],["self"]]],[11,"read_vec","","Read `nbytes` from the channel, and return it as a `Vec`.",8,[[["self"],["usize"]],[["vec",["u8"]],["result",["vec"]]]]],[11,"write_bool","","Write a `bool` to the channel.",8,[[["self"],["bool"]],["result"]]],[11,"read_bool","","Read a `bool` from the channel.",8,[[["self"]],[["bool"],["result",["bool"]]]]],[11,"write_u8","","Write a `u8` to the channel.",8,[[["self"],["u8"]],["result"]]],[11,"read_u8","","Read a `u8` from the channel.",8,[[["self"]],[["result",["u8"]],["u8"]]]],[11,"write_u16","","Write a `u16` to the channel.",8,[[["u16"],["self"]],["result"]]],[11,"read_u16","","Read a `u16` from the channel.",8,[[["self"]],[["u16"],["result",["u16"]]]]],[11,"write_u32","","Write a `u32` to the channel.",8,[[["self"],["u32"]],["result"]]],[11,"read_u32","","Read a `u32` from the channel.",8,[[["self"]],[["result",["u32"]],["u32"]]]],[11,"write_u64","","Write a `u64` to the channel.",8,[[["self"],["u64"]],["result"]]],[11,"read_u64","","Read a `u64` from the channel.",8,[[["self"]],[["u64"],["result",["u64"]]]]],[11,"write_usize","","Write a `usize` to the channel.",8,[[["self"],["usize"]],["result"]]],[11,"read_usize","","Read a `usize` from the channel.",8,[[["self"]],[["result",["usize"]],["usize"]]]],[11,"write_block","","Write a `Block` to the channel.",8,[[["block"],["self"]],["result"]]],[11,"read_block","","Read a `Block` from the channel.",8,[[["self"]],[["result",["block"]],["block"]]]],[11,"read_blocks","","Read `n` `Block`s from the channel.",8,[[["self"],["usize"]],[["result",["vec"]],["vec",["block"]]]]],[11,"write_block512","","Write a `Block512` to the channel.",8,[[["self"],["block512"]],["result"]]],[11,"read_block512","","Read a `Block512` from the channel.",8,[[["self"]],[["block512"],["result",["block512"]]]]],[11,"write_pt","","Write a `RistrettoPoint` to the channel.",8,[[["self"],["ristrettopoint"]],["result"]]],[11,"read_pt","","Read a `RistrettoPoint` from the channel.",8,[[["self"]],[["result",["ristrettopoint"]],["ristrettopoint"]]]],[11,"new","","Make a new `Channel` from a `reader` and a `writer`.",9,[[["w"],["r"]],["self"]]],[11,"reader","","Return a reader object wrapped in `Rc<RefCell>`.",9,[[],[["rc",["refcell"]],["refcell"]]]],[11,"writer","","Return a writer object wrapped in `Rc<RefCell>`.",9,[[],[["refcell"],["rc",["refcell"]]]]],[0,"cointoss","scuttlebutt","Implementation of a simple two-party coin tossing protocol…",null,null],[4,"Error","scuttlebutt::cointoss","Errors produced by the coin tossing protocol.",null,null],[13,"IoError","","An I/O error occurred.",10,null],[13,"CommitmentCheckFailed","","The commitment check failed.",10,null],[5,"send","","Coin tossing sender.",null,[[["c"]],[["result",["vec","error"]],["vec",["block"]],["error"]]]],[5,"receive","","Coin tossing receiver.",null,[[["c"]],[["result",["vec","error"]],["vec",["block"]],["error"]]]],[0,"commitment","scuttlebutt","A trait defining a Commitment Scheme and an implementation…",null,null],[3,"ShaCommitment","scuttlebutt::commitment","A commitment in the random oracle model using SHA256.",null,null],[12,"seed","","The seed used to initialize the commitment.",11,null],[8,"Commitment","","Generic commitment scheme.",null,null],[16,"Seed","","The type used to initialize a commitment.",12,null],[16,"Output","","The output type of the commitment.",12,null],[10,"new","","A new commitment initialized with `seed`.",12,[[],["self"]]],[10,"input","","A method to add data to the commitment.",12,[[["self"]]]],[10,"finish","","Complete the commitment.",12,[[]]],[10,"check","","Check if two commitments are equal.",12,[[],["bool"]]],[11,"new","scuttlebutt","Initialize the hash function using `key`.",13,[[["block"]],["self"]]],[11,"cr_hash","","Correlation-robust hash function for 128-bit inputs (cf.…",13,[[["self"],["block"]],["block"]]],[11,"ccr_hash","","Circular correlation-robust hash function (cf.…",13,[[["self"],["block"]],["block"]]],[11,"tccr_hash","","Tweakable circular correlation robust hash function (cf.…",13,[[["self"],["block"]],["block"]]],[11,"new","","Create a new random number generator using a random seed…",14,[[],["self"]]],[11,"fork","","Create a new RNG using a random seed from this one.",14,[[["self"]],["self"]]],[0,"utils","","Useful utility functions.",null,null],[5,"pack_bits","scuttlebutt::utils","Pack a bit slice into bytes.",null,[[],[["vec",["u8"]],["u8"]]]],[5,"unpack_bits","","Unpack a bit vector from a slice of bytes.",null,[[["usize"]],[["bool"],["vec",["bool"]]]]],[5,"xor","","XOR two byte arrays, outputting the result.",null,[[],[["vec",["u8"]],["u8"]]]],[5,"xor_n","","XOR two byte arrays up to `n` bytes, outputting the result.",null,[[["usize"]],[["vec",["u8"]],["u8"]]]],[5,"xor_inplace","","XOR two byte arrays in place.",null,[[]]],[5,"xor_inplace_n","","XOR two byte arrays up to `n` bytes in place.",null,[[["usize"]]]],[5,"and","","AND two byte arrays, outputting the result.",null,[[],[["vec",["u8"]],["u8"]]]],[5,"and_inplace","","AND two byte arrays in place.",null,[[]]],[6,"TrackUnixChannel","scuttlebutt","A TrackChannel which uses UnixStreams.",null,null],[6,"UnixChannel","","A SyncChannel which uses UnixStreams.",null,null],[17,"FIXED_KEY_AES128","","Fixed-key AES-128.",null,null],[17,"AES_HASH","","`AesHash` with a fixed key.",null,null],[8,"SemiHonest","","A marker trait denoting that the given scheme is…",null,null],[8,"Malicious","","A marker trait denoting that the given scheme is…",null,null],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,[[["self"],["t"]]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"try_into","","",1,[[],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"type_id","","",1,[[["self"]],["typeid"]]],[11,"into_bits","","",1,[[],["u"]]],[11,"from_cast","","",1,[[["t"]],["t"]]],[11,"cast","","",1,[[],["u"]]],[11,"from_bits","","",1,[[["t"]],["t"]]],[11,"vzip","","",1,[[],["v"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,[[["self"],["t"]]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"try_into","","",2,[[],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"type_id","","",2,[[["self"]],["typeid"]]],[11,"into_bits","","",2,[[],["u"]]],[11,"from_cast","","",2,[[["t"]],["t"]]],[11,"cast","","",2,[[],["u"]]],[11,"from_bits","","",2,[[["t"]],["t"]]],[11,"vzip","","",2,[[],["v"]]],[11,"from","","",0,[[["t"]],["t"]]],[11,"into","","",0,[[],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,[[["self"],["t"]]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"try_into","","",0,[[],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"type_id","","",0,[[["self"]],["typeid"]]],[11,"into_bits","","",0,[[],["u"]]],[11,"from_cast","","",0,[[["t"]],["t"]]],[11,"cast","","",0,[[],["u"]]],[11,"from_bits","","",0,[[["t"]],["t"]]],[11,"vzip","","",0,[[],["v"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,[[["self"],["t"]]]],[11,"to_string","","",3,[[["self"]],["string"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"try_into","","",3,[[],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"type_id","","",3,[[["self"]],["typeid"]]],[11,"into_bits","","",3,[[],["u"]]],[11,"from_cast","","",3,[[["t"]],["t"]]],[11,"cast","","",3,[[],["u"]]],[11,"from_bits","","",3,[[["t"]],["t"]]],[11,"vzip","","",3,[[],["v"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"into","","",5,[[],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"try_into","","",5,[[],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"type_id","","",5,[[["self"]],["typeid"]]],[11,"into_bits","","",5,[[],["u"]]],[11,"from_cast","","",5,[[["t"]],["t"]]],[11,"cast","","",5,[[],["u"]]],[11,"from_bits","","",5,[[["t"]],["t"]]],[11,"vzip","","",5,[[],["v"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"try_into","","",6,[[],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"type_id","","",6,[[["self"]],["typeid"]]],[11,"into_bits","","",6,[[],["u"]]],[11,"from_cast","","",6,[[["t"]],["t"]]],[11,"cast","","",6,[[],["u"]]],[11,"from_bits","","",6,[[["t"]],["t"]]],[11,"vzip","","",6,[[],["v"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"try_into","","",7,[[],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"type_id","","",7,[[["self"]],["typeid"]]],[11,"into_bits","","",7,[[],["u"]]],[11,"from_cast","","",7,[[["t"]],["t"]]],[11,"cast","","",7,[[],["u"]]],[11,"from_bits","","",7,[[["t"]],["t"]]],[11,"vzip","","",7,[[],["v"]]],[11,"from","","",13,[[["t"]],["t"]]],[11,"into","","",13,[[],["u"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"try_into","","",13,[[],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"type_id","","",13,[[["self"]],["typeid"]]],[11,"into_bits","","",13,[[],["u"]]],[11,"from_cast","","",13,[[["t"]],["t"]]],[11,"cast","","",13,[[],["u"]]],[11,"from_bits","","",13,[[["t"]],["t"]]],[11,"vzip","","",13,[[],["v"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"into","","",14,[[],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,[[["self"],["t"]]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"try_into","","",14,[[],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"type_id","","",14,[[["self"]],["typeid"]]],[11,"into_bits","","",14,[[],["u"]]],[11,"from_cast","","",14,[[["t"]],["t"]]],[11,"cast","","",14,[[],["u"]]],[11,"from_bits","","",14,[[["t"]],["t"]]],[11,"vzip","","",14,[[],["v"]]],[11,"from","scuttlebutt::bloomfilter","",4,[[["t"]],["t"]]],[11,"into","","",4,[[],["u"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"try_into","","",4,[[],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"type_id","","",4,[[["self"]],["typeid"]]],[11,"into_bits","","",4,[[],["u"]]],[11,"from_cast","","",4,[[["t"]],["t"]]],[11,"cast","","",4,[[],["u"]]],[11,"from_bits","","",4,[[["t"]],["t"]]],[11,"vzip","","",4,[[],["v"]]],[11,"from","scuttlebutt::channel","",9,[[["t"]],["t"]]],[11,"into","","",9,[[],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"try_into","","",9,[[],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"type_id","","",9,[[["self"]],["typeid"]]],[11,"into_bits","","",9,[[],["u"]]],[11,"from_cast","","",9,[[["t"]],["t"]]],[11,"cast","","",9,[[],["u"]]],[11,"from_bits","","",9,[[["t"]],["t"]]],[11,"vzip","","",9,[[],["v"]]],[11,"from","scuttlebutt::cointoss","",10,[[["t"]],["t"]]],[11,"into","","",10,[[],["u"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"try_into","","",10,[[],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"type_id","","",10,[[["self"]],["typeid"]]],[11,"into_bits","","",10,[[],["u"]]],[11,"from_cast","","",10,[[["t"]],["t"]]],[11,"cast","","",10,[[],["u"]]],[11,"from_bits","","",10,[[["t"]],["t"]]],[11,"vzip","","",10,[[],["v"]]],[11,"from","scuttlebutt::commitment","",11,[[["t"]],["t"]]],[11,"into","","",11,[[],["u"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"try_into","","",11,[[],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"type_id","","",11,[[["self"]],["typeid"]]],[11,"into_bits","","",11,[[],["u"]]],[11,"from_cast","","",11,[[["t"]],["t"]]],[11,"cast","","",11,[[],["u"]]],[11,"from_bits","","",11,[[["t"]],["t"]]],[11,"vzip","","",11,[[],["v"]]],[11,"write_bytes","scuttlebutt","",5,[[["self"]],["result"]]],[11,"read_bytes","","",5,[[["self"]],["result"]]],[11,"flush","","",5,[[["self"]],["result"]]],[11,"clone","","",5,[[["self"]],["self"]]],[11,"write_bytes","","",6,[[["self"]],["result"]]],[11,"read_bytes","","",6,[[["self"]],["result"]]],[11,"flush","","",6,[[["self"]],["result"]]],[11,"clone","","",6,[[["self"]],["self"]]],[11,"write_bytes","","",7,[[["self"]],["result"]]],[11,"read_bytes","","",7,[[["self"]],["result"]]],[11,"flush","","",7,[[["self"]],["result"]]],[11,"clone","","",7,[[["self"]],["self"]]],[11,"write_bytes","scuttlebutt::channel","",9,[[["self"]],["result"]]],[11,"read_bytes","","",9,[[["self"]],["result"]]],[11,"flush","","",9,[[["self"]],["result"]]],[11,"clone","","",9,[[["self"]],["self"]]],[11,"new","scuttlebutt::commitment","",11,[[],["self"]]],[11,"input","","",11,[[["self"]]]],[11,"finish","","",11,[[]]],[11,"check","","",11,[[],["bool"]]],[11,"as_mut","scuttlebutt","",0,[[["self"]]]],[11,"as_mut","","",3,[[["self"]]]],[11,"as_ref","","",0,[[["self"]]]],[11,"as_ref","","",3,[[["self"]]]],[11,"from","","",0,[[["u128"]],["self"]]],[11,"from","","",0,[[["__m128i"]],["self"]]],[11,"from","","",0,[[],["self"]]],[11,"from","","",0,[[],["self"]]],[11,"from","","",3,[[],["block512"]]],[11,"from","","",3,[[],["block512"]]],[11,"from","","",3,[[],["block512"]]],[11,"from","","",3,[[["__m512i"]],["block512"]]],[11,"from","scuttlebutt::cointoss","",10,[[["error"]],["self"]]],[11,"clone","scuttlebutt","",1,[[["self"]],["aes128"]]],[11,"clone","","",2,[[["self"]],["aes256"]]],[11,"clone","","",0,[[["self"]],["block"]]],[11,"clone","","",3,[[["self"]],["block512"]]],[11,"clone","","",14,[[["self"]],["aesrng"]]],[11,"default","","",0,[[],["self"]]],[11,"default","","",3,[[],["self"]]],[11,"default","","",14,[[],["self"]]],[11,"cmp","","",0,[[["self"]],["ordering"]]],[11,"cmp","","",3,[[["self"]],["ordering"]]],[11,"eq","","",0,[[["block"],["self"]],["bool"]]],[11,"eq","","",3,[[["block512"],["self"]],["bool"]]],[11,"eq","scuttlebutt::bloomfilter","",4,[[["self"],["bloomfilter"]],["bool"]]],[11,"ne","","",4,[[["self"],["bloomfilter"]],["bool"]]],[11,"partial_cmp","scuttlebutt","",0,[[["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","","",3,[[["self"]],[["ordering"],["option",["ordering"]]]]],[11,"partial_cmp","scuttlebutt::bloomfilter","",4,[[["self"],["bloomfilter"]],[["ordering"],["option",["ordering"]]]]],[11,"lt","","",4,[[["self"],["bloomfilter"]],["bool"]]],[11,"le","","",4,[[["self"],["bloomfilter"]],["bool"]]],[11,"gt","","",4,[[["self"],["bloomfilter"]],["bool"]]],[11,"ge","","",4,[[["self"],["bloomfilter"]],["bool"]]],[11,"fmt","scuttlebutt","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","scuttlebutt::bloomfilter","",4,[[["formatter"],["self"]],["result"]]],[11,"fmt","scuttlebutt::cointoss","",10,[[["formatter"],["self"]],["result"]]],[11,"fmt","scuttlebutt","",14,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",0,[[["formatter"],["self"]],["result"]]],[11,"fmt","","",3,[[["formatter"],["self"]],["result"]]],[11,"fmt","scuttlebutt::cointoss","",10,[[["formatter"],["self"]],["result"]]],[11,"bitand","scuttlebutt","",0,[[],["self"]]],[11,"bitor","","",0,[[],["self"]]],[11,"bitxor","","",0,[[],["self"]]],[11,"bitxor","","",3,[[],["self"]]],[11,"bitand_assign","","",0,[[["self"]]]],[11,"bitor_assign","","",0,[[["self"]]]],[11,"bitxor_assign","","",0,[[["self"]]]],[11,"bitxor_assign","","",3,[[["self"]]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"hash","","",3,[[["self"],["h"]]]],[11,"try_from","","",3,[[],["result"]]],[11,"next_u32","","",14,[[["self"]],["u32"]]],[11,"next_u64","","",14,[[["self"]],["u64"]]],[11,"fill_bytes","","",14,[[["self"]]]],[11,"try_fill_bytes","","",14,[[["self"]],[["result",["error"]],["error"]]]],[11,"from_seed","","",14,[[],["self"]]],[11,"from_rng","","",14,[[["rngcore"]],[["result",["error"]],["error"]]]],[11,"serialize","","",0,[[["self"],["serializer"]],["result"]]],[11,"deserialize","","",0,[[["deserializer"]],["result"]]]],"p":[[3,"Block"],[3,"Aes128"],[3,"Aes256"],[3,"Block512"],[3,"BloomFilter"],[3,"HashChannel"],[3,"SyncChannel"],[3,"TrackChannel"],[8,"AbstractChannel"],[3,"Channel"],[4,"Error"],[3,"ShaCommitment"],[8,"Commitment"],[3,"AesHash"],[3,"AesRng"]]};
addSearchOptions(searchIndex);initSearch(searchIndex);