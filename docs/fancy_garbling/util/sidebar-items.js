initSidebarItems({"constant":[["NPRIMES","Number of primes supported by our library."],["PRIMES","Primes used in fancy garbling."]],"fn":[["as_base_q_u128","Convert `x` into base `q`."],["as_mixed_radix","Convert `x` into mixed radix form using the provided `radii`."],["base_modulus_with_width","Generate a CRT modulus that support at least n-bit integers, using provided primes."],["base_primes_with_width","Generate the factors of a CRT modulus that support at least n-bit integers, using provided primes."],["base_q_add_eq","Add a base `q` slice `ys` into `xs`."],["crt","Compute the CRT representation of x with respect to the primes ps."],["crt_factor","Compute the CRT representation of `x` with respect to the factorization of `q`."],["crt_inv","Compute the value x given a list of CRT primes and residues."],["crt_inv_factor","Compute the value `x` given a composite CRT modulus provided by `xs`."],["digits_per_u128","Determine how many `mod q` digits fit into a `u128` (includes the color digit)."],["factor","Factor using the primes in the global `PRIMES` array. Fancy garbling only supports composites with small prime factors."],["from_base_q","Convert little-endian base `q` digits into `u128`."],["from_mixed_radix","Convert little-endian mixed radix digits into u128."],["inv","Generic algorithm to invert inp_a mod inp_b. As ref so as to support BigInts without copying."],["is_power_of_2","Raise a u16 to a power mod some value. Returns true if x is a power of 2"],["modulus_with_nprimes","Primes skipping the modulus 2, which allows certain gadgets. Generate a CRT modulus with n primes."],["modulus_with_width","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES."],["output_tweak","Compute the output tweak for a garbled gate where i is the gate id and k is the value."],["primes_with_width","Generate the factors of a CRT modulus that support at least n-bit integers, using the built-in PRIMES."],["product","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES_SKIP_2 (does not include 2 as a factor). Compute the product of some u16s as a u128."],["tweak",""],["tweak2",""],["u128_from_bits","Convert into a u128 from the \"bits\" as u16. Assumes each \"bit\" is 0 or 1."],["u128_to_bits","Get the bits of a u128 encoded in 128 u16s, which is convenient for the rest of the library, which uses u16 as the base digit type in Wire."]],"trait":[["RngExt","Extra Rng functionality, useful for `fancy-garbling`."]]});