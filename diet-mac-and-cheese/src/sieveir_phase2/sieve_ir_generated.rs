// CACHE KEY 7046b74e70bbb13104595681784a919ecb149d21b2d06b06647bbeed60925992
#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(clippy::all)]
#![allow(unused_imports)]
// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod sieve_ir {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE: u8 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE: [Message; 4] = [
  Message::NONE,
  Message::Relation,
  Message::PublicInputs,
  Message::PrivateInputs,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Message(pub u8);
#[allow(non_upper_case_globals)]
impl Message {
  pub const NONE: Self = Self(0);
  pub const Relation: Self = Self(1);
  pub const PublicInputs: Self = Self(2);
  pub const PrivateInputs: Self = Self(3);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Relation,
    Self::PublicInputs,
    Self::PrivateInputs,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Relation => Some("Relation"),
      Self::PublicInputs => Some("PublicInputs"),
      Self::PrivateInputs => Some("PrivateInputs"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Message {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Message {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Message {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Message {}
pub struct MessageUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIRECTIVE_SET: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIRECTIVE_SET: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTIVE_SET: [DirectiveSet; 3] = [
  DirectiveSet::NONE,
  DirectiveSet::Gate,
  DirectiveSet::Function,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DirectiveSet(pub u8);
#[allow(non_upper_case_globals)]
impl DirectiveSet {
  pub const NONE: Self = Self(0);
  pub const Gate: Self = Self(1);
  pub const Function: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Gate,
    Self::Function,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Gate => Some("Gate"),
      Self::Function => Some("Function"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DirectiveSet {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DirectiveSet {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DirectiveSet {
    type Output = DirectiveSet;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DirectiveSet {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DirectiveSet {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DirectiveSet {}
pub struct DirectiveSetUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TYPE_U: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TYPE_U: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TYPE_U: [TypeU; 3] = [
  TypeU::NONE,
  TypeU::Field,
  TypeU::PluginType,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TypeU(pub u8);
#[allow(non_upper_case_globals)]
impl TypeU {
  pub const NONE: Self = Self(0);
  pub const Field: Self = Self(1);
  pub const PluginType: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Field,
    Self::PluginType,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Field => Some("Field"),
      Self::PluginType => Some("PluginType"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TypeU {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TypeU {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TypeU {
    type Output = TypeU;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TypeU {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TypeU {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TypeU {}
pub struct TypeUUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FUNCTION_BODY: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FUNCTION_BODY: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FUNCTION_BODY: [FunctionBody; 3] = [
  FunctionBody::NONE,
  FunctionBody::Gates,
  FunctionBody::PluginBody,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FunctionBody(pub u8);
#[allow(non_upper_case_globals)]
impl FunctionBody {
  pub const NONE: Self = Self(0);
  pub const Gates: Self = Self(1);
  pub const PluginBody: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Gates,
    Self::PluginBody,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Gates => Some("Gates"),
      Self::PluginBody => Some("PluginBody"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FunctionBody {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FunctionBody {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FunctionBody {
    type Output = FunctionBody;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FunctionBody {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FunctionBody {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FunctionBody {}
pub struct FunctionBodyUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GATE_SET: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GATE_SET: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GATE_SET: [GateSet; 14] = [
  GateSet::NONE,
  GateSet::GateConstant,
  GateSet::GateAssertZero,
  GateSet::GateCopy,
  GateSet::GateAdd,
  GateSet::GateMul,
  GateSet::GateAddConstant,
  GateSet::GateMulConstant,
  GateSet::GatePublic,
  GateSet::GatePrivate,
  GateSet::GateNew,
  GateSet::GateDelete,
  GateSet::GateConvert,
  GateSet::GateCall,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GateSet(pub u8);
#[allow(non_upper_case_globals)]
impl GateSet {
  pub const NONE: Self = Self(0);
  pub const GateConstant: Self = Self(1);
  pub const GateAssertZero: Self = Self(2);
  pub const GateCopy: Self = Self(3);
  pub const GateAdd: Self = Self(4);
  pub const GateMul: Self = Self(5);
  pub const GateAddConstant: Self = Self(6);
  pub const GateMulConstant: Self = Self(7);
  pub const GatePublic: Self = Self(8);
  pub const GatePrivate: Self = Self(9);
  pub const GateNew: Self = Self(10);
  pub const GateDelete: Self = Self(11);
  pub const GateConvert: Self = Self(12);
  pub const GateCall: Self = Self(13);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::GateConstant,
    Self::GateAssertZero,
    Self::GateCopy,
    Self::GateAdd,
    Self::GateMul,
    Self::GateAddConstant,
    Self::GateMulConstant,
    Self::GatePublic,
    Self::GatePrivate,
    Self::GateNew,
    Self::GateDelete,
    Self::GateConvert,
    Self::GateCall,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::GateConstant => Some("GateConstant"),
      Self::GateAssertZero => Some("GateAssertZero"),
      Self::GateCopy => Some("GateCopy"),
      Self::GateAdd => Some("GateAdd"),
      Self::GateMul => Some("GateMul"),
      Self::GateAddConstant => Some("GateAddConstant"),
      Self::GateMulConstant => Some("GateMulConstant"),
      Self::GatePublic => Some("GatePublic"),
      Self::GatePrivate => Some("GatePrivate"),
      Self::GateNew => Some("GateNew"),
      Self::GateDelete => Some("GateDelete"),
      Self::GateConvert => Some("GateConvert"),
      Self::GateCall => Some("GateCall"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GateSet {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GateSet {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GateSet {
    type Output = GateSet;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GateSet {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GateSet {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GateSet {}
pub struct GateSetUnionTableOffset {}

// struct Count, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Count(pub [u8; 16]);
impl Default for Count { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for Count {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Count")
      .field("type_id", &self.type_id())
      .field("count", &self.count())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Count {}
impl<'a> flatbuffers::Follow<'a> for Count {
  type Inner = &'a Count;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Count>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Count {
  type Inner = &'a Count;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Count>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Count {
    type Output = Count;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Count as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Count {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Count {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    type_id: u8,
    count: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_type_id(type_id);
    s.set_count(count);
    s
  }

  pub fn type_id(&self) -> u8 {
    let mut mem = core::mem::MaybeUninit::<<u8 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_type_id(&mut self, x: u8) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u8 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn count(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_count(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

// struct Conversion, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Conversion(pub [u8; 32]);
impl Default for Conversion { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for Conversion {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Conversion")
      .field("output_count", &self.output_count())
      .field("input_count", &self.input_count())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Conversion {}
impl<'a> flatbuffers::Follow<'a> for Conversion {
  type Inner = &'a Conversion;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Conversion>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Conversion {
  type Inner = &'a Conversion;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Conversion>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Conversion {
    type Output = Conversion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const Conversion as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for Conversion {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Conversion {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    output_count: &Count,
    input_count: &Count,
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_output_count(output_count);
    s.set_input_count(input_count);
    s
  }

  pub fn output_count(&self) -> &Count {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[0..].as_ptr() as *const Count) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_output_count(&mut self, x: &Count) {
    self.0[0..0 + 16].copy_from_slice(&x.0)
  }

  pub fn input_count(&self) -> &Count {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid struct in this slot
    unsafe { &*(self.0[16..].as_ptr() as *const Count) }
  }

  #[allow(clippy::identity_op)]
  pub fn set_input_count(&mut self, x: &Count) {
    self.0[16..16 + 16].copy_from_slice(&x.0)
  }

}

// struct WireRange, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct WireRange(pub [u8; 16]);
impl Default for WireRange { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for WireRange {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("WireRange")
      .field("first_id", &self.first_id())
      .field("last_id", &self.last_id())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for WireRange {}
impl<'a> flatbuffers::Follow<'a> for WireRange {
  type Inner = &'a WireRange;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a WireRange>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a WireRange {
  type Inner = &'a WireRange;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<WireRange>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for WireRange {
    type Output = WireRange;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const WireRange as *const u8, Self::size());
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for WireRange {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> WireRange {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    first_id: u64,
    last_id: u64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_first_id(first_id);
    s.set_last_id(last_id);
    s
  }

  pub fn first_id(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_first_id(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn last_id(&self) -> u64 {
    let mut mem = core::mem::MaybeUninit::<<u64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_last_id(&mut self, x: u64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<u64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum RelationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Relation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Relation<'a> {
  type Inner = Relation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Relation<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_PLUGINS: flatbuffers::VOffsetT = 6;
  pub const VT_TYPES: flatbuffers::VOffsetT = 8;
  pub const VT_CONVERSIONS: flatbuffers::VOffsetT = 10;
  pub const VT_DIRECTIVES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Relation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RelationArgs<'args>
  ) -> flatbuffers::WIPOffset<Relation<'bldr>> {
    let mut builder = RelationBuilder::new(_fbb);
    if let Some(x) = args.directives { builder.add_directives(x); }
    if let Some(x) = args.conversions { builder.add_conversions(x); }
    if let Some(x) = args.types { builder.add_types(x); }
    if let Some(x) = args.plugins { builder.add_plugins(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Relation::VT_VERSION, None)}
  }
  #[inline]
  pub fn plugins(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(Relation::VT_PLUGINS, None)}
  }
  #[inline]
  pub fn types(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Type<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Type>>>>(Relation::VT_TYPES, None)}
  }
  #[inline]
  pub fn conversions(&self) -> Option<flatbuffers::Vector<'a, Conversion>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Conversion>>>(Relation::VT_CONVERSIONS, None)}
  }
  #[inline]
  pub fn directives(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive>>>>(Relation::VT_DIRECTIVES, None)}
  }
}

impl flatbuffers::Verifiable for Relation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("plugins", Self::VT_PLUGINS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Type>>>>("types", Self::VT_TYPES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Conversion>>>("conversions", Self::VT_CONVERSIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Directive>>>>("directives", Self::VT_DIRECTIVES, false)?
     .finish();
    Ok(())
  }
}
pub struct RelationArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plugins: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Type<'a>>>>>,
    pub conversions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Conversion>>>,
    pub directives: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Directive<'a>>>>>,
}
impl<'a> Default for RelationArgs<'a> {
  #[inline]
  fn default() -> Self {
    RelationArgs {
      version: None,
      plugins: None,
      types: None,
      conversions: None,
      directives: None,
    }
  }
}

pub struct RelationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelationBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_VERSION, version);
  }
  #[inline]
  pub fn add_plugins(&mut self, plugins: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_PLUGINS, plugins);
  }
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Type<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_TYPES, types);
  }
  #[inline]
  pub fn add_conversions(&mut self, conversions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Conversion>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_CONVERSIONS, conversions);
  }
  #[inline]
  pub fn add_directives(&mut self, directives: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Directive<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_DIRECTIVES, directives);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Relation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Relation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Relation");
      ds.field("version", &self.version());
      ds.field("plugins", &self.plugins());
      ds.field("types", &self.types());
      ds.field("conversions", &self.conversions());
      ds.field("directives", &self.directives());
      ds.finish()
  }
}
pub enum PublicInputsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PublicInputs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PublicInputs<'a> {
  type Inner = PublicInputs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PublicInputs<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PublicInputs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PublicInputsArgs<'args>
  ) -> flatbuffers::WIPOffset<PublicInputs<'bldr>> {
    let mut builder = PublicInputsBuilder::new(_fbb);
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PublicInputs::VT_VERSION, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<Type<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(PublicInputs::VT_TYPE_, None)}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>>>(PublicInputs::VT_INPUTS, None)}
  }
}

impl flatbuffers::Verifiable for PublicInputs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>>>("inputs", Self::VT_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct PublicInputsArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>>,
}
impl<'a> Default for PublicInputsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PublicInputsArgs {
      version: None,
      type_: None,
      inputs: None,
    }
  }
}

pub struct PublicInputsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PublicInputsBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicInputs::VT_VERSION, version);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(PublicInputs::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PublicInputs::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PublicInputsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PublicInputsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PublicInputs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PublicInputs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PublicInputs");
      ds.field("version", &self.version());
      ds.field("type_", &self.type_());
      ds.field("inputs", &self.inputs());
      ds.finish()
  }
}
pub enum PrivateInputsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrivateInputs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrivateInputs<'a> {
  type Inner = PrivateInputs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrivateInputs<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_INPUTS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrivateInputs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PrivateInputsArgs<'args>
  ) -> flatbuffers::WIPOffset<PrivateInputs<'bldr>> {
    let mut builder = PrivateInputsBuilder::new(_fbb);
    if let Some(x) = args.inputs { builder.add_inputs(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PrivateInputs::VT_VERSION, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<Type<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Type>>(PrivateInputs::VT_TYPE_, None)}
  }
  #[inline]
  pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>>>(PrivateInputs::VT_INPUTS, None)}
  }
}

impl flatbuffers::Verifiable for PrivateInputs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Type>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>>>("inputs", Self::VT_INPUTS, false)?
     .finish();
    Ok(())
  }
}
pub struct PrivateInputsArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<Type<'a>>>,
    pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>>,
}
impl<'a> Default for PrivateInputsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrivateInputsArgs {
      version: None,
      type_: None,
      inputs: None,
    }
  }
}

pub struct PrivateInputsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PrivateInputsBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateInputs::VT_VERSION, version);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<Type<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Type>>(PrivateInputs::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_inputs(&mut self, inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Value<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PrivateInputs::VT_INPUTS, inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PrivateInputsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PrivateInputsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrivateInputs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrivateInputs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrivateInputs");
      ds.field("version", &self.version());
      ds.field("type_", &self.type_());
      ds.field("inputs", &self.inputs());
      ds.finish()
  }
}
pub enum ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Value<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
  type Inner = Value<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Value<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Value { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args ValueArgs<'args>
  ) -> flatbuffers::WIPOffset<Value<'bldr>> {
    let mut builder = ValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Value::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Value<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ValueArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    ValueArgs {
      value: None,
    }
  }
}

pub struct ValueBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ValueBuilder<'a, 'b> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ValueBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Value<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Value");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DirectiveOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Directive<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Directive<'a> {
  type Inner = Directive<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Directive<'a> {
  pub const VT_DIRECTIVE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_DIRECTIVE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Directive { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args DirectiveArgs
  ) -> flatbuffers::WIPOffset<Directive<'bldr>> {
    let mut builder = DirectiveBuilder::new(_fbb);
    if let Some(x) = args.directive { builder.add_directive(x); }
    builder.add_directive_type(args.directive_type);
    builder.finish()
  }


  #[inline]
  pub fn directive_type(&self) -> DirectiveSet {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, Some(DirectiveSet::NONE)).unwrap()}
  }
  #[inline]
  pub fn directive(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Directive::VT_DIRECTIVE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_gate(&self) -> Option<Gate<'a>> {
    if self.directive_type() == DirectiveSet::Gate {
      self.directive().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Gate::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn directive_as_function(&self) -> Option<Function<'a>> {
    if self.directive_type() == DirectiveSet::Function {
      self.directive().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Function::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Directive<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<DirectiveSet, _>("directive_type", Self::VT_DIRECTIVE_TYPE, "directive", Self::VT_DIRECTIVE, false, |key, v, pos| {
        match key {
          DirectiveSet::Gate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Gate>>("DirectiveSet::Gate", pos),
          DirectiveSet::Function => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Function>>("DirectiveSet::Function", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DirectiveArgs {
    pub directive_type: DirectiveSet,
    pub directive: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DirectiveArgs {
  #[inline]
  fn default() -> Self {
    DirectiveArgs {
      directive_type: DirectiveSet::NONE,
      directive: None,
    }
  }
}

pub struct DirectiveBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DirectiveBuilder<'a, 'b> {
  #[inline]
  pub fn add_directive_type(&mut self, directive_type: DirectiveSet) {
    self.fbb_.push_slot::<DirectiveSet>(Directive::VT_DIRECTIVE_TYPE, directive_type, DirectiveSet::NONE);
  }
  #[inline]
  pub fn add_directive(&mut self, directive: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Directive::VT_DIRECTIVE, directive);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DirectiveBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DirectiveBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Directive<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Directive<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Directive");
      ds.field("directive_type", &self.directive_type());
      match self.directive_type() {
        DirectiveSet::Gate => {
          if let Some(x) = self.directive_as_gate() {
            ds.field("directive", &x)
          } else {
            ds.field("directive", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DirectiveSet::Function => {
          if let Some(x) = self.directive_as_function() {
            ds.field("directive", &x)
          } else {
            ds.field("directive", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("directive", &x)
        },
      };
      ds.finish()
  }
}
pub enum TypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Type<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Type<'a> {
  type Inner = Type<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Type<'a> {
  pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Type { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args TypeArgs
  ) -> flatbuffers::WIPOffset<Type<'bldr>> {
    let mut builder = TypeBuilder::new(_fbb);
    if let Some(x) = args.element { builder.add_element(x); }
    builder.add_element_type(args.element_type);
    builder.finish()
  }


  #[inline]
  pub fn element_type(&self) -> TypeU {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TypeU>(Type::VT_ELEMENT_TYPE, Some(TypeU::NONE)).unwrap()}
  }
  #[inline]
  pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Type::VT_ELEMENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_field(&self) -> Option<Field<'a>> {
    if self.element_type() == TypeU::Field {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Field::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_plugin_type(&self) -> Option<PluginType<'a>> {
    if self.element_type() == TypeU::PluginType {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PluginType::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Type<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<TypeU, _>("element_type", Self::VT_ELEMENT_TYPE, "element", Self::VT_ELEMENT, false, |key, v, pos| {
        match key {
          TypeU::Field => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Field>>("TypeU::Field", pos),
          TypeU::PluginType => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginType>>("TypeU::PluginType", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct TypeArgs {
    pub element_type: TypeU,
    pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for TypeArgs {
  #[inline]
  fn default() -> Self {
    TypeArgs {
      element_type: TypeU::NONE,
      element: None,
    }
  }
}

pub struct TypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_element_type(&mut self, element_type: TypeU) {
    self.fbb_.push_slot::<TypeU>(Type::VT_ELEMENT_TYPE, element_type, TypeU::NONE);
  }
  #[inline]
  pub fn add_element(&mut self, element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Type::VT_ELEMENT, element);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Type<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Type<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Type");
      ds.field("element_type", &self.element_type());
      match self.element_type() {
        TypeU::Field => {
          if let Some(x) = self.element_as_field() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        TypeU::PluginType => {
          if let Some(x) = self.element_as_plugin_type() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("element", &x)
        },
      };
      ds.finish()
  }
}
pub enum FieldOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Field<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Field<'a> {
  type Inner = Field<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Field<'a> {
  pub const VT_MODULO: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Field { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FieldArgs<'args>
  ) -> flatbuffers::WIPOffset<Field<'bldr>> {
    let mut builder = FieldBuilder::new(_fbb);
    if let Some(x) = args.modulo { builder.add_modulo(x); }
    builder.finish()
  }


  #[inline]
  pub fn modulo(&self) -> Option<Value<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Value>>(Field::VT_MODULO, None)}
  }
}

impl flatbuffers::Verifiable for Field<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Value>>("modulo", Self::VT_MODULO, false)?
     .finish();
    Ok(())
  }
}
pub struct FieldArgs<'a> {
    pub modulo: Option<flatbuffers::WIPOffset<Value<'a>>>,
}
impl<'a> Default for FieldArgs<'a> {
  #[inline]
  fn default() -> Self {
    FieldArgs {
      modulo: None,
    }
  }
}

pub struct FieldBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {
  #[inline]
  pub fn add_modulo(&mut self, modulo: flatbuffers::WIPOffset<Value<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Value>>(Field::VT_MODULO, modulo);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Field<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Field");
      ds.field("modulo", &self.modulo());
      ds.finish()
  }
}
pub enum PluginTypeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginType<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginType<'a> {
  type Inner = PluginType<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PluginType<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginType { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginTypeArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginType<'bldr>> {
    let mut builder = PluginTypeBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.operation { builder.add_operation(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginType::VT_NAME, None)}
  }
  #[inline]
  pub fn operation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginType::VT_OPERATION, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PluginType::VT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for PluginType<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginTypeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for PluginTypeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginTypeArgs {
      name: None,
      operation: None,
      params: None,
    }
  }
}

pub struct PluginTypeBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginTypeBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginType::VT_NAME, name);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginType::VT_OPERATION, operation);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginType::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginTypeBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginTypeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginType<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginType<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginType");
      ds.field("name", &self.name());
      ds.field("operation", &self.operation());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum GateConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConstant<'a> {
  type Inner = GateConstant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateConstant<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateConstant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateConstantArgs<'args>
  ) -> flatbuffers::WIPOffset<GateConstant<'bldr>> {
    let mut builder = GateConstantBuilder::new(_fbb);
    builder.add_out_id(args.out_id);
    if let Some(x) = args.constant { builder.add_constant(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateConstant::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConstant::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn constant(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateConstant::VT_CONSTANT, None)}
  }
}

impl flatbuffers::Verifiable for GateConstant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("constant", Self::VT_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct GateConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GateConstantArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateConstantArgs {
      type_id: 0,
      out_id: 0,
      constant: None,
    }
  }
}

pub struct GateConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateConstant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateConstant");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("constant", &self.constant());
      ds.finish()
  }
}
pub enum GateAssertZeroOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateAssertZero<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAssertZero<'a> {
  type Inner = GateAssertZero<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateAssertZero<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateAssertZero { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateAssertZeroArgs
  ) -> flatbuffers::WIPOffset<GateAssertZero<'bldr>> {
    let mut builder = GateAssertZeroBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateAssertZero::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAssertZero::VT_IN_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateAssertZero<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateAssertZeroArgs {
    pub type_id: u8,
    pub in_id: u64,
}
impl<'a> Default for GateAssertZeroArgs {
  #[inline]
  fn default() -> Self {
    GateAssertZeroArgs {
      type_id: 0,
      in_id: 0,
    }
  }
}

pub struct GateAssertZeroBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAssertZeroBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAssertZero::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateAssertZero::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAssertZeroBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAssertZeroBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAssertZero<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateAssertZero<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateAssertZero");
      ds.field("type_id", &self.type_id());
      ds.field("in_id", &self.in_id());
      ds.finish()
  }
}
pub enum GateCopyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateCopy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCopy<'a> {
  type Inner = GateCopy<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateCopy<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateCopy { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateCopyArgs
  ) -> flatbuffers::WIPOffset<GateCopy<'bldr>> {
    let mut builder = GateCopyBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateCopy::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateCopy::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateCopy::VT_IN_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateCopy<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateCopyArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
}
impl<'a> Default for GateCopyArgs {
  #[inline]
  fn default() -> Self {
    GateCopyArgs {
      type_id: 0,
      out_id: 0,
      in_id: 0,
    }
  }
}

pub struct GateCopyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCopyBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateCopy::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateCopy::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateCopy::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCopyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCopyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCopy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateCopy<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateCopy");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("in_id", &self.in_id());
      ds.finish()
  }
}
pub enum GateAddOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateAdd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAdd<'a> {
  type Inner = GateAdd<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateAdd<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LEFT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_RIGHT_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateAdd { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateAddArgs
  ) -> flatbuffers::WIPOffset<GateAdd<'bldr>> {
    let mut builder = GateAddBuilder::new(_fbb);
    builder.add_right_id(args.right_id);
    builder.add_left_id(args.left_id);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateAdd::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAdd::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn left_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAdd::VT_LEFT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn right_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAdd::VT_RIGHT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateAdd<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("left_id", Self::VT_LEFT_ID, false)?
     .visit_field::<u64>("right_id", Self::VT_RIGHT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateAddArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub left_id: u64,
    pub right_id: u64,
}
impl<'a> Default for GateAddArgs {
  #[inline]
  fn default() -> Self {
    GateAddArgs {
      type_id: 0,
      out_id: 0,
      left_id: 0,
      right_id: 0,
    }
  }
}

pub struct GateAddBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAdd::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_left_id(&mut self, left_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_LEFT_ID, left_id, 0);
  }
  #[inline]
  pub fn add_right_id(&mut self, right_id: u64) {
    self.fbb_.push_slot::<u64>(GateAdd::VT_RIGHT_ID, right_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAdd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateAdd<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateAdd");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("left_id", &self.left_id());
      ds.field("right_id", &self.right_id());
      ds.finish()
  }
}
pub enum GateMulOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateMul<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMul<'a> {
  type Inner = GateMul<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateMul<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LEFT_ID: flatbuffers::VOffsetT = 8;
  pub const VT_RIGHT_ID: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateMul { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateMulArgs
  ) -> flatbuffers::WIPOffset<GateMul<'bldr>> {
    let mut builder = GateMulBuilder::new(_fbb);
    builder.add_right_id(args.right_id);
    builder.add_left_id(args.left_id);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateMul::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMul::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn left_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMul::VT_LEFT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn right_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMul::VT_RIGHT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateMul<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("left_id", Self::VT_LEFT_ID, false)?
     .visit_field::<u64>("right_id", Self::VT_RIGHT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateMulArgs {
    pub type_id: u8,
    pub out_id: u64,
    pub left_id: u64,
    pub right_id: u64,
}
impl<'a> Default for GateMulArgs {
  #[inline]
  fn default() -> Self {
    GateMulArgs {
      type_id: 0,
      out_id: 0,
      left_id: 0,
      right_id: 0,
    }
  }
}

pub struct GateMulBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateMul::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_left_id(&mut self, left_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_LEFT_ID, left_id, 0);
  }
  #[inline]
  pub fn add_right_id(&mut self, right_id: u64) {
    self.fbb_.push_slot::<u64>(GateMul::VT_RIGHT_ID, right_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMul<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateMul<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateMul");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("left_id", &self.left_id());
      ds.field("right_id", &self.right_id());
      ds.finish()
  }
}
pub enum GateAddConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateAddConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAddConstant<'a> {
  type Inner = GateAddConstant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateAddConstant<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 8;
  pub const VT_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateAddConstant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateAddConstantArgs<'args>
  ) -> flatbuffers::WIPOffset<GateAddConstant<'bldr>> {
    let mut builder = GateAddConstantBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_out_id(args.out_id);
    if let Some(x) = args.constant { builder.add_constant(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateAddConstant::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAddConstant::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateAddConstant::VT_IN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn constant(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateAddConstant::VT_CONSTANT, None)}
  }
}

impl flatbuffers::Verifiable for GateAddConstant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("constant", Self::VT_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct GateAddConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GateAddConstantArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateAddConstantArgs {
      type_id: 0,
      out_id: 0,
      in_id: 0,
      constant: None,
    }
  }
}

pub struct GateAddConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateAddConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateAddConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateAddConstant::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateAddConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAddConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateAddConstant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateAddConstant");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("in_id", &self.in_id());
      ds.field("constant", &self.constant());
      ds.finish()
  }
}
pub enum GateMulConstantOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateMulConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMulConstant<'a> {
  type Inner = GateMulConstant<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateMulConstant<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_IN_ID: flatbuffers::VOffsetT = 8;
  pub const VT_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateMulConstant { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateMulConstantArgs<'args>
  ) -> flatbuffers::WIPOffset<GateMulConstant<'bldr>> {
    let mut builder = GateMulConstantBuilder::new(_fbb);
    builder.add_in_id(args.in_id);
    builder.add_out_id(args.out_id);
    if let Some(x) = args.constant { builder.add_constant(x); }
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateMulConstant::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMulConstant::VT_OUT_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateMulConstant::VT_IN_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn constant(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateMulConstant::VT_CONSTANT, None)}
  }
}

impl flatbuffers::Verifiable for GateMulConstant<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .visit_field::<u64>("in_id", Self::VT_IN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("constant", Self::VT_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct GateMulConstantArgs<'a> {
    pub type_id: u8,
    pub out_id: u64,
    pub in_id: u64,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for GateMulConstantArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateMulConstantArgs {
      type_id: 0,
      out_id: 0,
      in_id: 0,
      constant: None,
    }
  }
}

pub struct GateMulConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateMulConstant::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GateMulConstant::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn add_in_id(&mut self, in_id: u64) {
    self.fbb_.push_slot::<u64>(GateMulConstant::VT_IN_ID, in_id, 0);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateMulConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMulConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateMulConstant<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateMulConstant");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.field("in_id", &self.in_id());
      ds.field("constant", &self.constant());
      ds.finish()
  }
}
pub enum GatePublicOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatePublic<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatePublic<'a> {
  type Inner = GatePublic<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatePublic<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatePublic { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatePublicArgs
  ) -> flatbuffers::WIPOffset<GatePublic<'bldr>> {
    let mut builder = GatePublicBuilder::new(_fbb);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GatePublic::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatePublic::VT_OUT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GatePublic<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GatePublicArgs {
    pub type_id: u8,
    pub out_id: u64,
}
impl<'a> Default for GatePublicArgs {
  #[inline]
  fn default() -> Self {
    GatePublicArgs {
      type_id: 0,
      out_id: 0,
    }
  }
}

pub struct GatePublicBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatePublicBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GatePublic::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GatePublic::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatePublicBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatePublicBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatePublic<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatePublic<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatePublic");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.finish()
  }
}
pub enum GatePrivateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GatePrivate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GatePrivate<'a> {
  type Inner = GatePrivate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GatePrivate<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GatePrivate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatePrivateArgs
  ) -> flatbuffers::WIPOffset<GatePrivate<'bldr>> {
    let mut builder = GatePrivateBuilder::new(_fbb);
    builder.add_out_id(args.out_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GatePrivate::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GatePrivate::VT_OUT_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GatePrivate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("out_id", Self::VT_OUT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GatePrivateArgs {
    pub type_id: u8,
    pub out_id: u64,
}
impl<'a> Default for GatePrivateArgs {
  #[inline]
  fn default() -> Self {
    GatePrivateArgs {
      type_id: 0,
      out_id: 0,
    }
  }
}

pub struct GatePrivateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatePrivateBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GatePrivate::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_out_id(&mut self, out_id: u64) {
    self.fbb_.push_slot::<u64>(GatePrivate::VT_OUT_ID, out_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatePrivateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatePrivateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GatePrivate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GatePrivate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GatePrivate");
      ds.field("type_id", &self.type_id());
      ds.field("out_id", &self.out_id());
      ds.finish()
  }
}
pub enum GateNewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateNew<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateNew<'a> {
  type Inner = GateNew<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateNew<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FIRST_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateNew { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateNewArgs
  ) -> flatbuffers::WIPOffset<GateNew<'bldr>> {
    let mut builder = GateNewBuilder::new(_fbb);
    builder.add_last_id(args.last_id);
    builder.add_first_id(args.first_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateNew::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateNew::VT_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateNew::VT_LAST_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateNew<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("first_id", Self::VT_FIRST_ID, false)?
     .visit_field::<u64>("last_id", Self::VT_LAST_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateNewArgs {
    pub type_id: u8,
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for GateNewArgs {
  #[inline]
  fn default() -> Self {
    GateNewArgs {
      type_id: 0,
      first_id: 0,
      last_id: 0,
    }
  }
}

pub struct GateNewBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateNewBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateNew::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(GateNew::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(GateNew::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateNewBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateNewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateNew<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateNew<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateNew");
      ds.field("type_id", &self.type_id());
      ds.field("first_id", &self.first_id());
      ds.field("last_id", &self.last_id());
      ds.finish()
  }
}
pub enum GateDeleteOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateDelete<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateDelete<'a> {
  type Inner = GateDelete<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateDelete<'a> {
  pub const VT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FIRST_ID: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateDelete { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateDeleteArgs
  ) -> flatbuffers::WIPOffset<GateDelete<'bldr>> {
    let mut builder = GateDeleteBuilder::new(_fbb);
    builder.add_last_id(args.last_id);
    builder.add_first_id(args.first_id);
    builder.add_type_id(args.type_id);
    builder.finish()
  }


  #[inline]
  pub fn type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateDelete::VT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateDelete::VT_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateDelete::VT_LAST_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateDelete<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("type_id", Self::VT_TYPE_ID, false)?
     .visit_field::<u64>("first_id", Self::VT_FIRST_ID, false)?
     .visit_field::<u64>("last_id", Self::VT_LAST_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateDeleteArgs {
    pub type_id: u8,
    pub first_id: u64,
    pub last_id: u64,
}
impl<'a> Default for GateDeleteArgs {
  #[inline]
  fn default() -> Self {
    GateDeleteArgs {
      type_id: 0,
      first_id: 0,
      last_id: 0,
    }
  }
}

pub struct GateDeleteBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateDeleteBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_id(&mut self, type_id: u8) {
    self.fbb_.push_slot::<u8>(GateDelete::VT_TYPE_ID, type_id, 0);
  }
  #[inline]
  pub fn add_first_id(&mut self, first_id: u64) {
    self.fbb_.push_slot::<u64>(GateDelete::VT_FIRST_ID, first_id, 0);
  }
  #[inline]
  pub fn add_last_id(&mut self, last_id: u64) {
    self.fbb_.push_slot::<u64>(GateDelete::VT_LAST_ID, last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateDeleteBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateDeleteBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateDelete<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateDelete<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateDelete");
      ds.field("type_id", &self.type_id());
      ds.field("first_id", &self.first_id());
      ds.field("last_id", &self.last_id());
      ds.finish()
  }
}
pub enum GateConvertOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateConvert<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConvert<'a> {
  type Inner = GateConvert<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateConvert<'a> {
  pub const VT_OUT_TYPE_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_FIRST_ID: flatbuffers::VOffsetT = 6;
  pub const VT_OUT_LAST_ID: flatbuffers::VOffsetT = 8;
  pub const VT_IN_TYPE_ID: flatbuffers::VOffsetT = 10;
  pub const VT_IN_FIRST_ID: flatbuffers::VOffsetT = 12;
  pub const VT_IN_LAST_ID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateConvert { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateConvertArgs
  ) -> flatbuffers::WIPOffset<GateConvert<'bldr>> {
    let mut builder = GateConvertBuilder::new(_fbb);
    builder.add_in_last_id(args.in_last_id);
    builder.add_in_first_id(args.in_first_id);
    builder.add_out_last_id(args.out_last_id);
    builder.add_out_first_id(args.out_first_id);
    builder.add_in_type_id(args.in_type_id);
    builder.add_out_type_id(args.out_type_id);
    builder.finish()
  }


  #[inline]
  pub fn out_type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateConvert::VT_OUT_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_OUT_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn out_last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_OUT_LAST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_type_id(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(GateConvert::VT_IN_TYPE_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_first_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_IN_FIRST_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn in_last_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(GateConvert::VT_IN_LAST_ID, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GateConvert<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u8>("out_type_id", Self::VT_OUT_TYPE_ID, false)?
     .visit_field::<u64>("out_first_id", Self::VT_OUT_FIRST_ID, false)?
     .visit_field::<u64>("out_last_id", Self::VT_OUT_LAST_ID, false)?
     .visit_field::<u8>("in_type_id", Self::VT_IN_TYPE_ID, false)?
     .visit_field::<u64>("in_first_id", Self::VT_IN_FIRST_ID, false)?
     .visit_field::<u64>("in_last_id", Self::VT_IN_LAST_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct GateConvertArgs {
    pub out_type_id: u8,
    pub out_first_id: u64,
    pub out_last_id: u64,
    pub in_type_id: u8,
    pub in_first_id: u64,
    pub in_last_id: u64,
}
impl<'a> Default for GateConvertArgs {
  #[inline]
  fn default() -> Self {
    GateConvertArgs {
      out_type_id: 0,
      out_first_id: 0,
      out_last_id: 0,
      in_type_id: 0,
      in_first_id: 0,
      in_last_id: 0,
    }
  }
}

pub struct GateConvertBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConvertBuilder<'a, 'b> {
  #[inline]
  pub fn add_out_type_id(&mut self, out_type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConvert::VT_OUT_TYPE_ID, out_type_id, 0);
  }
  #[inline]
  pub fn add_out_first_id(&mut self, out_first_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_OUT_FIRST_ID, out_first_id, 0);
  }
  #[inline]
  pub fn add_out_last_id(&mut self, out_last_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_OUT_LAST_ID, out_last_id, 0);
  }
  #[inline]
  pub fn add_in_type_id(&mut self, in_type_id: u8) {
    self.fbb_.push_slot::<u8>(GateConvert::VT_IN_TYPE_ID, in_type_id, 0);
  }
  #[inline]
  pub fn add_in_first_id(&mut self, in_first_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_IN_FIRST_ID, in_first_id, 0);
  }
  #[inline]
  pub fn add_in_last_id(&mut self, in_last_id: u64) {
    self.fbb_.push_slot::<u64>(GateConvert::VT_IN_LAST_ID, in_last_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConvertBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConvertBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConvert<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateConvert<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateConvert");
      ds.field("out_type_id", &self.out_type_id());
      ds.field("out_first_id", &self.out_first_id());
      ds.field("out_last_id", &self.out_last_id());
      ds.field("in_type_id", &self.in_type_id());
      ds.field("in_first_id", &self.in_first_id());
      ds.field("in_last_id", &self.in_last_id());
      ds.finish()
  }
}
pub enum GatesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Gates<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gates<'a> {
  type Inner = Gates<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Gates<'a> {
  pub const VT_GATES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Gates { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GatesArgs<'args>
  ) -> flatbuffers::WIPOffset<Gates<'bldr>> {
    let mut builder = GatesBuilder::new(_fbb);
    if let Some(x) = args.gates { builder.add_gates(x); }
    builder.finish()
  }


  #[inline]
  pub fn gates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate>>>>(Gates::VT_GATES, None)}
  }
}

impl flatbuffers::Verifiable for Gates<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Gate>>>>("gates", Self::VT_GATES, false)?
     .finish();
    Ok(())
  }
}
pub struct GatesArgs<'a> {
    pub gates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>>>,
}
impl<'a> Default for GatesArgs<'a> {
  #[inline]
  fn default() -> Self {
    GatesArgs {
      gates: None,
    }
  }
}

pub struct GatesBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GatesBuilder<'a, 'b> {
  #[inline]
  pub fn add_gates(&mut self, gates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Gate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Gates::VT_GATES, gates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GatesBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GatesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gates<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Gates<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Gates");
      ds.field("gates", &self.gates());
      ds.finish()
  }
}
pub enum PluginBodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PluginBody<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PluginBody<'a> {
  type Inner = PluginBody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PluginBody<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OPERATION: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 8;
  pub const VT_PUBLIC_COUNT: flatbuffers::VOffsetT = 10;
  pub const VT_PRIVATE_COUNT: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PluginBody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PluginBodyArgs<'args>
  ) -> flatbuffers::WIPOffset<PluginBody<'bldr>> {
    let mut builder = PluginBodyBuilder::new(_fbb);
    if let Some(x) = args.private_count { builder.add_private_count(x); }
    if let Some(x) = args.public_count { builder.add_public_count(x); }
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.operation { builder.add_operation(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginBody::VT_NAME, None)}
  }
  #[inline]
  pub fn operation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PluginBody::VT_OPERATION, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(PluginBody::VT_PARAMS, None)}
  }
  #[inline]
  pub fn public_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(PluginBody::VT_PUBLIC_COUNT, None)}
  }
  #[inline]
  pub fn private_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(PluginBody::VT_PRIVATE_COUNT, None)}
  }
}

impl flatbuffers::Verifiable for PluginBody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("operation", Self::VT_OPERATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("public_count", Self::VT_PUBLIC_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("private_count", Self::VT_PRIVATE_COUNT, false)?
     .finish();
    Ok(())
  }
}
pub struct PluginBodyArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub operation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub public_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
    pub private_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
}
impl<'a> Default for PluginBodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    PluginBodyArgs {
      name: None,
      operation: None,
      params: None,
      public_count: None,
      private_count: None,
    }
  }
}

pub struct PluginBodyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PluginBodyBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_NAME, name);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_OPERATION, operation);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PARAMS, params);
  }
  #[inline]
  pub fn add_public_count(&mut self, public_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PUBLIC_COUNT, public_count);
  }
  #[inline]
  pub fn add_private_count(&mut self, private_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PluginBody::VT_PRIVATE_COUNT, private_count);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PluginBodyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PluginBodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PluginBody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PluginBody<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PluginBody");
      ds.field("name", &self.name());
      ds.field("operation", &self.operation());
      ds.field("params", &self.params());
      ds.field("public_count", &self.public_count());
      ds.field("private_count", &self.private_count());
      ds.finish()
  }
}
pub enum FunctionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Function<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Function<'a> {
  type Inner = Function<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Function<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OUTPUT_COUNT: flatbuffers::VOffsetT = 6;
  pub const VT_INPUT_COUNT: flatbuffers::VOffsetT = 8;
  pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 10;
  pub const VT_BODY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Function { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args FunctionArgs<'args>
  ) -> flatbuffers::WIPOffset<Function<'bldr>> {
    let mut builder = FunctionBuilder::new(_fbb);
    if let Some(x) = args.body { builder.add_body(x); }
    if let Some(x) = args.input_count { builder.add_input_count(x); }
    if let Some(x) = args.output_count { builder.add_output_count(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_body_type(args.body_type);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Function::VT_NAME, None)}
  }
  #[inline]
  pub fn output_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(Function::VT_OUTPUT_COUNT, None)}
  }
  #[inline]
  pub fn input_count(&self) -> Option<flatbuffers::Vector<'a, Count>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Count>>>(Function::VT_INPUT_COUNT, None)}
  }
  #[inline]
  pub fn body_type(&self) -> FunctionBody {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<FunctionBody>(Function::VT_BODY_TYPE, Some(FunctionBody::NONE)).unwrap()}
  }
  #[inline]
  pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Function::VT_BODY, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_gates(&self) -> Option<Gates<'a>> {
    if self.body_type() == FunctionBody::Gates {
      self.body().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Gates::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn body_as_plugin_body(&self) -> Option<PluginBody<'a>> {
    if self.body_type() == FunctionBody::PluginBody {
      self.body().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PluginBody::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Function<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("output_count", Self::VT_OUTPUT_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Count>>>("input_count", Self::VT_INPUT_COUNT, false)?
     .visit_union::<FunctionBody, _>("body_type", Self::VT_BODY_TYPE, "body", Self::VT_BODY, false, |key, v, pos| {
        match key {
          FunctionBody::Gates => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Gates>>("FunctionBody::Gates", pos),
          FunctionBody::PluginBody => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PluginBody>>("FunctionBody::PluginBody", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct FunctionArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub output_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
    pub input_count: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Count>>>,
    pub body_type: FunctionBody,
    pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FunctionArgs<'a> {
  #[inline]
  fn default() -> Self {
    FunctionArgs {
      name: None,
      output_count: None,
      input_count: None,
      body_type: FunctionBody::NONE,
      body: None,
    }
  }
}

pub struct FunctionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FunctionBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_NAME, name);
  }
  #[inline]
  pub fn add_output_count(&mut self, output_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_OUTPUT_COUNT, output_count);
  }
  #[inline]
  pub fn add_input_count(&mut self, input_count: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Count>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_INPUT_COUNT, input_count);
  }
  #[inline]
  pub fn add_body_type(&mut self, body_type: FunctionBody) {
    self.fbb_.push_slot::<FunctionBody>(Function::VT_BODY_TYPE, body_type, FunctionBody::NONE);
  }
  #[inline]
  pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Function::VT_BODY, body);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FunctionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FunctionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Function<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Function<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Function");
      ds.field("name", &self.name());
      ds.field("output_count", &self.output_count());
      ds.field("input_count", &self.input_count());
      ds.field("body_type", &self.body_type());
      match self.body_type() {
        FunctionBody::Gates => {
          if let Some(x) = self.body_as_gates() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        FunctionBody::PluginBody => {
          if let Some(x) = self.body_as_plugin_body() {
            ds.field("body", &x)
          } else {
            ds.field("body", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("body", &x)
        },
      };
      ds.finish()
  }
}
pub enum GateCallOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GateCall<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCall<'a> {
  type Inner = GateCall<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GateCall<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_OUT_IDS: flatbuffers::VOffsetT = 6;
  pub const VT_IN_IDS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GateCall { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateCallArgs<'args>
  ) -> flatbuffers::WIPOffset<GateCall<'bldr>> {
    let mut builder = GateCallBuilder::new(_fbb);
    if let Some(x) = args.in_ids { builder.add_in_ids(x); }
    if let Some(x) = args.out_ids { builder.add_out_ids(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GateCall::VT_NAME, None)}
  }
  #[inline]
  pub fn out_ids(&self) -> Option<flatbuffers::Vector<'a, WireRange>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, WireRange>>>(GateCall::VT_OUT_IDS, None)}
  }
  #[inline]
  pub fn in_ids(&self) -> Option<flatbuffers::Vector<'a, WireRange>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, WireRange>>>(GateCall::VT_IN_IDS, None)}
  }
}

impl flatbuffers::Verifiable for GateCall<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, WireRange>>>("out_ids", Self::VT_OUT_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, WireRange>>>("in_ids", Self::VT_IN_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct GateCallArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub out_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, WireRange>>>,
    pub in_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, WireRange>>>,
}
impl<'a> Default for GateCallArgs<'a> {
  #[inline]
  fn default() -> Self {
    GateCallArgs {
      name: None,
      out_ids: None,
      in_ids: None,
    }
  }
}

pub struct GateCallBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCallBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_NAME, name);
  }
  #[inline]
  pub fn add_out_ids(&mut self, out_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , WireRange>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_OUT_IDS, out_ids);
  }
  #[inline]
  pub fn add_in_ids(&mut self, in_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , WireRange>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateCall::VT_IN_IDS, in_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCallBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCallBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCall<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GateCall<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GateCall");
      ds.field("name", &self.name());
      ds.field("out_ids", &self.out_ids());
      ds.field("in_ids", &self.in_ids());
      ds.finish()
  }
}
pub enum GateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Gate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gate<'a> {
  type Inner = Gate<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Gate<'a> {
  pub const VT_GATE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_GATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Gate { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args GateArgs
  ) -> flatbuffers::WIPOffset<Gate<'bldr>> {
    let mut builder = GateBuilder::new(_fbb);
    if let Some(x) = args.gate { builder.add_gate(x); }
    builder.add_gate_type(args.gate_type);
    builder.finish()
  }


  #[inline]
  pub fn gate_type(&self) -> GateSet {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GateSet>(Gate::VT_GATE_TYPE, Some(GateSet::NONE)).unwrap()}
  }
  #[inline]
  pub fn gate(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Gate::VT_GATE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_constant(&self) -> Option<GateConstant<'a>> {
    if self.gate_type() == GateSet::GateConstant {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateConstant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_assert_zero(&self) -> Option<GateAssertZero<'a>> {
    if self.gate_type() == GateSet::GateAssertZero {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateAssertZero::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_copy(&self) -> Option<GateCopy<'a>> {
    if self.gate_type() == GateSet::GateCopy {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateCopy::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_add(&self) -> Option<GateAdd<'a>> {
    if self.gate_type() == GateSet::GateAdd {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateAdd::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_mul(&self) -> Option<GateMul<'a>> {
    if self.gate_type() == GateSet::GateMul {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateMul::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_add_constant(&self) -> Option<GateAddConstant<'a>> {
    if self.gate_type() == GateSet::GateAddConstant {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateAddConstant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_mul_constant(&self) -> Option<GateMulConstant<'a>> {
    if self.gate_type() == GateSet::GateMulConstant {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateMulConstant::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_public(&self) -> Option<GatePublic<'a>> {
    if self.gate_type() == GateSet::GatePublic {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GatePublic::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_private(&self) -> Option<GatePrivate<'a>> {
    if self.gate_type() == GateSet::GatePrivate {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GatePrivate::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_new(&self) -> Option<GateNew<'a>> {
    if self.gate_type() == GateSet::GateNew {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateNew::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_delete(&self) -> Option<GateDelete<'a>> {
    if self.gate_type() == GateSet::GateDelete {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateDelete::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_convert(&self) -> Option<GateConvert<'a>> {
    if self.gate_type() == GateSet::GateConvert {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateConvert::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_call(&self) -> Option<GateCall<'a>> {
    if self.gate_type() == GateSet::GateCall {
      self.gate().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { GateCall::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Gate<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<GateSet, _>("gate_type", Self::VT_GATE_TYPE, "gate", Self::VT_GATE, false, |key, v, pos| {
        match key {
          GateSet::GateConstant => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateConstant>>("GateSet::GateConstant", pos),
          GateSet::GateAssertZero => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateAssertZero>>("GateSet::GateAssertZero", pos),
          GateSet::GateCopy => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateCopy>>("GateSet::GateCopy", pos),
          GateSet::GateAdd => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateAdd>>("GateSet::GateAdd", pos),
          GateSet::GateMul => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateMul>>("GateSet::GateMul", pos),
          GateSet::GateAddConstant => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateAddConstant>>("GateSet::GateAddConstant", pos),
          GateSet::GateMulConstant => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateMulConstant>>("GateSet::GateMulConstant", pos),
          GateSet::GatePublic => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatePublic>>("GateSet::GatePublic", pos),
          GateSet::GatePrivate => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GatePrivate>>("GateSet::GatePrivate", pos),
          GateSet::GateNew => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateNew>>("GateSet::GateNew", pos),
          GateSet::GateDelete => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateDelete>>("GateSet::GateDelete", pos),
          GateSet::GateConvert => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateConvert>>("GateSet::GateConvert", pos),
          GateSet::GateCall => v.verify_union_variant::<flatbuffers::ForwardsUOffset<GateCall>>("GateSet::GateCall", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct GateArgs {
    pub gate_type: GateSet,
    pub gate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GateArgs {
  #[inline]
  fn default() -> Self {
    GateArgs {
      gate_type: GateSet::NONE,
      gate: None,
    }
  }
}

pub struct GateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateBuilder<'a, 'b> {
  #[inline]
  pub fn add_gate_type(&mut self, gate_type: GateSet) {
    self.fbb_.push_slot::<GateSet>(Gate::VT_GATE_TYPE, gate_type, GateSet::NONE);
  }
  #[inline]
  pub fn add_gate(&mut self, gate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Gate::VT_GATE, gate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Gate<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Gate");
      ds.field("gate_type", &self.gate_type());
      match self.gate_type() {
        GateSet::GateConstant => {
          if let Some(x) = self.gate_as_gate_constant() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateAssertZero => {
          if let Some(x) = self.gate_as_gate_assert_zero() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateCopy => {
          if let Some(x) = self.gate_as_gate_copy() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateAdd => {
          if let Some(x) = self.gate_as_gate_add() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateMul => {
          if let Some(x) = self.gate_as_gate_mul() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateAddConstant => {
          if let Some(x) = self.gate_as_gate_add_constant() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateMulConstant => {
          if let Some(x) = self.gate_as_gate_mul_constant() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GatePublic => {
          if let Some(x) = self.gate_as_gate_public() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GatePrivate => {
          if let Some(x) = self.gate_as_gate_private() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateNew => {
          if let Some(x) = self.gate_as_gate_new() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateDelete => {
          if let Some(x) = self.gate_as_gate_delete() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateConvert => {
          if let Some(x) = self.gate_as_gate_convert() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        GateSet::GateCall => {
          if let Some(x) = self.gate_as_gate_call() {
            ds.field("gate", &x)
          } else {
            ds.field("gate", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("gate", &x)
        },
      };
      ds.finish()
  }
}
pub enum RootOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
  type Inner = Root<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Root<'a> {
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Root { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args RootArgs
  ) -> flatbuffers::WIPOffset<Root<'bldr>> {
    let mut builder = RootBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_message_type(args.message_type);
    builder.finish()
  }


  #[inline]
  pub fn message_type(&self) -> Message {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_relation(&self) -> Option<Relation<'a>> {
    if self.message_type() == Message::Relation {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Relation::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_public_inputs(&self) -> Option<PublicInputs<'a>> {
    if self.message_type() == Message::PublicInputs {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PublicInputs::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_private_inputs(&self) -> Option<PrivateInputs<'a>> {
    if self.message_type() == Message::PrivateInputs {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PrivateInputs::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Root<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Message, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          Message::Relation => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Relation>>("Message::Relation", pos),
          Message::PublicInputs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PublicInputs>>("Message::PublicInputs", pos),
          Message::PrivateInputs => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PrivateInputs>>("Message::PrivateInputs", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
  #[inline]
  fn default() -> Self {
    RootArgs {
      message_type: Message::NONE,
      message: None,
    }
  }
}

pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Root<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Root");
      ds.field("message_type", &self.message_type());
      match self.message_type() {
        Message::Relation => {
          if let Some(x) = self.message_as_relation() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::PublicInputs => {
          if let Some(x) = self.message_as_public_inputs() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Message::PrivateInputs => {
          if let Some(x) = self.message_as_private_inputs() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("message", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Root`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn root_as_root(buf: &[u8]) -> Result<Root, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Root>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Root` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_root_unchecked`.
pub fn size_prefixed_root_as_root(buf: &[u8]) -> Result<Root, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Root>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Root` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn root_as_root_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Root<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Root<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Root` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_root_unchecked`.
pub fn size_prefixed_root_as_root_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Root<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Root<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Root and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Root`.
pub unsafe fn root_as_root_unchecked(buf: &[u8]) -> Root {
  flatbuffers::root_unchecked::<Root>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Root and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Root`.
pub unsafe fn size_prefixed_root_as_root_unchecked(buf: &[u8]) -> Root {
  flatbuffers::size_prefixed_root_unchecked::<Root>(buf)
}
pub const ROOT_IDENTIFIER: &str = "siev";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false)
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true)
}

pub const ROOT_EXTENSION: &str = "sieve";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod sieve_ir

