/*!
All-but-one vector commitment implementation.

The implementation follows the [the FAEST spec](https://faest.info/faest-spec-v1.1.pdf).
*/
#![allow(dead_code)]
use vectoreyes::{Aes128EncryptOnly, AesBlockCipher, U8x16};

// The implementation of PRG, H0, H1 follows the interface provided in the
// [the FAEST spec, page 16](https://faest.info/faest-spec-v1.1.pdf),
// but specialized to how they are used in functions:
// * commit()
// * open()
// * reconstruct()
// * verify()
// The implementation of these functions follows
// [the FAEST spec, Figure 5.1, page 27](https://faest.info/faest-spec-v1.1.pdf).

// In the following, we assume the $\lambda$ security parameter to be 128 as set in
// `schmivitz::parameters::SECURITY_PARAM`.

// Type for Initialization Vector
pub(crate) type IV = U8x16;
// Type for Keys, that is the internal nodes of the Tree-PRG
pub(crate) type Key = U8x16;
// Type for Commitments generated by 1-VC
pub(crate) type Com = (U8x16, U8x16);
// Type for Seed generated by 1-VC
pub(crate) type Seed = U8x16;

// Pseudo random generator structure
#[allow(clippy::upper_case_acronyms)]
pub(crate) struct PRG {
    aes0: Aes128EncryptOnly,
    aes1: Aes128EncryptOnly,
}

impl PRG {
    // Create a PRG from an `IV`
    fn new_with_iv(iv: IV) -> Self {
        // This is similar to how things are done in ocelot/.../vole.rs
        let seed = Aes128EncryptOnly::new_with_key(iv);

        let aes0 = Aes128EncryptOnly::new_with_key(seed.encrypt([255; 16].into()));
        let aes1 = Aes128EncryptOnly::new_with_key(seed.encrypt([254; 16].into()));

        Self { aes0, aes1 }
    }

    // Encrypt function.
    // It is specialized to generate ${0,1}^{2\lambda}$ outputs.
    fn encrypt(&self, x: Key) -> (Key, Key) {
        let t1 = self.aes0.encrypt(x);
        let t2 = self.aes1.encrypt(x);
        (t1, t2)
    }
}

// blake3 hasher computes hashes that are in ${0,1}^{2*128}$.
// Here are some helper functions to translate the values back to U8x16
fn blake3_to_u8x16(v: Vec<u8>) -> U8x16 {
    assert!(v.len() == 32);
    let mut arr: [u8; 16] = Default::default();
    arr.copy_from_slice(&v[0..16]);
    U8x16::from_array(arr)
}

fn blake3_to_2_u8x16(v: Vec<u8>) -> (U8x16, U8x16) {
    let mut arr1: [u8; 16] = Default::default();
    arr1.copy_from_slice(&v[0..16]);
    let mut arr2: [u8; 16] = Default::default();
    arr2.copy_from_slice(&v[16..32]);
    (U8x16::from_array(arr1), U8x16::from_array(arr2))
}

// Hash function
fn h0(x: Key, iv: IV) -> (Seed, Com) {
    let x1: [u8; 16] = x.into();
    let iv1: [u8; 16] = iv.into();

    // Hash x||iv to generate the Key
    let mut hasher = blake3::Hasher::new();
    hasher.update(&x1);
    hasher.update(&iv1);
    let hash_for_key = hasher.finalize().as_bytes().to_vec();

    // Now hash iv||x to generate the Com
    let mut hasher = blake3::Hasher::new();
    hasher.update(&iv1);
    hasher.update(&x1);
    let hash_for_com = hasher.finalize().as_bytes().to_vec();

    (
        blake3_to_u8x16(hash_for_key),
        blake3_to_2_u8x16(hash_for_com),
    )
}

// Return type for the $`H1`$ function
#[repr(transparent)]
#[derive(PartialEq)]
pub(crate) struct H1(Com);

// Hash function on stream of values
fn h1(coms: &Coms) -> H1 {
    let mut hasher = blake3::Hasher::new();
    for com in coms.0.iter() {
        let com1: [u8; 16] = com.0.into();
        let com2: [u8; 16] = com.1.into();
        hasher.update(&com1);
        hasher.update(&com2);
    }
    let h = hasher.finalize().as_bytes().to_vec();
    let (com1, com2) = blake3_to_2_u8x16(h);
    H1((com1, com2))
}

// The type holding the tree of all the Keys
#[repr(transparent)]
#[derive(Debug)]
pub(crate) struct Keys(Vec<Key>);

impl Keys {
    // get a key in the tree at `depth` and index at the associated layer
    fn get(&self, depth: usize, idx: usize) -> Key {
        let layer_start = (1 << depth) - 1;
        self.0[layer_start + idx]
    }

    // set a key in the tree at `depth` and index at the associated layer
    fn set(&mut self, depth: usize, idx: usize, k: Key) {
        let layer_start = (1 << depth) - 1;
        self.0[layer_start + idx] = k;
    }

    // get a full layer as a slice of keys
    fn get_layer(&self, depth: usize) -> &[Key] {
        let layer_start = (1 << depth) - 1;
        let layer_end = (1 << (depth + 1)) - 1;
        &self.0[layer_start..layer_end]
    }
}

#[repr(transparent)]
#[derive(Debug)]
pub(crate) struct Coms(Vec<Com>);

// Full decommitment as computed by the prover: $`(k^i_j, com_j\in[0..n]$)`$
pub(crate) type Decom = (Keys, Coms);

// Partial decommitment as received by the verifier from the prover $`(cop, com_{j^*}$)`$
pub(crate) type Pdecom = (Keys, Com);

// Type for the seeds generated by 1-VC
#[repr(transparent)]
pub(crate) struct Seeds(Vec<Seed>);

// The tree function does not appear in the paper but it is the factorization of the loop computing
// all the internal keys, bottom seeds and commitments at a given depth.
// This function is used in `commit()` and `reconstruct`
fn tree(prg: &PRG, iv: IV, r: Key, depth: usize) -> (Keys, Seeds, Coms) {
    let n = 1 << depth;

    let mut ks = Keys(vec![Key::default(); 2 * n - 1]);
    // initialize the first key
    ks.set(0, 0, r);

    for d in 1..depth + 1 {
        let n_previous_level = 1 << (d - 1);
        for j in 0..n_previous_level {
            let (t1, t2) = prg.encrypt(ks.get(d - 1, j));
            ks.set(d, j * 2, t1);
            ks.set(d, j * 2 + 1, t2);
        }
    }

    // Set the bottom seeds and commitments:
    let mut seeds = Vec::with_capacity(n);
    let mut coms = Vec::with_capacity(n);
    for k in ks.get_layer(depth) {
        let (sd, com) = h0(*k, iv);
        seeds.push(sd);
        coms.push(com);
    }

    (ks, Seeds(seeds), Coms(coms))
}

// Implements `VC.Commit` from Fig 5.1
pub(crate) fn commit(r: Key, iv: IV, depth: usize) -> (H1, Decom, Seeds) {
    let prg = PRG::new_with_iv(iv);
    let (ks, seeds, coms) = tree(&prg, iv, r, depth);

    // compute the h
    let h = h1(&coms);

    (h, (ks, coms), seeds)
}

// Implements `NumRec` from Fig. 3.2
fn num_rec(j: &[bool]) -> usize {
    let mut r = 0;
    let mut pow2 = 1;
    for b in j.iter() {
        r += (if *b { 1 } else { 0 }) * pow2;
        pow2 *= 2;
    }
    r
}

// Implements `VC.Open` from Fig 5.1
pub(crate) fn open(decom: Decom, j: Vec<bool>) -> Pdecom {
    let j_num = num_rec(&j);
    let mut cop: Vec<Key> = Vec::with_capacity(j.len());

    let (ks, coms) = decom;
    let mut a = 0;
    for (i, b) in j.iter().rev().enumerate() {
        let idx = 2 * a + (if *b { 0 } else { 1 });
        cop.push(ks.get(i + 1, idx));

        a = 2 * a + (if *b { 1 } else { 0 });
    }

    (Keys(cop), coms.0[j_num])
}

// Implements `VC.Reconstruct` from Fig 5.1
pub(crate) fn reconstruct(pdecom: Pdecom, j: Vec<bool>, iv: IV) -> (H1, Seeds) {
    let prg = PRG::new_with_iv(iv);
    assert_eq!(pdecom.0 .0.len(), j.len());
    let d = j.len();

    let (cop, com_j) = pdecom;

    let mut coms = vec![Com::default(); 1 << d];
    // The seeds computed by `reconstruct` have one less entry than coms
    let mut seeds = vec![Seed::default(); (1 << d) - 1];

    let mut pos = 0;
    for (i, (b, k)) in std::iter::zip(j.iter().rev(), cop.0).enumerate() {
        let how_many = 1 << (d - i - 1);
        let (_keys, seeds_subtree, coms_subtree) = tree(&prg, iv, k, d - i - 1);
        let copy_start = if *b { pos } else { pos + how_many };

        // if the boolean is one then the hidden seed in on the left,
        // and then the start to copy the seed is shifted by one.
        let copy_start_seeds = if *b { copy_start } else { copy_start - 1 };

        // copy commitments from the subtree into the array of all coms
        coms[copy_start..(copy_start + how_many)].copy_from_slice(&coms_subtree.0[..how_many]);

        seeds[copy_start_seeds..(copy_start_seeds + how_many)]
            .copy_from_slice(&seeds_subtree.0[..how_many]);

        pos = if *b { pos + how_many } else { pos };
    }
    // After computing all the commitments, except com_j, it is finally setup in
    // the right spot.
    coms[pos] = com_j;

    // compute the hash using H1
    let h_computed = h1(&Coms(coms));

    assert_eq!(seeds.len(), (1 << d) - 1);
    (h_computed, Seeds(seeds))
}

// Implements `VC.Verify` from Fig 5.1
pub(crate) fn verify(h_com: H1, pdecom: Pdecom, j: Vec<bool>, iv: IV) -> bool {
    assert_eq!(pdecom.0 .0.len(), j.len());

    let (h_computed, _seeds) = reconstruct(pdecom, j, iv);
    h_com == h_computed
}

#[cfg(test)]
mod test {
    use super::{commit, num_rec, open, reconstruct, verify, Key, Keys, IV};
    use proptest::prelude::*;

    #[test]
    fn test_num_rec() {
        let v = num_rec(&[true, false, true, true]);
        assert_eq!(v, 13);
    }

    // Test the correctness of values computed by commit/open/verify/reconstruct
    fn test_1_vc_correctness(r: Key, iv: IV, j: Vec<bool>) {
        let depth = j.len();
        // prover side
        let (h, decom, sd) = commit(r, iv, depth);
        let (cop, com_j) = open(decom, j.clone());

        // verifier side
        let j_num = num_rec(&j);
        let b = verify(h, (Keys(cop.0.clone()), com_j), j.clone(), iv);
        assert!(b); // check verify

        // test that the seeds from the prover are the same as the ones found by the verifier
        let (_, seeds) = reconstruct((cop, com_j), j, iv);

        let mut prv_i = 0;
        for vrf_i in 0..(1 << depth) - 1 {
            if vrf_i == j_num {
                // if the index is equal to j then we skip a seed in the prover
                prv_i += 1;
            }
            assert_eq!(sd.0[prv_i], seeds.0[vrf_i]);
            prv_i += 1;
        }
    }

    #[test]
    fn test_1_vc_simple2() {
        let iv = IV::default();
        let r = Key::default();

        let j = vec![false, true];
        test_1_vc_correctness(r, iv, j);
    }

    #[test]
    fn test_1_vc_simple3() {
        let iv = IV::default();
        let r = Key::default();

        let j = vec![true, true, false];
        test_1_vc_correctness(r, iv, j);
    }

    #[test]
    fn test_1_vc_simple8() {
        let iv = IV::default();
        let r = Key::default();

        let j = vec![false, true, true, false, false, true, true, true];
        test_1_vc_correctness(r, iv, j);
    }

    proptest! {
        #![proptest_config(ProptestConfig::with_cases(1000))]

        #[test]
        fn test_1_vc_proptest(
            ref j in prop::collection::vec(any::<bool>(), 8),
            ref rand_vec in prop::collection::vec(any::<u8>(), 32))
        {
            // setup random iv and r:
            let (iv, r) = super::blake3_to_2_u8x16(rand_vec.to_vec());

            // Test
            test_1_vc_correctness(r, iv, j.to_vec());
        }
    }
}
