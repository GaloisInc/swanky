// @generated
// rustfmt-format_generated_files: false
// This file was auto-generated by generate.py DO NOT MODIFY
#![allow(unused_variables, unused_mut)]
use crate::array_utils::*;
impl UnrollableArraySize<0> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 0] {
        []
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 0], mut f: F) -> [U; 0] {
        match arr {
            [] => [],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 0],
        mut f: F,
    ) -> Result<[U; 0], E> {
        match arr {
            [] => Ok([]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 0]) -> [(usize, T); 0] {
        match arr {
            [] => [],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 0], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [] => {}
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 0], arr2: [T2; 0]) -> [(T1, T2); 0] {
        match arr1 {
            [] => match arr2 {
                [] => [],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 0]) -> [&T; 0] {
        match arr {
            [] => [],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 0]) -> [&mut T; 0] {
        match arr {
            [] => [],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 0] {
    type T = T;
    type AdjacentPairs = [(T, T); 0];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [] => [],
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 0] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [] => [],
        }
    }
}
impl UnrollableArraySize<1> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 1] {
        let x_0 = f(0);
        [x_0]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 1], mut f: F) -> [U; 1] {
        match arr {
            [arr_0] => [f(arr_0)],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 1],
        mut f: F,
    ) -> Result<[U; 1], E> {
        match arr {
            [arr_0] => Ok([f(arr_0)?]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 1]) -> [(usize, T); 1] {
        match arr {
            [arr_0] => [(0, arr_0)],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 1], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0] => {
                acu = f(acu, arr_0);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 1], arr2: [T2; 1]) -> [(T1, T2); 1] {
        match arr1 {
            [arr1_0] => match arr2 {
                [arr2_0] => [(arr1_0, arr2_0)],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 1]) -> [&T; 1] {
        match arr {
            [arr_0] => [arr_0],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 1]) -> [&mut T; 1] {
        match arr {
            [arr_0] => [arr_0],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 1] {
    type T = T;
    type AdjacentPairs = [(T, T); 1];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0] => [(self_0, fallback)],
        }
    }
}
impl UnrollableArraySize<2> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 2] {
        let x_0 = f(0);
        let x_1 = f(1);
        [x_0, x_1]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 2], mut f: F) -> [U; 2] {
        match arr {
            [arr_0, arr_1] => [f(arr_0), f(arr_1)],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 2],
        mut f: F,
    ) -> Result<[U; 2], E> {
        match arr {
            [arr_0, arr_1] => Ok([f(arr_0)?, f(arr_1)?]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 2]) -> [(usize, T); 2] {
        match arr {
            [arr_0, arr_1] => [(0, arr_0), (1, arr_1)],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 2], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 2], arr2: [T2; 2]) -> [(T1, T2); 2] {
        match arr1 {
            [arr1_0, arr1_1] => match arr2 {
                [arr2_0, arr2_1] => [(arr1_0, arr2_0), (arr1_1, arr2_1)],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 2]) -> [&T; 2] {
        match arr {
            [arr_0, arr_1] => [arr_0, arr_1],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 2]) -> [&mut T; 2] {
        match arr {
            [arr_0, arr_1] => [arr_0, arr_1],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 2] {
    type T = T;
    type AdjacentPairs = [(T, T); 1];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1] => [(self_0, self_1)],
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 2] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1] => [(self_0, self_1)],
        }
    }
}
impl UnrollableArraySize<3> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 3] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        [x_0, x_1, x_2]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 3], mut f: F) -> [U; 3] {
        match arr {
            [arr_0, arr_1, arr_2] => [f(arr_0), f(arr_1), f(arr_2)],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 3],
        mut f: F,
    ) -> Result<[U; 3], E> {
        match arr {
            [arr_0, arr_1, arr_2] => Ok([f(arr_0)?, f(arr_1)?, f(arr_2)?]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 3]) -> [(usize, T); 3] {
        match arr {
            [arr_0, arr_1, arr_2] => [(0, arr_0), (1, arr_1), (2, arr_2)],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 3], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 3], arr2: [T2; 3]) -> [(T1, T2); 3] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2] => match arr2 {
                [arr2_0, arr2_1, arr2_2] => [(arr1_0, arr2_0), (arr1_1, arr2_1), (arr1_2, arr2_2)],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 3]) -> [&T; 3] {
        match arr {
            [arr_0, arr_1, arr_2] => [arr_0, arr_1, arr_2],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 3]) -> [&mut T; 3] {
        match arr {
            [arr_0, arr_1, arr_2] => [arr_0, arr_1, arr_2],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 3] {
    type T = T;
    type AdjacentPairs = [(T, T); 2];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2] => [(self_0, self_1), (self_2, fallback)],
        }
    }
}
impl UnrollableArraySize<4> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 4] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        [x_0, x_1, x_2, x_3]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 4], mut f: F) -> [U; 4] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3] => [f(arr_0), f(arr_1), f(arr_2), f(arr_3)],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 4],
        mut f: F,
    ) -> Result<[U; 4], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3] => Ok([f(arr_0)?, f(arr_1)?, f(arr_2)?, f(arr_3)?]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 4]) -> [(usize, T); 4] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3] => [(0, arr_0), (1, arr_1), (2, arr_2), (3, arr_3)],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 4], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 4], arr2: [T2; 4]) -> [(T1, T2); 4] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3] => match arr2 {
                [arr2_0, arr2_1, arr2_2, arr2_3] => [
                    (arr1_0, arr2_0),
                    (arr1_1, arr2_1),
                    (arr1_2, arr2_2),
                    (arr1_3, arr2_3),
                ],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 4]) -> [&T; 4] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3] => [arr_0, arr_1, arr_2, arr_3],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 4]) -> [&mut T; 4] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3] => [arr_0, arr_1, arr_2, arr_3],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 4] {
    type T = T;
    type AdjacentPairs = [(T, T); 2];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3] => [(self_0, self_1), (self_2, self_3)],
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 4] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3] => [(self_0, self_1), (self_2, self_3)],
        }
    }
}
impl UnrollableArraySize<5> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 5] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        [x_0, x_1, x_2, x_3, x_4]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 5], mut f: F) -> [U; 5] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4] => {
                [f(arr_0), f(arr_1), f(arr_2), f(arr_3), f(arr_4)]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 5],
        mut f: F,
    ) -> Result<[U; 5], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4] => {
                Ok([f(arr_0)?, f(arr_1)?, f(arr_2)?, f(arr_3)?, f(arr_4)?])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 5]) -> [(usize, T); 5] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4] => {
                [(0, arr_0), (1, arr_1), (2, arr_2), (3, arr_3), (4, arr_4)]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 5], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 5], arr2: [T2; 5]) -> [(T1, T2); 5] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4] => match arr2 {
                [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4] => [
                    (arr1_0, arr2_0),
                    (arr1_1, arr2_1),
                    (arr1_2, arr2_2),
                    (arr1_3, arr2_3),
                    (arr1_4, arr2_4),
                ],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 5]) -> [&T; 5] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4] => [arr_0, arr_1, arr_2, arr_3, arr_4],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 5]) -> [&mut T; 5] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4] => [arr_0, arr_1, arr_2, arr_3, arr_4],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 5] {
    type T = T;
    type AdjacentPairs = [(T, T); 3];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4] => {
                [(self_0, self_1), (self_2, self_3), (self_4, fallback)]
            }
        }
    }
}
impl UnrollableArraySize<6> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 6] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        [x_0, x_1, x_2, x_3, x_4, x_5]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 6], mut f: F) -> [U; 6] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5] => {
                [f(arr_0), f(arr_1), f(arr_2), f(arr_3), f(arr_4), f(arr_5)]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 6],
        mut f: F,
    ) -> Result<[U; 6], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5] => Ok([
                f(arr_0)?,
                f(arr_1)?,
                f(arr_2)?,
                f(arr_3)?,
                f(arr_4)?,
                f(arr_5)?,
            ]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 6]) -> [(usize, T); 6] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5] => [
                (0, arr_0),
                (1, arr_1),
                (2, arr_2),
                (3, arr_3),
                (4, arr_4),
                (5, arr_5),
            ],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 6], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 6], arr2: [T2; 6]) -> [(T1, T2); 6] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5] => match arr2 {
                [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5] => [
                    (arr1_0, arr2_0),
                    (arr1_1, arr2_1),
                    (arr1_2, arr2_2),
                    (arr1_3, arr2_3),
                    (arr1_4, arr2_4),
                    (arr1_5, arr2_5),
                ],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 6]) -> [&T; 6] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5] => {
                [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 6]) -> [&mut T; 6] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5] => {
                [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 6] {
    type T = T;
    type AdjacentPairs = [(T, T); 3];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5] => {
                [(self_0, self_1), (self_2, self_3), (self_4, self_5)]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 6] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5] => {
                [(self_0, self_1), (self_2, self_3), (self_4, self_5)]
            }
        }
    }
}
impl UnrollableArraySize<7> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 7] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        [x_0, x_1, x_2, x_3, x_4, x_5, x_6]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 7], mut f: F) -> [U; 7] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6] => [
                f(arr_0),
                f(arr_1),
                f(arr_2),
                f(arr_3),
                f(arr_4),
                f(arr_5),
                f(arr_6),
            ],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 7],
        mut f: F,
    ) -> Result<[U; 7], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6] => Ok([
                f(arr_0)?,
                f(arr_1)?,
                f(arr_2)?,
                f(arr_3)?,
                f(arr_4)?,
                f(arr_5)?,
                f(arr_6)?,
            ]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 7]) -> [(usize, T); 7] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6] => [
                (0, arr_0),
                (1, arr_1),
                (2, arr_2),
                (3, arr_3),
                (4, arr_4),
                (5, arr_5),
                (6, arr_6),
            ],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 7], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 7], arr2: [T2; 7]) -> [(T1, T2); 7] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6] => match arr2 {
                [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6] => [
                    (arr1_0, arr2_0),
                    (arr1_1, arr2_1),
                    (arr1_2, arr2_2),
                    (arr1_3, arr2_3),
                    (arr1_4, arr2_4),
                    (arr1_5, arr2_5),
                    (arr1_6, arr2_6),
                ],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 7]) -> [&T; 7] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6] => {
                [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 7]) -> [&mut T; 7] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6] => {
                [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 7] {
    type T = T;
    type AdjacentPairs = [(T, T); 4];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6] => [
                (self_0, self_1),
                (self_2, self_3),
                (self_4, self_5),
                (self_6, fallback),
            ],
        }
    }
}
impl UnrollableArraySize<8> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 8] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        [x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 8], mut f: F) -> [U; 8] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7] => [
                f(arr_0),
                f(arr_1),
                f(arr_2),
                f(arr_3),
                f(arr_4),
                f(arr_5),
                f(arr_6),
                f(arr_7),
            ],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 8],
        mut f: F,
    ) -> Result<[U; 8], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7] => Ok([
                f(arr_0)?,
                f(arr_1)?,
                f(arr_2)?,
                f(arr_3)?,
                f(arr_4)?,
                f(arr_5)?,
                f(arr_6)?,
                f(arr_7)?,
            ]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 8]) -> [(usize, T); 8] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7] => [
                (0, arr_0),
                (1, arr_1),
                (2, arr_2),
                (3, arr_3),
                (4, arr_4),
                (5, arr_5),
                (6, arr_6),
                (7, arr_7),
            ],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 8], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 8], arr2: [T2; 8]) -> [(T1, T2); 8] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7] => match arr2 {
                [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7] => [
                    (arr1_0, arr2_0),
                    (arr1_1, arr2_1),
                    (arr1_2, arr2_2),
                    (arr1_3, arr2_3),
                    (arr1_4, arr2_4),
                    (arr1_5, arr2_5),
                    (arr1_6, arr2_6),
                    (arr1_7, arr2_7),
                ],
            },
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 8]) -> [&T; 8] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7] => {
                [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 8]) -> [&mut T; 8] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7] => {
                [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 8] {
    type T = T;
    type AdjacentPairs = [(T, T); 4];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7] => [
                (self_0, self_1),
                (self_2, self_3),
                (self_4, self_5),
                (self_6, self_7),
            ],
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 8] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7] => [
                (self_0, self_1),
                (self_2, self_3),
                (self_4, self_5),
                (self_6, self_7),
            ],
        }
    }
}
impl UnrollableArraySize<9> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 9] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        [x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 9], mut f: F) -> [U; 9] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8] => [
                f(arr_0),
                f(arr_1),
                f(arr_2),
                f(arr_3),
                f(arr_4),
                f(arr_5),
                f(arr_6),
                f(arr_7),
                f(arr_8),
            ],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 9],
        mut f: F,
    ) -> Result<[U; 9], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8] => Ok([
                f(arr_0)?,
                f(arr_1)?,
                f(arr_2)?,
                f(arr_3)?,
                f(arr_4)?,
                f(arr_5)?,
                f(arr_6)?,
                f(arr_7)?,
                f(arr_8)?,
            ]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 9]) -> [(usize, T); 9] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8] => [
                (0, arr_0),
                (1, arr_1),
                (2, arr_2),
                (3, arr_3),
                (4, arr_4),
                (5, arr_5),
                (6, arr_6),
                (7, arr_7),
                (8, arr_8),
            ],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 9], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 9], arr2: [T2; 9]) -> [(T1, T2); 9] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8] => [
                        (arr1_0, arr2_0),
                        (arr1_1, arr2_1),
                        (arr1_2, arr2_2),
                        (arr1_3, arr2_3),
                        (arr1_4, arr2_4),
                        (arr1_5, arr2_5),
                        (arr1_6, arr2_6),
                        (arr1_7, arr2_7),
                        (arr1_8, arr2_8),
                    ],
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 9]) -> [&T; 9] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8] => [
                arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8,
            ],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 9]) -> [&mut T; 9] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8] => [
                arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8,
            ],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 9] {
    type T = T;
    type AdjacentPairs = [(T, T); 5];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8] => [
                (self_0, self_1),
                (self_2, self_3),
                (self_4, self_5),
                (self_6, self_7),
                (self_8, fallback),
            ],
        }
    }
}
impl UnrollableArraySize<10> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 10] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        [x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 10], mut f: F) -> [U; 10] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9] => [
                f(arr_0),
                f(arr_1),
                f(arr_2),
                f(arr_3),
                f(arr_4),
                f(arr_5),
                f(arr_6),
                f(arr_7),
                f(arr_8),
                f(arr_9),
            ],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 10],
        mut f: F,
    ) -> Result<[U; 10], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9] => Ok([
                f(arr_0)?,
                f(arr_1)?,
                f(arr_2)?,
                f(arr_3)?,
                f(arr_4)?,
                f(arr_5)?,
                f(arr_6)?,
                f(arr_7)?,
                f(arr_8)?,
                f(arr_9)?,
            ]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 10]) -> [(usize, T); 10] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9] => [
                (0, arr_0),
                (1, arr_1),
                (2, arr_2),
                (3, arr_3),
                (4, arr_4),
                (5, arr_5),
                (6, arr_6),
                (7, arr_7),
                (8, arr_8),
                (9, arr_9),
            ],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 10], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 10], arr2: [T2; 10]) -> [(T1, T2); 10] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 10]) -> [&T; 10] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9] => [
                arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9,
            ],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 10]) -> [&mut T; 10] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9] => [
                arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9,
            ],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 10] {
    type T = T;
    type AdjacentPairs = [(T, T); 5];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9] => [
                (self_0, self_1),
                (self_2, self_3),
                (self_4, self_5),
                (self_6, self_7),
                (self_8, self_9),
            ],
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 10] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9] => [
                (self_0, self_1),
                (self_2, self_3),
                (self_4, self_5),
                (self_6, self_7),
                (self_8, self_9),
            ],
        }
    }
}
impl UnrollableArraySize<11> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 11] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        [x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 11], mut f: F) -> [U; 11] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10] => [
                f(arr_0),
                f(arr_1),
                f(arr_2),
                f(arr_3),
                f(arr_4),
                f(arr_5),
                f(arr_6),
                f(arr_7),
                f(arr_8),
                f(arr_9),
                f(arr_10),
            ],
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 11],
        mut f: F,
    ) -> Result<[U; 11], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10] => Ok([
                f(arr_0)?,
                f(arr_1)?,
                f(arr_2)?,
                f(arr_3)?,
                f(arr_4)?,
                f(arr_5)?,
                f(arr_6)?,
                f(arr_7)?,
                f(arr_8)?,
                f(arr_9)?,
                f(arr_10)?,
            ]),
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 11]) -> [(usize, T); 11] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10] => [
                (0, arr_0),
                (1, arr_1),
                (2, arr_2),
                (3, arr_3),
                (4, arr_4),
                (5, arr_5),
                (6, arr_6),
                (7, arr_7),
                (8, arr_8),
                (9, arr_9),
                (10, arr_10),
            ],
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 11], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10] => {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 11], arr2: [T2; 11]) -> [(T1, T2); 11] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 11]) -> [&T; 11] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10] => [
                arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
            ],
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 11]) -> [&mut T; 11] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10] => [
                arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
            ],
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 11] {
    type T = T;
    type AdjacentPairs = [(T, T); 6];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<12> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 12] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        [x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 12], mut f: F) -> [U; 12] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 12],
        mut f: F,
    ) -> Result<[U; 12], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 12]) -> [(usize, T); 12] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 12], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 12], arr2: [T2; 12]) -> [(T1, T2); 12] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 12]) -> [&T; 12] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 12]) -> [&mut T; 12] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 12] {
    type T = T;
    type AdjacentPairs = [(T, T); 6];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 12] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                ]
            }
        }
    }
}
impl UnrollableArraySize<13> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 13] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 13], mut f: F) -> [U; 13] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 13],
        mut f: F,
    ) -> Result<[U; 13], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 13]) -> [(usize, T); 13] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 13], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 13], arr2: [T2; 13]) -> [(T1, T2); 13] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 13]) -> [&T; 13] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 13]) -> [&mut T; 13] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 13] {
    type T = T;
    type AdjacentPairs = [(T, T); 7];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<14> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 14] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 14], mut f: F) -> [U; 14] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 14],
        mut f: F,
    ) -> Result<[U; 14], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 14]) -> [(usize, T); 14] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 14], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 14], arr2: [T2; 14]) -> [(T1, T2); 14] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 14]) -> [&T; 14] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 14]) -> [&mut T; 14] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 14] {
    type T = T;
    type AdjacentPairs = [(T, T); 7];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 14] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                ]
            }
        }
    }
}
impl UnrollableArraySize<15> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 15] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 15], mut f: F) -> [U; 15] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 15],
        mut f: F,
    ) -> Result<[U; 15], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 15]) -> [(usize, T); 15] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 15], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 15], arr2: [T2; 15]) -> [(T1, T2); 15] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 15]) -> [&T; 15] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 15]) -> [&mut T; 15] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 15] {
    type T = T;
    type AdjacentPairs = [(T, T); 8];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<16> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 16] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 16], mut f: F) -> [U; 16] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 16],
        mut f: F,
    ) -> Result<[U; 16], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 16]) -> [(usize, T); 16] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 16], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 16], arr2: [T2; 16]) -> [(T1, T2); 16] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 16]) -> [&T; 16] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 16]) -> [&mut T; 16] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 16] {
    type T = T;
    type AdjacentPairs = [(T, T); 8];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 16] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                ]
            }
        }
    }
}
impl UnrollableArraySize<17> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 17] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 17], mut f: F) -> [U; 17] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 17],
        mut f: F,
    ) -> Result<[U; 17], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 17]) -> [(usize, T); 17] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 17], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 17], arr2: [T2; 17]) -> [(T1, T2); 17] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 17]) -> [&T; 17] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 17]) -> [&mut T; 17] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 17] {
    type T = T;
    type AdjacentPairs = [(T, T); 9];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<18> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 18] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 18], mut f: F) -> [U; 18] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 18],
        mut f: F,
    ) -> Result<[U; 18], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 18]) -> [(usize, T); 18] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 18], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 18], arr2: [T2; 18]) -> [(T1, T2); 18] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 18]) -> [&T; 18] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 18]) -> [&mut T; 18] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 18] {
    type T = T;
    type AdjacentPairs = [(T, T); 9];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 18] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                ]
            }
        }
    }
}
impl UnrollableArraySize<19> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 19] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 19], mut f: F) -> [U; 19] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 19],
        mut f: F,
    ) -> Result<[U; 19], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 19]) -> [(usize, T); 19] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 19], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 19], arr2: [T2; 19]) -> [(T1, T2); 19] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 19]) -> [&T; 19] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 19]) -> [&mut T; 19] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 19] {
    type T = T;
    type AdjacentPairs = [(T, T); 10];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<20> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 20] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 20], mut f: F) -> [U; 20] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 20],
        mut f: F,
    ) -> Result<[U; 20], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 20]) -> [(usize, T); 20] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 20], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 20], arr2: [T2; 20]) -> [(T1, T2); 20] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 20]) -> [&T; 20] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 20]) -> [&mut T; 20] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 20] {
    type T = T;
    type AdjacentPairs = [(T, T); 10];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 20] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                ]
            }
        }
    }
}
impl UnrollableArraySize<21> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 21] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 21], mut f: F) -> [U; 21] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 21],
        mut f: F,
    ) -> Result<[U; 21], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 21]) -> [(usize, T); 21] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 21], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 21], arr2: [T2; 21]) -> [(T1, T2); 21] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 21]) -> [&T; 21] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 21]) -> [&mut T; 21] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 21] {
    type T = T;
    type AdjacentPairs = [(T, T); 11];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<22> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 22] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 22], mut f: F) -> [U; 22] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 22],
        mut f: F,
    ) -> Result<[U; 22], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 22]) -> [(usize, T); 22] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 22], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 22], arr2: [T2; 22]) -> [(T1, T2); 22] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 22]) -> [&T; 22] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 22]) -> [&mut T; 22] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 22] {
    type T = T;
    type AdjacentPairs = [(T, T); 11];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 22] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                ]
            }
        }
    }
}
impl UnrollableArraySize<23> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 23] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 23], mut f: F) -> [U; 23] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 23],
        mut f: F,
    ) -> Result<[U; 23], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 23]) -> [(usize, T); 23] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 23], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 23], arr2: [T2; 23]) -> [(T1, T2); 23] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 23]) -> [&T; 23] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 23]) -> [&mut T; 23] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 23] {
    type T = T;
    type AdjacentPairs = [(T, T); 12];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<24> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 24] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 24], mut f: F) -> [U; 24] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 24],
        mut f: F,
    ) -> Result<[U; 24], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 24]) -> [(usize, T); 24] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 24], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 24], arr2: [T2; 24]) -> [(T1, T2); 24] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 24]) -> [&T; 24] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 24]) -> [&mut T; 24] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 24] {
    type T = T;
    type AdjacentPairs = [(T, T); 12];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 24] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                ]
            }
        }
    }
}
impl UnrollableArraySize<25> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 25] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 25], mut f: F) -> [U; 25] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 25],
        mut f: F,
    ) -> Result<[U; 25], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 25]) -> [(usize, T); 25] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 25], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 25], arr2: [T2; 25]) -> [(T1, T2); 25] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 25]) -> [&T; 25] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 25]) -> [&mut T; 25] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 25] {
    type T = T;
    type AdjacentPairs = [(T, T); 13];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<26> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 26] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 26], mut f: F) -> [U; 26] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 26],
        mut f: F,
    ) -> Result<[U; 26], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 26]) -> [(usize, T); 26] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 26], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 26], arr2: [T2; 26]) -> [(T1, T2); 26] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 26]) -> [&T; 26] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 26]) -> [&mut T; 26] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 26] {
    type T = T;
    type AdjacentPairs = [(T, T); 13];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 26] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                ]
            }
        }
    }
}
impl UnrollableArraySize<27> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 27] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        let x_26 = f(26);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 27], mut f: F) -> [U; 27] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                    f(arr_26),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 27],
        mut f: F,
    ) -> Result<[U; 27], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                    f(arr_26)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 27]) -> [(usize, T); 27] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                    (26, arr_26),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 27], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
                acu = f(acu, arr_26);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 27], arr2: [T2; 27]) -> [(T1, T2); 27] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25, arr1_26] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25, arr2_26] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                            (arr1_26, arr2_26),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 27]) -> [&T; 27] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 27]) -> [&mut T; 27] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 27] {
    type T = T;
    type AdjacentPairs = [(T, T); 14];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<28> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 28] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        let x_26 = f(26);
        let x_27 = f(27);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 28], mut f: F) -> [U; 28] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                    f(arr_26),
                    f(arr_27),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 28],
        mut f: F,
    ) -> Result<[U; 28], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                    f(arr_26)?,
                    f(arr_27)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 28]) -> [(usize, T); 28] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                    (26, arr_26),
                    (27, arr_27),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 28], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
                acu = f(acu, arr_26);
                acu = f(acu, arr_27);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 28], arr2: [T2; 28]) -> [(T1, T2); 28] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25, arr1_26, arr1_27] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25, arr2_26, arr2_27] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                            (arr1_26, arr2_26),
                            (arr1_27, arr2_27),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 28]) -> [&T; 28] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 28]) -> [&mut T; 28] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 28] {
    type T = T;
    type AdjacentPairs = [(T, T); 14];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 28] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                ]
            }
        }
    }
}
impl UnrollableArraySize<29> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 29] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        let x_26 = f(26);
        let x_27 = f(27);
        let x_28 = f(28);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 29], mut f: F) -> [U; 29] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                    f(arr_26),
                    f(arr_27),
                    f(arr_28),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 29],
        mut f: F,
    ) -> Result<[U; 29], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                    f(arr_26)?,
                    f(arr_27)?,
                    f(arr_28)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 29]) -> [(usize, T); 29] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                    (26, arr_26),
                    (27, arr_27),
                    (28, arr_28),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 29], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
                acu = f(acu, arr_26);
                acu = f(acu, arr_27);
                acu = f(acu, arr_28);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 29], arr2: [T2; 29]) -> [(T1, T2); 29] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25, arr1_26, arr1_27, arr1_28] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25, arr2_26, arr2_27, arr2_28] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                            (arr1_26, arr2_26),
                            (arr1_27, arr2_27),
                            (arr1_28, arr2_28),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 29]) -> [&T; 29] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 29]) -> [&mut T; 29] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 29] {
    type T = T;
    type AdjacentPairs = [(T, T); 15];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27, self_28] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                    (self_28, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<30> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 30] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        let x_26 = f(26);
        let x_27 = f(27);
        let x_28 = f(28);
        let x_29 = f(29);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 30], mut f: F) -> [U; 30] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                    f(arr_26),
                    f(arr_27),
                    f(arr_28),
                    f(arr_29),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 30],
        mut f: F,
    ) -> Result<[U; 30], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                    f(arr_26)?,
                    f(arr_27)?,
                    f(arr_28)?,
                    f(arr_29)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 30]) -> [(usize, T); 30] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                    (26, arr_26),
                    (27, arr_27),
                    (28, arr_28),
                    (29, arr_29),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 30], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
                acu = f(acu, arr_26);
                acu = f(acu, arr_27);
                acu = f(acu, arr_28);
                acu = f(acu, arr_29);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 30], arr2: [T2; 30]) -> [(T1, T2); 30] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25, arr1_26, arr1_27, arr1_28, arr1_29] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25, arr2_26, arr2_27, arr2_28, arr2_29] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                            (arr1_26, arr2_26),
                            (arr1_27, arr2_27),
                            (arr1_28, arr2_28),
                            (arr1_29, arr2_29),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 30]) -> [&T; 30] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 30]) -> [&mut T; 30] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 30] {
    type T = T;
    type AdjacentPairs = [(T, T); 15];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27, self_28, self_29] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                    (self_28, self_29),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 30] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27, self_28, self_29] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                    (self_28, self_29),
                ]
            }
        }
    }
}
impl UnrollableArraySize<31> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 31] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        let x_26 = f(26);
        let x_27 = f(27);
        let x_28 = f(28);
        let x_29 = f(29);
        let x_30 = f(30);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29,
            x_30,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 31], mut f: F) -> [U; 31] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                    f(arr_26),
                    f(arr_27),
                    f(arr_28),
                    f(arr_29),
                    f(arr_30),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 31],
        mut f: F,
    ) -> Result<[U; 31], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                    f(arr_26)?,
                    f(arr_27)?,
                    f(arr_28)?,
                    f(arr_29)?,
                    f(arr_30)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 31]) -> [(usize, T); 31] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                    (26, arr_26),
                    (27, arr_27),
                    (28, arr_28),
                    (29, arr_29),
                    (30, arr_30),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 31], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
                acu = f(acu, arr_26);
                acu = f(acu, arr_27);
                acu = f(acu, arr_28);
                acu = f(acu, arr_29);
                acu = f(acu, arr_30);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 31], arr2: [T2; 31]) -> [(T1, T2); 31] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25, arr1_26, arr1_27, arr1_28, arr1_29, arr1_30] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25, arr2_26, arr2_27, arr2_28, arr2_29, arr2_30] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                            (arr1_26, arr2_26),
                            (arr1_27, arr2_27),
                            (arr1_28, arr2_28),
                            (arr1_29, arr2_29),
                            (arr1_30, arr2_30),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 31]) -> [&T; 31] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 31]) -> [&mut T; 31] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 31] {
    type T = T;
    type AdjacentPairs = [(T, T); 16];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27, self_28, self_29, self_30] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                    (self_28, self_29),
                    (self_30, fallback),
                ]
            }
        }
    }
}
impl UnrollableArraySize<32> for ArrayUnrolledOps {
    #[inline(always)]
    fn array_generate<T, F: FnMut(usize) -> T>(mut f: F) -> [T; 32] {
        let x_0 = f(0);
        let x_1 = f(1);
        let x_2 = f(2);
        let x_3 = f(3);
        let x_4 = f(4);
        let x_5 = f(5);
        let x_6 = f(6);
        let x_7 = f(7);
        let x_8 = f(8);
        let x_9 = f(9);
        let x_10 = f(10);
        let x_11 = f(11);
        let x_12 = f(12);
        let x_13 = f(13);
        let x_14 = f(14);
        let x_15 = f(15);
        let x_16 = f(16);
        let x_17 = f(17);
        let x_18 = f(18);
        let x_19 = f(19);
        let x_20 = f(20);
        let x_21 = f(21);
        let x_22 = f(22);
        let x_23 = f(23);
        let x_24 = f(24);
        let x_25 = f(25);
        let x_26 = f(26);
        let x_27 = f(27);
        let x_28 = f(28);
        let x_29 = f(29);
        let x_30 = f(30);
        let x_31 = f(31);
        [
            x_0, x_1, x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_10, x_11, x_12, x_13, x_14, x_15,
            x_16, x_17, x_18, x_19, x_20, x_21, x_22, x_23, x_24, x_25, x_26, x_27, x_28, x_29,
            x_30, x_31,
        ]
    }
    #[inline(always)]
    fn array_map<T, U, F: FnMut(T) -> U>(arr: [T; 32], mut f: F) -> [U; 32] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30, arr_31] => {
                [
                    f(arr_0),
                    f(arr_1),
                    f(arr_2),
                    f(arr_3),
                    f(arr_4),
                    f(arr_5),
                    f(arr_6),
                    f(arr_7),
                    f(arr_8),
                    f(arr_9),
                    f(arr_10),
                    f(arr_11),
                    f(arr_12),
                    f(arr_13),
                    f(arr_14),
                    f(arr_15),
                    f(arr_16),
                    f(arr_17),
                    f(arr_18),
                    f(arr_19),
                    f(arr_20),
                    f(arr_21),
                    f(arr_22),
                    f(arr_23),
                    f(arr_24),
                    f(arr_25),
                    f(arr_26),
                    f(arr_27),
                    f(arr_28),
                    f(arr_29),
                    f(arr_30),
                    f(arr_31),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_map_result<T, U, E, F: FnMut(T) -> Result<U, E>>(
        arr: [T; 32],
        mut f: F,
    ) -> Result<[U; 32], E> {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30, arr_31] => {
                Ok([
                    f(arr_0)?,
                    f(arr_1)?,
                    f(arr_2)?,
                    f(arr_3)?,
                    f(arr_4)?,
                    f(arr_5)?,
                    f(arr_6)?,
                    f(arr_7)?,
                    f(arr_8)?,
                    f(arr_9)?,
                    f(arr_10)?,
                    f(arr_11)?,
                    f(arr_12)?,
                    f(arr_13)?,
                    f(arr_14)?,
                    f(arr_15)?,
                    f(arr_16)?,
                    f(arr_17)?,
                    f(arr_18)?,
                    f(arr_19)?,
                    f(arr_20)?,
                    f(arr_21)?,
                    f(arr_22)?,
                    f(arr_23)?,
                    f(arr_24)?,
                    f(arr_25)?,
                    f(arr_26)?,
                    f(arr_27)?,
                    f(arr_28)?,
                    f(arr_29)?,
                    f(arr_30)?,
                    f(arr_31)?,
                ])
            }
        }
    }
    #[inline(always)]
    fn array_enumerate<T>(arr: [T; 32]) -> [(usize, T); 32] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30, arr_31] => {
                [
                    (0, arr_0),
                    (1, arr_1),
                    (2, arr_2),
                    (3, arr_3),
                    (4, arr_4),
                    (5, arr_5),
                    (6, arr_6),
                    (7, arr_7),
                    (8, arr_8),
                    (9, arr_9),
                    (10, arr_10),
                    (11, arr_11),
                    (12, arr_12),
                    (13, arr_13),
                    (14, arr_14),
                    (15, arr_15),
                    (16, arr_16),
                    (17, arr_17),
                    (18, arr_18),
                    (19, arr_19),
                    (20, arr_20),
                    (21, arr_21),
                    (22, arr_22),
                    (23, arr_23),
                    (24, arr_24),
                    (25, arr_25),
                    (26, arr_26),
                    (27, arr_27),
                    (28, arr_28),
                    (29, arr_29),
                    (30, arr_30),
                    (31, arr_31),
                ]
            }
        }
    }
    #[inline(always)]
    fn array_fold<T, U, F: FnMut(U, T) -> U>(arr: [T; 32], init: U, mut f: F) -> U {
        let mut acu = init;
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30, arr_31] =>
            {
                acu = f(acu, arr_0);
                acu = f(acu, arr_1);
                acu = f(acu, arr_2);
                acu = f(acu, arr_3);
                acu = f(acu, arr_4);
                acu = f(acu, arr_5);
                acu = f(acu, arr_6);
                acu = f(acu, arr_7);
                acu = f(acu, arr_8);
                acu = f(acu, arr_9);
                acu = f(acu, arr_10);
                acu = f(acu, arr_11);
                acu = f(acu, arr_12);
                acu = f(acu, arr_13);
                acu = f(acu, arr_14);
                acu = f(acu, arr_15);
                acu = f(acu, arr_16);
                acu = f(acu, arr_17);
                acu = f(acu, arr_18);
                acu = f(acu, arr_19);
                acu = f(acu, arr_20);
                acu = f(acu, arr_21);
                acu = f(acu, arr_22);
                acu = f(acu, arr_23);
                acu = f(acu, arr_24);
                acu = f(acu, arr_25);
                acu = f(acu, arr_26);
                acu = f(acu, arr_27);
                acu = f(acu, arr_28);
                acu = f(acu, arr_29);
                acu = f(acu, arr_30);
                acu = f(acu, arr_31);
            }
        }
        acu
    }
    #[inline(always)]
    fn array_zip<T1, T2>(arr1: [T1; 32], arr2: [T2; 32]) -> [(T1, T2); 32] {
        match arr1 {
            [arr1_0, arr1_1, arr1_2, arr1_3, arr1_4, arr1_5, arr1_6, arr1_7, arr1_8, arr1_9, arr1_10, arr1_11, arr1_12, arr1_13, arr1_14, arr1_15, arr1_16, arr1_17, arr1_18, arr1_19, arr1_20, arr1_21, arr1_22, arr1_23, arr1_24, arr1_25, arr1_26, arr1_27, arr1_28, arr1_29, arr1_30, arr1_31] => {
                match arr2 {
                    [arr2_0, arr2_1, arr2_2, arr2_3, arr2_4, arr2_5, arr2_6, arr2_7, arr2_8, arr2_9, arr2_10, arr2_11, arr2_12, arr2_13, arr2_14, arr2_15, arr2_16, arr2_17, arr2_18, arr2_19, arr2_20, arr2_21, arr2_22, arr2_23, arr2_24, arr2_25, arr2_26, arr2_27, arr2_28, arr2_29, arr2_30, arr2_31] => {
                        [
                            (arr1_0, arr2_0),
                            (arr1_1, arr2_1),
                            (arr1_2, arr2_2),
                            (arr1_3, arr2_3),
                            (arr1_4, arr2_4),
                            (arr1_5, arr2_5),
                            (arr1_6, arr2_6),
                            (arr1_7, arr2_7),
                            (arr1_8, arr2_8),
                            (arr1_9, arr2_9),
                            (arr1_10, arr2_10),
                            (arr1_11, arr2_11),
                            (arr1_12, arr2_12),
                            (arr1_13, arr2_13),
                            (arr1_14, arr2_14),
                            (arr1_15, arr2_15),
                            (arr1_16, arr2_16),
                            (arr1_17, arr2_17),
                            (arr1_18, arr2_18),
                            (arr1_19, arr2_19),
                            (arr1_20, arr2_20),
                            (arr1_21, arr2_21),
                            (arr1_22, arr2_22),
                            (arr1_23, arr2_23),
                            (arr1_24, arr2_24),
                            (arr1_25, arr2_25),
                            (arr1_26, arr2_26),
                            (arr1_27, arr2_27),
                            (arr1_28, arr2_28),
                            (arr1_29, arr2_29),
                            (arr1_30, arr2_30),
                            (arr1_31, arr2_31),
                        ]
                    }
                }
            }
        }
    }
    #[inline(always)]
    fn array_as_ref<T>(arr: &[T; 32]) -> [&T; 32] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30, arr_31] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30,
                    arr_31,
                ]
            }
        }
    }
    #[inline(always)]
    fn array_as_mut<T>(arr: &mut [T; 32]) -> [&mut T; 32] {
        match arr {
            [arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10, arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20, arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30, arr_31] => {
                [
                    arr_0, arr_1, arr_2, arr_3, arr_4, arr_5, arr_6, arr_7, arr_8, arr_9, arr_10,
                    arr_11, arr_12, arr_13, arr_14, arr_15, arr_16, arr_17, arr_18, arr_19, arr_20,
                    arr_21, arr_22, arr_23, arr_24, arr_25, arr_26, arr_27, arr_28, arr_29, arr_30,
                    arr_31,
                ]
            }
        }
    }
}
impl<T> ArrayAdjacentPairs for [T; 32] {
    type T = T;
    type AdjacentPairs = [(T, T); 16];
    #[inline(always)]
    #[allow(unused_variables)]
    fn pair_adjacent_maybe_odd(self, fallback: T) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27, self_28, self_29, self_30, self_31] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                    (self_28, self_29),
                    (self_30, self_31),
                ]
            }
        }
    }
}
impl<T> EvenArrayAdjacentPairs for [T; 32] {
    #[inline(always)]
    fn pair_adjacent(self) -> Self::AdjacentPairs {
        match self {
            [self_0, self_1, self_2, self_3, self_4, self_5, self_6, self_7, self_8, self_9, self_10, self_11, self_12, self_13, self_14, self_15, self_16, self_17, self_18, self_19, self_20, self_21, self_22, self_23, self_24, self_25, self_26, self_27, self_28, self_29, self_30, self_31] => {
                [
                    (self_0, self_1),
                    (self_2, self_3),
                    (self_4, self_5),
                    (self_6, self_7),
                    (self_8, self_9),
                    (self_10, self_11),
                    (self_12, self_13),
                    (self_14, self_15),
                    (self_16, self_17),
                    (self_18, self_19),
                    (self_20, self_21),
                    (self_22, self_23),
                    (self_24, self_25),
                    (self_26, self_27),
                    (self_28, self_29),
                    (self_30, self_31),
                ]
            }
        }
    }
}
