// @generated
// rustfmt-format_generated_files: false
// This file was auto-generated by generate.py DO NOT MODIFY
#![allow(unused_braces)]
use crate::array_utils::*;
use crate::SimdBase;
use std::ops::*;
#[doc = "We need to use a macro to explicitly match every possible immediate value, and then dispatch to\na block which has a const generic value for the intrinsic immediate. The inputs to our\nfunctions need to be manipulated before they passed to the raw intrinsic.\nIt used to be possible to directly manipulate the const before passing it to the intrinsic.\nHowever, https://git.io/JsukV broke compatibility with stable, so we need to do this instead."]
#[allow(unused_macros)]
macro_rules! constify_imm { ($func:path => ( $($normal_args:expr,)* @@ [0..256] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 0 => $func($($normal_args,)* 0), 1 => $func($($normal_args,)* 1), 2 => $func($($normal_args,)* 2), 3 => $func($($normal_args,)* 3), 4 => $func($($normal_args,)* 4), 5 => $func($($normal_args,)* 5), 6 => $func($($normal_args,)* 6), 7 => $func($($normal_args,)* 7), 8 => $func($($normal_args,)* 8), 9 => $func($($normal_args,)* 9), 10 => $func($($normal_args,)* 10), 11 => $func($($normal_args,)* 11), 12 => $func($($normal_args,)* 12), 13 => $func($($normal_args,)* 13), 14 => $func($($normal_args,)* 14), 15 => $func($($normal_args,)* 15), 16 => $func($($normal_args,)* 16), 17 => $func($($normal_args,)* 17), 18 => $func($($normal_args,)* 18), 19 => $func($($normal_args,)* 19), 20 => $func($($normal_args,)* 20), 21 => $func($($normal_args,)* 21), 22 => $func($($normal_args,)* 22), 23 => $func($($normal_args,)* 23), 24 => $func($($normal_args,)* 24), 25 => $func($($normal_args,)* 25), 26 => $func($($normal_args,)* 26), 27 => $func($($normal_args,)* 27), 28 => $func($($normal_args,)* 28), 29 => $func($($normal_args,)* 29), 30 => $func($($normal_args,)* 30), 31 => $func($($normal_args,)* 31), 32 => $func($($normal_args,)* 32), 33 => $func($($normal_args,)* 33), 34 => $func($($normal_args,)* 34), 35 => $func($($normal_args,)* 35), 36 => $func($($normal_args,)* 36), 37 => $func($($normal_args,)* 37), 38 => $func($($normal_args,)* 38), 39 => $func($($normal_args,)* 39), 40 => $func($($normal_args,)* 40), 41 => $func($($normal_args,)* 41), 42 => $func($($normal_args,)* 42), 43 => $func($($normal_args,)* 43), 44 => $func($($normal_args,)* 44), 45 => $func($($normal_args,)* 45), 46 => $func($($normal_args,)* 46), 47 => $func($($normal_args,)* 47), 48 => $func($($normal_args,)* 48), 49 => $func($($normal_args,)* 49), 50 => $func($($normal_args,)* 50), 51 => $func($($normal_args,)* 51), 52 => $func($($normal_args,)* 52), 53 => $func($($normal_args,)* 53), 54 => $func($($normal_args,)* 54), 55 => $func($($normal_args,)* 55), 56 => $func($($normal_args,)* 56), 57 => $func($($normal_args,)* 57), 58 => $func($($normal_args,)* 58), 59 => $func($($normal_args,)* 59), 60 => $func($($normal_args,)* 60), 61 => $func($($normal_args,)* 61), 62 => $func($($normal_args,)* 62), 63 => $func($($normal_args,)* 63), 64 => $func($($normal_args,)* 64), 65 => $func($($normal_args,)* 65), 66 => $func($($normal_args,)* 66), 67 => $func($($normal_args,)* 67), 68 => $func($($normal_args,)* 68), 69 => $func($($normal_args,)* 69), 70 => $func($($normal_args,)* 70), 71 => $func($($normal_args,)* 71), 72 => $func($($normal_args,)* 72), 73 => $func($($normal_args,)* 73), 74 => $func($($normal_args,)* 74), 75 => $func($($normal_args,)* 75), 76 => $func($($normal_args,)* 76), 77 => $func($($normal_args,)* 77), 78 => $func($($normal_args,)* 78), 79 => $func($($normal_args,)* 79), 80 => $func($($normal_args,)* 80), 81 => $func($($normal_args,)* 81), 82 => $func($($normal_args,)* 82), 83 => $func($($normal_args,)* 83), 84 => $func($($normal_args,)* 84), 85 => $func($($normal_args,)* 85), 86 => $func($($normal_args,)* 86), 87 => $func($($normal_args,)* 87), 88 => $func($($normal_args,)* 88), 89 => $func($($normal_args,)* 89), 90 => $func($($normal_args,)* 90), 91 => $func($($normal_args,)* 91), 92 => $func($($normal_args,)* 92), 93 => $func($($normal_args,)* 93), 94 => $func($($normal_args,)* 94), 95 => $func($($normal_args,)* 95), 96 => $func($($normal_args,)* 96), 97 => $func($($normal_args,)* 97), 98 => $func($($normal_args,)* 98), 99 => $func($($normal_args,)* 99), 100 => $func($($normal_args,)* 100), 101 => $func($($normal_args,)* 101), 102 => $func($($normal_args,)* 102), 103 => $func($($normal_args,)* 103), 104 => $func($($normal_args,)* 104), 105 => $func($($normal_args,)* 105), 106 => $func($($normal_args,)* 106), 107 => $func($($normal_args,)* 107), 108 => $func($($normal_args,)* 108), 109 => $func($($normal_args,)* 109), 110 => $func($($normal_args,)* 110), 111 => $func($($normal_args,)* 111), 112 => $func($($normal_args,)* 112), 113 => $func($($normal_args,)* 113), 114 => $func($($normal_args,)* 114), 115 => $func($($normal_args,)* 115), 116 => $func($($normal_args,)* 116), 117 => $func($($normal_args,)* 117), 118 => $func($($normal_args,)* 118), 119 => $func($($normal_args,)* 119), 120 => $func($($normal_args,)* 120), 121 => $func($($normal_args,)* 121), 122 => $func($($normal_args,)* 122), 123 => $func($($normal_args,)* 123), 124 => $func($($normal_args,)* 124), 125 => $func($($normal_args,)* 125), 126 => $func($($normal_args,)* 126), 127 => $func($($normal_args,)* 127), 128 => $func($($normal_args,)* 128), 129 => $func($($normal_args,)* 129), 130 => $func($($normal_args,)* 130), 131 => $func($($normal_args,)* 131), 132 => $func($($normal_args,)* 132), 133 => $func($($normal_args,)* 133), 134 => $func($($normal_args,)* 134), 135 => $func($($normal_args,)* 135), 136 => $func($($normal_args,)* 136), 137 => $func($($normal_args,)* 137), 138 => $func($($normal_args,)* 138), 139 => $func($($normal_args,)* 139), 140 => $func($($normal_args,)* 140), 141 => $func($($normal_args,)* 141), 142 => $func($($normal_args,)* 142), 143 => $func($($normal_args,)* 143), 144 => $func($($normal_args,)* 144), 145 => $func($($normal_args,)* 145), 146 => $func($($normal_args,)* 146), 147 => $func($($normal_args,)* 147), 148 => $func($($normal_args,)* 148), 149 => $func($($normal_args,)* 149), 150 => $func($($normal_args,)* 150), 151 => $func($($normal_args,)* 151), 152 => $func($($normal_args,)* 152), 153 => $func($($normal_args,)* 153), 154 => $func($($normal_args,)* 154), 155 => $func($($normal_args,)* 155), 156 => $func($($normal_args,)* 156), 157 => $func($($normal_args,)* 157), 158 => $func($($normal_args,)* 158), 159 => $func($($normal_args,)* 159), 160 => $func($($normal_args,)* 160), 161 => $func($($normal_args,)* 161), 162 => $func($($normal_args,)* 162), 163 => $func($($normal_args,)* 163), 164 => $func($($normal_args,)* 164), 165 => $func($($normal_args,)* 165), 166 => $func($($normal_args,)* 166), 167 => $func($($normal_args,)* 167), 168 => $func($($normal_args,)* 168), 169 => $func($($normal_args,)* 169), 170 => $func($($normal_args,)* 170), 171 => $func($($normal_args,)* 171), 172 => $func($($normal_args,)* 172), 173 => $func($($normal_args,)* 173), 174 => $func($($normal_args,)* 174), 175 => $func($($normal_args,)* 175), 176 => $func($($normal_args,)* 176), 177 => $func($($normal_args,)* 177), 178 => $func($($normal_args,)* 178), 179 => $func($($normal_args,)* 179), 180 => $func($($normal_args,)* 180), 181 => $func($($normal_args,)* 181), 182 => $func($($normal_args,)* 182), 183 => $func($($normal_args,)* 183), 184 => $func($($normal_args,)* 184), 185 => $func($($normal_args,)* 185), 186 => $func($($normal_args,)* 186), 187 => $func($($normal_args,)* 187), 188 => $func($($normal_args,)* 188), 189 => $func($($normal_args,)* 189), 190 => $func($($normal_args,)* 190), 191 => $func($($normal_args,)* 191), 192 => $func($($normal_args,)* 192), 193 => $func($($normal_args,)* 193), 194 => $func($($normal_args,)* 194), 195 => $func($($normal_args,)* 195), 196 => $func($($normal_args,)* 196), 197 => $func($($normal_args,)* 197), 198 => $func($($normal_args,)* 198), 199 => $func($($normal_args,)* 199), 200 => $func($($normal_args,)* 200), 201 => $func($($normal_args,)* 201), 202 => $func($($normal_args,)* 202), 203 => $func($($normal_args,)* 203), 204 => $func($($normal_args,)* 204), 205 => $func($($normal_args,)* 205), 206 => $func($($normal_args,)* 206), 207 => $func($($normal_args,)* 207), 208 => $func($($normal_args,)* 208), 209 => $func($($normal_args,)* 209), 210 => $func($($normal_args,)* 210), 211 => $func($($normal_args,)* 211), 212 => $func($($normal_args,)* 212), 213 => $func($($normal_args,)* 213), 214 => $func($($normal_args,)* 214), 215 => $func($($normal_args,)* 215), 216 => $func($($normal_args,)* 216), 217 => $func($($normal_args,)* 217), 218 => $func($($normal_args,)* 218), 219 => $func($($normal_args,)* 219), 220 => $func($($normal_args,)* 220), 221 => $func($($normal_args,)* 221), 222 => $func($($normal_args,)* 222), 223 => $func($($normal_args,)* 223), 224 => $func($($normal_args,)* 224), 225 => $func($($normal_args,)* 225), 226 => $func($($normal_args,)* 226), 227 => $func($($normal_args,)* 227), 228 => $func($($normal_args,)* 228), 229 => $func($($normal_args,)* 229), 230 => $func($($normal_args,)* 230), 231 => $func($($normal_args,)* 231), 232 => $func($($normal_args,)* 232), 233 => $func($($normal_args,)* 233), 234 => $func($($normal_args,)* 234), 235 => $func($($normal_args,)* 235), 236 => $func($($normal_args,)* 236), 237 => $func($($normal_args,)* 237), 238 => $func($($normal_args,)* 238), 239 => $func($($normal_args,)* 239), 240 => $func($($normal_args,)* 240), 241 => $func($($normal_args,)* 241), 242 => $func($($normal_args,)* 242), 243 => $func($($normal_args,)* 243), 244 => $func($($normal_args,)* 244), 245 => $func($($normal_args,)* 245), 246 => $func($($normal_args,)* 246), 247 => $func($($normal_args,)* 247), 248 => $func($($normal_args,)* 248), 249 => $func($($normal_args,)* 249), 250 => $func($($normal_args,)* 250), 251 => $func($($normal_args,)* 251), 252 => $func($($normal_args,)* 252), 253 => $func($($normal_args,)* 253), 254 => $func($($normal_args,)* 254), 255 => $func($($normal_args,)* 255), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: 0..256", $imm_arg), } }; ($func:path => ( $($normal_args:expr,)* @@ [0..32] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 0 => $func($($normal_args,)* 0), 1 => $func($($normal_args,)* 1), 2 => $func($($normal_args,)* 2), 3 => $func($($normal_args,)* 3), 4 => $func($($normal_args,)* 4), 5 => $func($($normal_args,)* 5), 6 => $func($($normal_args,)* 6), 7 => $func($($normal_args,)* 7), 8 => $func($($normal_args,)* 8), 9 => $func($($normal_args,)* 9), 10 => $func($($normal_args,)* 10), 11 => $func($($normal_args,)* 11), 12 => $func($($normal_args,)* 12), 13 => $func($($normal_args,)* 13), 14 => $func($($normal_args,)* 14), 15 => $func($($normal_args,)* 15), 16 => $func($($normal_args,)* 16), 17 => $func($($normal_args,)* 17), 18 => $func($($normal_args,)* 18), 19 => $func($($normal_args,)* 19), 20 => $func($($normal_args,)* 20), 21 => $func($($normal_args,)* 21), 22 => $func($($normal_args,)* 22), 23 => $func($($normal_args,)* 23), 24 => $func($($normal_args,)* 24), 25 => $func($($normal_args,)* 25), 26 => $func($($normal_args,)* 26), 27 => $func($($normal_args,)* 27), 28 => $func($($normal_args,)* 28), 29 => $func($($normal_args,)* 29), 30 => $func($($normal_args,)* 30), 31 => $func($($normal_args,)* 31), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: 0..32", $imm_arg), } }; ($func:path => ( $($normal_args:expr,)* @@ [0..16] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 0 => $func($($normal_args,)* 0), 1 => $func($($normal_args,)* 1), 2 => $func($($normal_args,)* 2), 3 => $func($($normal_args,)* 3), 4 => $func($($normal_args,)* 4), 5 => $func($($normal_args,)* 5), 6 => $func($($normal_args,)* 6), 7 => $func($($normal_args,)* 7), 8 => $func($($normal_args,)* 8), 9 => $func($($normal_args,)* 9), 10 => $func($($normal_args,)* 10), 11 => $func($($normal_args,)* 11), 12 => $func($($normal_args,)* 12), 13 => $func($($normal_args,)* 13), 14 => $func($($normal_args,)* 14), 15 => $func($($normal_args,)* 15), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: 0..16", $imm_arg), } }; ($func:path => ( $($normal_args:expr,)* @@ [0..8] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 0 => $func($($normal_args,)* 0), 1 => $func($($normal_args,)* 1), 2 => $func($($normal_args,)* 2), 3 => $func($($normal_args,)* 3), 4 => $func($($normal_args,)* 4), 5 => $func($($normal_args,)* 5), 6 => $func($($normal_args,)* 6), 7 => $func($($normal_args,)* 7), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: 0..8", $imm_arg), } }; ($func:path => ( $($normal_args:expr,)* @@ [0..4] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 0 => $func($($normal_args,)* 0), 1 => $func($($normal_args,)* 1), 2 => $func($($normal_args,)* 2), 3 => $func($($normal_args,)* 3), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: 0..4", $imm_arg), } }; ($func:path => ( $($normal_args:expr,)* @@ [0..2] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 0 => $func($($normal_args,)* 0), 1 => $func($($normal_args,)* 1), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: 0..2", $imm_arg), } }; ($func:path => ( $($normal_args:expr,)* @@ [[1, 2, 4, 8]] $imm_arg:expr )) => { // Hopefully this gets optimized out...
 match $imm_arg { 1 => $func($($normal_args,)* 1), 2 => $func($($normal_args,)* 2), 4 => $func($($normal_args,)* 4), 8 => $func($($normal_args,)* 8), _ => panic!("Invalid immediate: {}. Expected immediate to satisfy: [1, 2, 4, 8]", $imm_arg), } }; }
#[doc = "The backend that is used to evaluate vector operations."]
#[allow(dead_code)]
pub const VECTOR_BACKEND: crate::VectorBackend = { crate::VectorBackend::Scalar };
type I8x16Internal = [i8; 16];
#[doc = "`[i8; 16]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I8x16(I8x16Internal);
unsafe impl bytemuck::Pod for I8x16 {}
unsafe impl bytemuck::Zeroable for I8x16 {}
impl PartialEq for I8x16 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I8x16 {}
impl Default for I8x16 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I8x16 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I8x16 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I8x16({:?})", <[i8; 16]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i8> for I8x16 {}
impl BitXorAssign for I8x16 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n     self.as_array()[8] ^ rhs.as_array()[8],\n     self.as_array()[9] ^ rhs.as_array()[9],\n     self.as_array()[10] ^ rhs.as_array()[10],\n     self.as_array()[11] ^ rhs.as_array()[11],\n     self.as_array()[12] ^ rhs.as_array()[12],\n     self.as_array()[13] ^ rhs.as_array()[13],\n     self.as_array()[14] ^ rhs.as_array()[14],\n     self.as_array()[15] ^ rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
            self.as_array()[8] ^ rhs.as_array()[8],
            self.as_array()[9] ^ rhs.as_array()[9],
            self.as_array()[10] ^ rhs.as_array()[10],
            self.as_array()[11] ^ rhs.as_array()[11],
            self.as_array()[12] ^ rhs.as_array()[12],
            self.as_array()[13] ^ rhs.as_array()[13],
            self.as_array()[14] ^ rhs.as_array()[14],
            self.as_array()[15] ^ rhs.as_array()[15],
        ])
    }
}
impl BitOrAssign for I8x16 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n     self.as_array()[8] | rhs.as_array()[8],\n     self.as_array()[9] | rhs.as_array()[9],\n     self.as_array()[10] | rhs.as_array()[10],\n     self.as_array()[11] | rhs.as_array()[11],\n     self.as_array()[12] | rhs.as_array()[12],\n     self.as_array()[13] | rhs.as_array()[13],\n     self.as_array()[14] | rhs.as_array()[14],\n     self.as_array()[15] | rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
            self.as_array()[8] | rhs.as_array()[8],
            self.as_array()[9] | rhs.as_array()[9],
            self.as_array()[10] | rhs.as_array()[10],
            self.as_array()[11] | rhs.as_array()[11],
            self.as_array()[12] | rhs.as_array()[12],
            self.as_array()[13] | rhs.as_array()[13],
            self.as_array()[14] | rhs.as_array()[14],
            self.as_array()[15] | rhs.as_array()[15],
        ])
    }
}
impl BitAndAssign for I8x16 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n     self.as_array()[8] & rhs.as_array()[8],\n     self.as_array()[9] & rhs.as_array()[9],\n     self.as_array()[10] & rhs.as_array()[10],\n     self.as_array()[11] & rhs.as_array()[11],\n     self.as_array()[12] & rhs.as_array()[12],\n     self.as_array()[13] & rhs.as_array()[13],\n     self.as_array()[14] & rhs.as_array()[14],\n     self.as_array()[15] & rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
            self.as_array()[8] & rhs.as_array()[8],
            self.as_array()[9] & rhs.as_array()[9],
            self.as_array()[10] & rhs.as_array()[10],
            self.as_array()[11] & rhs.as_array()[11],
            self.as_array()[12] & rhs.as_array()[12],
            self.as_array()[13] & rhs.as_array()[13],
            self.as_array()[14] & rhs.as_array()[14],
            self.as_array()[15] & rhs.as_array()[15],
        ])
    }
}
impl AddAssign for I8x16 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_add(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_add(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_add(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_add(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_add(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_add(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_add(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_add(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi8)\n\n\n [`PADDB (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
            self.as_array()[8].wrapping_add(rhs.as_array()[8]),
            self.as_array()[9].wrapping_add(rhs.as_array()[9]),
            self.as_array()[10].wrapping_add(rhs.as_array()[10]),
            self.as_array()[11].wrapping_add(rhs.as_array()[11]),
            self.as_array()[12].wrapping_add(rhs.as_array()[12]),
            self.as_array()[13].wrapping_add(rhs.as_array()[13]),
            self.as_array()[14].wrapping_add(rhs.as_array()[14]),
            self.as_array()[15].wrapping_add(rhs.as_array()[15]),
        ])
    }
}
impl SubAssign for I8x16 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_sub(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_sub(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_sub(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_sub(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_sub(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_sub(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_sub(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_sub(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi8)\n\n\n [`PSUBB (XMM, XMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
            self.as_array()[8].wrapping_sub(rhs.as_array()[8]),
            self.as_array()[9].wrapping_sub(rhs.as_array()[9]),
            self.as_array()[10].wrapping_sub(rhs.as_array()[10]),
            self.as_array()[11].wrapping_sub(rhs.as_array()[11]),
            self.as_array()[12].wrapping_sub(rhs.as_array()[12]),
            self.as_array()[13].wrapping_sub(rhs.as_array()[13]),
            self.as_array()[14].wrapping_sub(rhs.as_array()[14]),
            self.as_array()[15].wrapping_sub(rhs.as_array()[15]),
        ])
    }
}
impl I8x16 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I8x16Internal) -> Self {
        Self(x)
    }
}
impl From<[i8; 16]> for I8x16 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i8; 16]) -> I8x16 {
        I8x16(array)
    }
}
impl From<I8x16> for [i8; 16] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I8x16) -> [i8; 16] {
        vector.0
    }
}
impl From<I16x8> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: I16x8) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: I32x4) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: I64x2) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: U8x16) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: U16x8) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: U32x4) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for I8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of I8x16."]
    #[inline(always)]
    fn from(x: U64x2) -> I8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
} // Static shift
impl ShlAssign<u64> for I8x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x16\n # {\n if amount >= 8 {\n     I8x16::ZERO\n } else {\n     I8x16::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n         self.as_array()[8] << amount,\n         self.as_array()[9] << amount,\n         self.as_array()[10] << amount,\n         self.as_array()[11] << amount,\n         self.as_array()[12] << amount,\n         self.as_array()[13] << amount,\n         self.as_array()[14] << amount,\n         self.as_array()[15] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: u64) -> I8x16 {
        if amount >= 8 {
            I8x16::ZERO
        } else {
            I8x16::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
                self.as_array()[8] << amount,
                self.as_array()[9] << amount,
                self.as_array()[10] << amount,
                self.as_array()[11] << amount,
                self.as_array()[12] << amount,
                self.as_array()[13] << amount,
                self.as_array()[14] << amount,
                self.as_array()[15] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I8x16> for I8x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I8x16) {
        *self = (*self) << amount;
    }
}
impl Shl<I8x16> for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x16  ,\n # )  -> I8x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: I8x16) -> I8x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 || amm < 0 { 0 } else { *x << amm };
        }
        I8x16::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I8x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x16\n # {\n if amount >= 8 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I8x16::from(out)\n } else {\n     I8x16::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n         self.as_array()[8] >> amount,\n         self.as_array()[9] >> amount,\n         self.as_array()[10] >> amount,\n         self.as_array()[11] >> amount,\n         self.as_array()[12] >> amount,\n         self.as_array()[13] >> amount,\n         self.as_array()[14] >> amount,\n         self.as_array()[15] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: u64) -> I8x16 {
        if amount >= 8 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I8x16::from(out)
        } else {
            I8x16::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
                self.as_array()[8] >> amount,
                self.as_array()[9] >> amount,
                self.as_array()[10] >> amount,
                self.as_array()[11] >> amount,
                self.as_array()[12] >> amount,
                self.as_array()[13] >> amount,
                self.as_array()[14] >> amount,
                self.as_array()[15] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I8x16> for I8x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I8x16) {
        *self = (*self) >> amount;
    }
}
impl Shr<I8x16> for I8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x16  ,\n # )  -> I8x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: I8x16) -> I8x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I8x16::from(out)
    }
}
impl SimdBase<i8> for I8x16 {
    type Array = [i8; 16];
    type Signed = I8x16;
    type Unsigned = U8x16;
    const LANES: usize = 16;
    const ZERO: Self = { Self([0; 16]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i8  ,\n # )  -> I8x16\n # {\n let mut out = [0; 16];\n out[0] = scalar;\n I8x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i8) -> I8x16 {
        let mut out = [0; 16];
        out[0] = scalar;
        I8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i8\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i8\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi8)\n\n\n [`PEXTRB (R32, XMM, I8)`](https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html): Extract Byte/Dword/Qword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRB_R32_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRB_R32_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRB_R32_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i8 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i8  ,\n # )  -> I8x16\n # {\n I8x16::from([scalar; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i8) -> I8x16 {
        I8x16::from([scalar; 16])
    }
    type BroadcastLoInput = I8x16;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([vector.as_array()[0]; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastb_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastb_epi8)\n\n\n [`VPBROADCASTB (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I8x16) -> I8x16 {
        I8x16::from([vector.as_array()[0]; 16])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  -1  } else { 0 },\n     if self.as_array()[8] == other.as_array()[8] {  -1  } else { 0 },\n     if self.as_array()[9] == other.as_array()[9] {  -1  } else { 0 },\n     if self.as_array()[10] == other.as_array()[10] {  -1  } else { 0 },\n     if self.as_array()[11] == other.as_array()[11] {  -1  } else { 0 },\n     if self.as_array()[12] == other.as_array()[12] {  -1  } else { 0 },\n     if self.as_array()[13] == other.as_array()[13] {  -1  } else { 0 },\n     if self.as_array()[14] == other.as_array()[14] {  -1  } else { 0 },\n     if self.as_array()[15] == other.as_array()[15] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi8)\n\n\n [`PCMPEQB (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I8x16) -> I8x16 {
        I8x16::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                -1
            } else {
                0
            },
            if self.as_array()[8] == other.as_array()[8] {
                -1
            } else {
                0
            },
            if self.as_array()[9] == other.as_array()[9] {
                -1
            } else {
                0
            },
            if self.as_array()[10] == other.as_array()[10] {
                -1
            } else {
                0
            },
            if self.as_array()[11] == other.as_array()[11] {
                -1
            } else {
                0
            },
            if self.as_array()[12] == other.as_array()[12] {
                -1
            } else {
                0
            },
            if self.as_array()[13] == other.as_array()[13] {
                -1
            } else {
                0
            },
            if self.as_array()[14] == other.as_array()[14] {
                -1
            } else {
                0
            },
            if self.as_array()[15] == other.as_array()[15] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  -1  } else { 0 },\n     if self.as_array()[8] > other.as_array()[8] {  -1  } else { 0 },\n     if self.as_array()[9] > other.as_array()[9] {  -1  } else { 0 },\n     if self.as_array()[10] > other.as_array()[10] {  -1  } else { 0 },\n     if self.as_array()[11] > other.as_array()[11] {  -1  } else { 0 },\n     if self.as_array()[12] > other.as_array()[12] {  -1  } else { 0 },\n     if self.as_array()[13] > other.as_array()[13] {  -1  } else { 0 },\n     if self.as_array()[14] > other.as_array()[14] {  -1  } else { 0 },\n     if self.as_array()[15] > other.as_array()[15] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpgt_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpgt_epi8)\n\n\n [`PCMPGTB (XMM, XMM)`](https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html): Compare Packed Signed Integers for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I8x16) -> I8x16 {
        I8x16::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                -1
            } else {
                0
            },
            if self.as_array()[8] > other.as_array()[8] {
                -1
            } else {
                0
            },
            if self.as_array()[9] > other.as_array()[9] {
                -1
            } else {
                0
            },
            if self.as_array()[10] > other.as_array()[10] {
                -1
            } else {
                0
            },
            if self.as_array()[11] > other.as_array()[11] {
                -1
            } else {
                0
            },
            if self.as_array()[12] > other.as_array()[12] {
                -1
            } else {
                0
            },
            if self.as_array()[13] > other.as_array()[13] {
                -1
            } else {
                0
            },
            if self.as_array()[14] > other.as_array()[14] {
                -1
            } else {
                0
            },
            if self.as_array()[15] > other.as_array()[15] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I8x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I8x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi8)\n\n\n [`PUNPCKLBW (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLBW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLBW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLBW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I8x16) -> I8x16 {
        I8x16::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     // Lane# 0\n     self.as_array()[8],\n     other.as_array()[8],\n     self.as_array()[9],\n     other.as_array()[9],\n     self.as_array()[10],\n     other.as_array()[10],\n     self.as_array()[11],\n     other.as_array()[11],\n     self.as_array()[12],\n     other.as_array()[12],\n     self.as_array()[13],\n     other.as_array()[13],\n     self.as_array()[14],\n     other.as_array()[14],\n     self.as_array()[15],\n     other.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi8)\n\n\n [`PUNPCKHBW (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHBW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHBW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHBW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I8x16) -> I8x16 {
        I8x16::from([
            // Lane# 0
            self.as_array()[8],
            other.as_array()[8],
            self.as_array()[9],
            other.as_array()[9],
            self.as_array()[10],
            other.as_array()[10],
            self.as_array()[11],
            other.as_array()[11],
            self.as_array()[12],
            other.as_array()[12],
            self.as_array()[13],
            other.as_array()[13],
            self.as_array()[14],
            other.as_array()[14],
            self.as_array()[15],
            other.as_array()[15],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n     self.as_array()[8].max(other.as_array()[8]),\n     self.as_array()[9].max(other.as_array()[9]),\n     self.as_array()[10].max(other.as_array()[10]),\n     self.as_array()[11].max(other.as_array()[11]),\n     self.as_array()[12].max(other.as_array()[12]),\n     self.as_array()[13].max(other.as_array()[13]),\n     self.as_array()[14].max(other.as_array()[14]),\n     self.as_array()[15].max(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_max_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_max_epi8)\n\n\n [`PMAXSB (XMM, XMM)`](https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html): Maximum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
            self.as_array()[8].max(other.as_array()[8]),
            self.as_array()[9].max(other.as_array()[9]),
            self.as_array()[10].max(other.as_array()[10]),
            self.as_array()[11].max(other.as_array()[11]),
            self.as_array()[12].max(other.as_array()[12]),
            self.as_array()[13].max(other.as_array()[13]),
            self.as_array()[14].max(other.as_array()[14]),
            self.as_array()[15].max(other.as_array()[15]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x16  ,\n # )  -> I8x16\n # {\n I8x16::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n     self.as_array()[8].min(other.as_array()[8]),\n     self.as_array()[9].min(other.as_array()[9]),\n     self.as_array()[10].min(other.as_array()[10]),\n     self.as_array()[11].min(other.as_array()[11]),\n     self.as_array()[12].min(other.as_array()[12]),\n     self.as_array()[13].min(other.as_array()[13]),\n     self.as_array()[14].min(other.as_array()[14]),\n     self.as_array()[15].min(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_min_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_min_epi8)\n\n\n [`PMINSB (XMM, XMM)`](https://felixcloutier.com/x86/PMINSB:PMINSW.html): Minimum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: I8x16) -> I8x16 {
        I8x16::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
            self.as_array()[8].min(other.as_array()[8]),
            self.as_array()[9].min(other.as_array()[9]),
            self.as_array()[10].min(other.as_array()[10]),
            self.as_array()[11].min(other.as_array()[11]),
            self.as_array()[12].min(other.as_array()[12]),
            self.as_array()[13].min(other.as_array()[13]),
            self.as_array()[14].min(other.as_array()[14]),
            self.as_array()[15].min(other.as_array()[15]),
        ])
    }
}
impl crate::SimdBase8<i8> for I8x16 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # {\n let mut out = [0; 16];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);\n }\n I8x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_si128)\n\n\n [`PSLLDQ (XMM, I8)`](https://felixcloutier.com/x86/PSLLDQ.html): Shift Double Quadword Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLDQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLDQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLDQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_left<const AMOUNT: usize>(&self) -> I8x16 {
        let mut out = [0; 16];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);
        }
        I8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x16\n # {\n let mut out = [0; 16];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);\n }\n I8x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srli_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srli_si128)\n\n\n [`PSRLDQ (XMM, I8)`](https://felixcloutier.com/x86/PSRLDQ.html): Shift Double Quadword Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLDQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLDQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLDQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_right<const AMOUNT: usize>(&self) -> I8x16 {
        let mut out = [0; 16];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);
        }
        I8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # ;}\n # impl SomeTraitForDoc for I8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # {\n let mut out: u32 = 0;\n for (i, value) in self.as_array().iter().copied().enumerate() {\n     out |= u32::from((value as u8) >> 7) << i;\n }\n out\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_movemask_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_movemask_epi8)\n\n\n [`PMOVMSKB (R32, XMM)`](https://felixcloutier.com/x86/PMOVMSKB.html): Move Byte Mask\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMOVMSKB_R32_XMM.html#SKL\">Skylake</a></td>\n <td>&le;3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMOVMSKB_R32_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMOVMSKB_R32_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn most_significant_bits(&self) -> u32 {
        let mut out: u32 = 0;
        for (i, value) in self.as_array().iter().copied().enumerate() {
            out |= u32::from((value as u8) >> 7) << i;
        }
        out
    }
}
type I8x32Internal = [i8; 32];
#[doc = "`[i8; 32]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I8x32(I8x32Internal);
unsafe impl bytemuck::Pod for I8x32 {}
unsafe impl bytemuck::Zeroable for I8x32 {}
impl PartialEq for I8x32 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I8x32 {}
impl Default for I8x32 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I8x32 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I8x32 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I8x32({:?})", <[i8; 32]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i8> for I8x32 {}
impl BitXorAssign for I8x32 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n     self.as_array()[8] ^ rhs.as_array()[8],\n     self.as_array()[9] ^ rhs.as_array()[9],\n     self.as_array()[10] ^ rhs.as_array()[10],\n     self.as_array()[11] ^ rhs.as_array()[11],\n     self.as_array()[12] ^ rhs.as_array()[12],\n     self.as_array()[13] ^ rhs.as_array()[13],\n     self.as_array()[14] ^ rhs.as_array()[14],\n     self.as_array()[15] ^ rhs.as_array()[15],\n     self.as_array()[16] ^ rhs.as_array()[16],\n     self.as_array()[17] ^ rhs.as_array()[17],\n     self.as_array()[18] ^ rhs.as_array()[18],\n     self.as_array()[19] ^ rhs.as_array()[19],\n     self.as_array()[20] ^ rhs.as_array()[20],\n     self.as_array()[21] ^ rhs.as_array()[21],\n     self.as_array()[22] ^ rhs.as_array()[22],\n     self.as_array()[23] ^ rhs.as_array()[23],\n     self.as_array()[24] ^ rhs.as_array()[24],\n     self.as_array()[25] ^ rhs.as_array()[25],\n     self.as_array()[26] ^ rhs.as_array()[26],\n     self.as_array()[27] ^ rhs.as_array()[27],\n     self.as_array()[28] ^ rhs.as_array()[28],\n     self.as_array()[29] ^ rhs.as_array()[29],\n     self.as_array()[30] ^ rhs.as_array()[30],\n     self.as_array()[31] ^ rhs.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
            self.as_array()[8] ^ rhs.as_array()[8],
            self.as_array()[9] ^ rhs.as_array()[9],
            self.as_array()[10] ^ rhs.as_array()[10],
            self.as_array()[11] ^ rhs.as_array()[11],
            self.as_array()[12] ^ rhs.as_array()[12],
            self.as_array()[13] ^ rhs.as_array()[13],
            self.as_array()[14] ^ rhs.as_array()[14],
            self.as_array()[15] ^ rhs.as_array()[15],
            self.as_array()[16] ^ rhs.as_array()[16],
            self.as_array()[17] ^ rhs.as_array()[17],
            self.as_array()[18] ^ rhs.as_array()[18],
            self.as_array()[19] ^ rhs.as_array()[19],
            self.as_array()[20] ^ rhs.as_array()[20],
            self.as_array()[21] ^ rhs.as_array()[21],
            self.as_array()[22] ^ rhs.as_array()[22],
            self.as_array()[23] ^ rhs.as_array()[23],
            self.as_array()[24] ^ rhs.as_array()[24],
            self.as_array()[25] ^ rhs.as_array()[25],
            self.as_array()[26] ^ rhs.as_array()[26],
            self.as_array()[27] ^ rhs.as_array()[27],
            self.as_array()[28] ^ rhs.as_array()[28],
            self.as_array()[29] ^ rhs.as_array()[29],
            self.as_array()[30] ^ rhs.as_array()[30],
            self.as_array()[31] ^ rhs.as_array()[31],
        ])
    }
}
impl BitOrAssign for I8x32 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n     self.as_array()[8] | rhs.as_array()[8],\n     self.as_array()[9] | rhs.as_array()[9],\n     self.as_array()[10] | rhs.as_array()[10],\n     self.as_array()[11] | rhs.as_array()[11],\n     self.as_array()[12] | rhs.as_array()[12],\n     self.as_array()[13] | rhs.as_array()[13],\n     self.as_array()[14] | rhs.as_array()[14],\n     self.as_array()[15] | rhs.as_array()[15],\n     self.as_array()[16] | rhs.as_array()[16],\n     self.as_array()[17] | rhs.as_array()[17],\n     self.as_array()[18] | rhs.as_array()[18],\n     self.as_array()[19] | rhs.as_array()[19],\n     self.as_array()[20] | rhs.as_array()[20],\n     self.as_array()[21] | rhs.as_array()[21],\n     self.as_array()[22] | rhs.as_array()[22],\n     self.as_array()[23] | rhs.as_array()[23],\n     self.as_array()[24] | rhs.as_array()[24],\n     self.as_array()[25] | rhs.as_array()[25],\n     self.as_array()[26] | rhs.as_array()[26],\n     self.as_array()[27] | rhs.as_array()[27],\n     self.as_array()[28] | rhs.as_array()[28],\n     self.as_array()[29] | rhs.as_array()[29],\n     self.as_array()[30] | rhs.as_array()[30],\n     self.as_array()[31] | rhs.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
            self.as_array()[8] | rhs.as_array()[8],
            self.as_array()[9] | rhs.as_array()[9],
            self.as_array()[10] | rhs.as_array()[10],
            self.as_array()[11] | rhs.as_array()[11],
            self.as_array()[12] | rhs.as_array()[12],
            self.as_array()[13] | rhs.as_array()[13],
            self.as_array()[14] | rhs.as_array()[14],
            self.as_array()[15] | rhs.as_array()[15],
            self.as_array()[16] | rhs.as_array()[16],
            self.as_array()[17] | rhs.as_array()[17],
            self.as_array()[18] | rhs.as_array()[18],
            self.as_array()[19] | rhs.as_array()[19],
            self.as_array()[20] | rhs.as_array()[20],
            self.as_array()[21] | rhs.as_array()[21],
            self.as_array()[22] | rhs.as_array()[22],
            self.as_array()[23] | rhs.as_array()[23],
            self.as_array()[24] | rhs.as_array()[24],
            self.as_array()[25] | rhs.as_array()[25],
            self.as_array()[26] | rhs.as_array()[26],
            self.as_array()[27] | rhs.as_array()[27],
            self.as_array()[28] | rhs.as_array()[28],
            self.as_array()[29] | rhs.as_array()[29],
            self.as_array()[30] | rhs.as_array()[30],
            self.as_array()[31] | rhs.as_array()[31],
        ])
    }
}
impl BitAndAssign for I8x32 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n     self.as_array()[8] & rhs.as_array()[8],\n     self.as_array()[9] & rhs.as_array()[9],\n     self.as_array()[10] & rhs.as_array()[10],\n     self.as_array()[11] & rhs.as_array()[11],\n     self.as_array()[12] & rhs.as_array()[12],\n     self.as_array()[13] & rhs.as_array()[13],\n     self.as_array()[14] & rhs.as_array()[14],\n     self.as_array()[15] & rhs.as_array()[15],\n     self.as_array()[16] & rhs.as_array()[16],\n     self.as_array()[17] & rhs.as_array()[17],\n     self.as_array()[18] & rhs.as_array()[18],\n     self.as_array()[19] & rhs.as_array()[19],\n     self.as_array()[20] & rhs.as_array()[20],\n     self.as_array()[21] & rhs.as_array()[21],\n     self.as_array()[22] & rhs.as_array()[22],\n     self.as_array()[23] & rhs.as_array()[23],\n     self.as_array()[24] & rhs.as_array()[24],\n     self.as_array()[25] & rhs.as_array()[25],\n     self.as_array()[26] & rhs.as_array()[26],\n     self.as_array()[27] & rhs.as_array()[27],\n     self.as_array()[28] & rhs.as_array()[28],\n     self.as_array()[29] & rhs.as_array()[29],\n     self.as_array()[30] & rhs.as_array()[30],\n     self.as_array()[31] & rhs.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
            self.as_array()[8] & rhs.as_array()[8],
            self.as_array()[9] & rhs.as_array()[9],
            self.as_array()[10] & rhs.as_array()[10],
            self.as_array()[11] & rhs.as_array()[11],
            self.as_array()[12] & rhs.as_array()[12],
            self.as_array()[13] & rhs.as_array()[13],
            self.as_array()[14] & rhs.as_array()[14],
            self.as_array()[15] & rhs.as_array()[15],
            self.as_array()[16] & rhs.as_array()[16],
            self.as_array()[17] & rhs.as_array()[17],
            self.as_array()[18] & rhs.as_array()[18],
            self.as_array()[19] & rhs.as_array()[19],
            self.as_array()[20] & rhs.as_array()[20],
            self.as_array()[21] & rhs.as_array()[21],
            self.as_array()[22] & rhs.as_array()[22],
            self.as_array()[23] & rhs.as_array()[23],
            self.as_array()[24] & rhs.as_array()[24],
            self.as_array()[25] & rhs.as_array()[25],
            self.as_array()[26] & rhs.as_array()[26],
            self.as_array()[27] & rhs.as_array()[27],
            self.as_array()[28] & rhs.as_array()[28],
            self.as_array()[29] & rhs.as_array()[29],
            self.as_array()[30] & rhs.as_array()[30],
            self.as_array()[31] & rhs.as_array()[31],
        ])
    }
}
impl AddAssign for I8x32 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_add(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_add(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_add(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_add(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_add(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_add(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_add(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_add(rhs.as_array()[15]),\n     self.as_array()[16].wrapping_add(rhs.as_array()[16]),\n     self.as_array()[17].wrapping_add(rhs.as_array()[17]),\n     self.as_array()[18].wrapping_add(rhs.as_array()[18]),\n     self.as_array()[19].wrapping_add(rhs.as_array()[19]),\n     self.as_array()[20].wrapping_add(rhs.as_array()[20]),\n     self.as_array()[21].wrapping_add(rhs.as_array()[21]),\n     self.as_array()[22].wrapping_add(rhs.as_array()[22]),\n     self.as_array()[23].wrapping_add(rhs.as_array()[23]),\n     self.as_array()[24].wrapping_add(rhs.as_array()[24]),\n     self.as_array()[25].wrapping_add(rhs.as_array()[25]),\n     self.as_array()[26].wrapping_add(rhs.as_array()[26]),\n     self.as_array()[27].wrapping_add(rhs.as_array()[27]),\n     self.as_array()[28].wrapping_add(rhs.as_array()[28]),\n     self.as_array()[29].wrapping_add(rhs.as_array()[29]),\n     self.as_array()[30].wrapping_add(rhs.as_array()[30]),\n     self.as_array()[31].wrapping_add(rhs.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi8)\n\n\n [`VPADDB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
            self.as_array()[8].wrapping_add(rhs.as_array()[8]),
            self.as_array()[9].wrapping_add(rhs.as_array()[9]),
            self.as_array()[10].wrapping_add(rhs.as_array()[10]),
            self.as_array()[11].wrapping_add(rhs.as_array()[11]),
            self.as_array()[12].wrapping_add(rhs.as_array()[12]),
            self.as_array()[13].wrapping_add(rhs.as_array()[13]),
            self.as_array()[14].wrapping_add(rhs.as_array()[14]),
            self.as_array()[15].wrapping_add(rhs.as_array()[15]),
            self.as_array()[16].wrapping_add(rhs.as_array()[16]),
            self.as_array()[17].wrapping_add(rhs.as_array()[17]),
            self.as_array()[18].wrapping_add(rhs.as_array()[18]),
            self.as_array()[19].wrapping_add(rhs.as_array()[19]),
            self.as_array()[20].wrapping_add(rhs.as_array()[20]),
            self.as_array()[21].wrapping_add(rhs.as_array()[21]),
            self.as_array()[22].wrapping_add(rhs.as_array()[22]),
            self.as_array()[23].wrapping_add(rhs.as_array()[23]),
            self.as_array()[24].wrapping_add(rhs.as_array()[24]),
            self.as_array()[25].wrapping_add(rhs.as_array()[25]),
            self.as_array()[26].wrapping_add(rhs.as_array()[26]),
            self.as_array()[27].wrapping_add(rhs.as_array()[27]),
            self.as_array()[28].wrapping_add(rhs.as_array()[28]),
            self.as_array()[29].wrapping_add(rhs.as_array()[29]),
            self.as_array()[30].wrapping_add(rhs.as_array()[30]),
            self.as_array()[31].wrapping_add(rhs.as_array()[31]),
        ])
    }
}
impl SubAssign for I8x32 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_sub(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_sub(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_sub(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_sub(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_sub(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_sub(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_sub(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_sub(rhs.as_array()[15]),\n     self.as_array()[16].wrapping_sub(rhs.as_array()[16]),\n     self.as_array()[17].wrapping_sub(rhs.as_array()[17]),\n     self.as_array()[18].wrapping_sub(rhs.as_array()[18]),\n     self.as_array()[19].wrapping_sub(rhs.as_array()[19]),\n     self.as_array()[20].wrapping_sub(rhs.as_array()[20]),\n     self.as_array()[21].wrapping_sub(rhs.as_array()[21]),\n     self.as_array()[22].wrapping_sub(rhs.as_array()[22]),\n     self.as_array()[23].wrapping_sub(rhs.as_array()[23]),\n     self.as_array()[24].wrapping_sub(rhs.as_array()[24]),\n     self.as_array()[25].wrapping_sub(rhs.as_array()[25]),\n     self.as_array()[26].wrapping_sub(rhs.as_array()[26]),\n     self.as_array()[27].wrapping_sub(rhs.as_array()[27]),\n     self.as_array()[28].wrapping_sub(rhs.as_array()[28]),\n     self.as_array()[29].wrapping_sub(rhs.as_array()[29]),\n     self.as_array()[30].wrapping_sub(rhs.as_array()[30]),\n     self.as_array()[31].wrapping_sub(rhs.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi8)\n\n\n [`VPSUBB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
            self.as_array()[8].wrapping_sub(rhs.as_array()[8]),
            self.as_array()[9].wrapping_sub(rhs.as_array()[9]),
            self.as_array()[10].wrapping_sub(rhs.as_array()[10]),
            self.as_array()[11].wrapping_sub(rhs.as_array()[11]),
            self.as_array()[12].wrapping_sub(rhs.as_array()[12]),
            self.as_array()[13].wrapping_sub(rhs.as_array()[13]),
            self.as_array()[14].wrapping_sub(rhs.as_array()[14]),
            self.as_array()[15].wrapping_sub(rhs.as_array()[15]),
            self.as_array()[16].wrapping_sub(rhs.as_array()[16]),
            self.as_array()[17].wrapping_sub(rhs.as_array()[17]),
            self.as_array()[18].wrapping_sub(rhs.as_array()[18]),
            self.as_array()[19].wrapping_sub(rhs.as_array()[19]),
            self.as_array()[20].wrapping_sub(rhs.as_array()[20]),
            self.as_array()[21].wrapping_sub(rhs.as_array()[21]),
            self.as_array()[22].wrapping_sub(rhs.as_array()[22]),
            self.as_array()[23].wrapping_sub(rhs.as_array()[23]),
            self.as_array()[24].wrapping_sub(rhs.as_array()[24]),
            self.as_array()[25].wrapping_sub(rhs.as_array()[25]),
            self.as_array()[26].wrapping_sub(rhs.as_array()[26]),
            self.as_array()[27].wrapping_sub(rhs.as_array()[27]),
            self.as_array()[28].wrapping_sub(rhs.as_array()[28]),
            self.as_array()[29].wrapping_sub(rhs.as_array()[29]),
            self.as_array()[30].wrapping_sub(rhs.as_array()[30]),
            self.as_array()[31].wrapping_sub(rhs.as_array()[31]),
        ])
    }
}
impl I8x32 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I8x32Internal) -> Self {
        Self(x)
    }
}
impl From<[i8; 32]> for I8x32 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i8; 32]) -> I8x32 {
        I8x32(array)
    }
}
impl From<I8x32> for [i8; 32] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I8x32) -> [i8; 32] {
        vector.0
    }
}
impl From<I16x16> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: I16x16) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: I32x8) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: I64x4) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: U8x32) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: U16x16) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: U32x8) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for I8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of I8x32."]
    #[inline(always)]
    fn from(x: U64x4) -> I8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I8x16> for I8x32 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I8x16  ,\n # )  -> I8x32\n # {\n let mut out = [0; 32];\n out[0..16].copy_from_slice(&vector.as_array());\n I8x32::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I8x16) -> I8x32 {
        let mut out = [0; 32];
        out[0..16].copy_from_slice(&vector.as_array());
        I8x32::from(out)
    }
}
impl From<[I8x16; 2]> for I8x32 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [I8x16; 2]  ,\n # )  -> I8x32\n # {\n let mut out = [0; 32];\n out[0..16].copy_from_slice(&vectors[0].as_array());\n out[16..].copy_from_slice(&vectors[1].as_array());\n I8x32::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [I8x16; 2]) -> I8x32 {
        let mut out = [0; 32];
        out[0..16].copy_from_slice(&vectors[0].as_array());
        out[16..].copy_from_slice(&vectors[1].as_array());
        I8x32::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<I8x32> for [I8x16; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I8x32  ,\n # )  -> [I8x16; 2]\n # {\n let mut lo = [0; 16];\n let mut hi = [0; 16];\n lo.copy_from_slice(&vector.as_array()[0..16]);\n hi.copy_from_slice(&vector.as_array()[16..]);\n [I8x16::from(lo), I8x16::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I8x32) -> [I8x16; 2] {
        let mut lo = [0; 16];
        let mut hi = [0; 16];
        lo.copy_from_slice(&vector.as_array()[0..16]);
        hi.copy_from_slice(&vector.as_array()[16..]);
        [I8x16::from(lo), I8x16::from(hi)]
    }
} // Static shift
impl ShlAssign<u64> for I8x32 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x32\n # {\n if amount >= 8 {\n     I8x32::ZERO\n } else {\n     I8x32::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n         self.as_array()[8] << amount,\n         self.as_array()[9] << amount,\n         self.as_array()[10] << amount,\n         self.as_array()[11] << amount,\n         self.as_array()[12] << amount,\n         self.as_array()[13] << amount,\n         self.as_array()[14] << amount,\n         self.as_array()[15] << amount,\n         self.as_array()[16] << amount,\n         self.as_array()[17] << amount,\n         self.as_array()[18] << amount,\n         self.as_array()[19] << amount,\n         self.as_array()[20] << amount,\n         self.as_array()[21] << amount,\n         self.as_array()[22] << amount,\n         self.as_array()[23] << amount,\n         self.as_array()[24] << amount,\n         self.as_array()[25] << amount,\n         self.as_array()[26] << amount,\n         self.as_array()[27] << amount,\n         self.as_array()[28] << amount,\n         self.as_array()[29] << amount,\n         self.as_array()[30] << amount,\n         self.as_array()[31] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: u64) -> I8x32 {
        if amount >= 8 {
            I8x32::ZERO
        } else {
            I8x32::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
                self.as_array()[8] << amount,
                self.as_array()[9] << amount,
                self.as_array()[10] << amount,
                self.as_array()[11] << amount,
                self.as_array()[12] << amount,
                self.as_array()[13] << amount,
                self.as_array()[14] << amount,
                self.as_array()[15] << amount,
                self.as_array()[16] << amount,
                self.as_array()[17] << amount,
                self.as_array()[18] << amount,
                self.as_array()[19] << amount,
                self.as_array()[20] << amount,
                self.as_array()[21] << amount,
                self.as_array()[22] << amount,
                self.as_array()[23] << amount,
                self.as_array()[24] << amount,
                self.as_array()[25] << amount,
                self.as_array()[26] << amount,
                self.as_array()[27] << amount,
                self.as_array()[28] << amount,
                self.as_array()[29] << amount,
                self.as_array()[30] << amount,
                self.as_array()[31] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I8x32> for I8x32 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I8x32) {
        *self = (*self) << amount;
    }
}
impl Shl<I8x32> for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x32  ,\n # )  -> I8x32\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: I8x32) -> I8x32 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 || amm < 0 { 0 } else { *x << amm };
        }
        I8x32::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I8x32 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I8x32\n # {\n if amount >= 8 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I8x32::from(out)\n } else {\n     I8x32::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n         self.as_array()[8] >> amount,\n         self.as_array()[9] >> amount,\n         self.as_array()[10] >> amount,\n         self.as_array()[11] >> amount,\n         self.as_array()[12] >> amount,\n         self.as_array()[13] >> amount,\n         self.as_array()[14] >> amount,\n         self.as_array()[15] >> amount,\n         self.as_array()[16] >> amount,\n         self.as_array()[17] >> amount,\n         self.as_array()[18] >> amount,\n         self.as_array()[19] >> amount,\n         self.as_array()[20] >> amount,\n         self.as_array()[21] >> amount,\n         self.as_array()[22] >> amount,\n         self.as_array()[23] >> amount,\n         self.as_array()[24] >> amount,\n         self.as_array()[25] >> amount,\n         self.as_array()[26] >> amount,\n         self.as_array()[27] >> amount,\n         self.as_array()[28] >> amount,\n         self.as_array()[29] >> amount,\n         self.as_array()[30] >> amount,\n         self.as_array()[31] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: u64) -> I8x32 {
        if amount >= 8 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I8x32::from(out)
        } else {
            I8x32::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
                self.as_array()[8] >> amount,
                self.as_array()[9] >> amount,
                self.as_array()[10] >> amount,
                self.as_array()[11] >> amount,
                self.as_array()[12] >> amount,
                self.as_array()[13] >> amount,
                self.as_array()[14] >> amount,
                self.as_array()[15] >> amount,
                self.as_array()[16] >> amount,
                self.as_array()[17] >> amount,
                self.as_array()[18] >> amount,
                self.as_array()[19] >> amount,
                self.as_array()[20] >> amount,
                self.as_array()[21] >> amount,
                self.as_array()[22] >> amount,
                self.as_array()[23] >> amount,
                self.as_array()[24] >> amount,
                self.as_array()[25] >> amount,
                self.as_array()[26] >> amount,
                self.as_array()[27] >> amount,
                self.as_array()[28] >> amount,
                self.as_array()[29] >> amount,
                self.as_array()[30] >> amount,
                self.as_array()[31] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I8x32> for I8x32 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I8x32) {
        *self = (*self) >> amount;
    }
}
impl Shr<I8x32> for I8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I8x32  ,\n # )  -> I8x32\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: I8x32) -> I8x32 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I8x32::from(out)
    }
}
impl SimdBase<i8> for I8x32 {
    type Array = [i8; 32];
    type Signed = I8x32;
    type Unsigned = U8x32;
    const LANES: usize = 32;
    const ZERO: Self = { Self([0; 32]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i8  ,\n # )  -> I8x32\n # {\n let mut out = [0; 32];\n out[0] = scalar;\n I8x32::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i8) -> I8x32 {
        let mut out = [0; 32];
        out[0] = scalar;
        I8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i8\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i8\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i8 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i8  ,\n # )  -> I8x32\n # {\n I8x32::from([scalar; 32])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i8) -> I8x32 {
        I8x32::from([scalar; 32])
    }
    type BroadcastLoInput = I8x16;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I8x16  ,\n # )  -> I8x32\n # {\n I8x32::from([vector.as_array()[0]; 32])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastb_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastb_epi8)\n\n\n [`VPBROADCASTB (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I8x16) -> I8x32 {
        I8x32::from([vector.as_array()[0]; 32])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  -1  } else { 0 },\n     if self.as_array()[8] == other.as_array()[8] {  -1  } else { 0 },\n     if self.as_array()[9] == other.as_array()[9] {  -1  } else { 0 },\n     if self.as_array()[10] == other.as_array()[10] {  -1  } else { 0 },\n     if self.as_array()[11] == other.as_array()[11] {  -1  } else { 0 },\n     if self.as_array()[12] == other.as_array()[12] {  -1  } else { 0 },\n     if self.as_array()[13] == other.as_array()[13] {  -1  } else { 0 },\n     if self.as_array()[14] == other.as_array()[14] {  -1  } else { 0 },\n     if self.as_array()[15] == other.as_array()[15] {  -1  } else { 0 },\n     if self.as_array()[16] == other.as_array()[16] {  -1  } else { 0 },\n     if self.as_array()[17] == other.as_array()[17] {  -1  } else { 0 },\n     if self.as_array()[18] == other.as_array()[18] {  -1  } else { 0 },\n     if self.as_array()[19] == other.as_array()[19] {  -1  } else { 0 },\n     if self.as_array()[20] == other.as_array()[20] {  -1  } else { 0 },\n     if self.as_array()[21] == other.as_array()[21] {  -1  } else { 0 },\n     if self.as_array()[22] == other.as_array()[22] {  -1  } else { 0 },\n     if self.as_array()[23] == other.as_array()[23] {  -1  } else { 0 },\n     if self.as_array()[24] == other.as_array()[24] {  -1  } else { 0 },\n     if self.as_array()[25] == other.as_array()[25] {  -1  } else { 0 },\n     if self.as_array()[26] == other.as_array()[26] {  -1  } else { 0 },\n     if self.as_array()[27] == other.as_array()[27] {  -1  } else { 0 },\n     if self.as_array()[28] == other.as_array()[28] {  -1  } else { 0 },\n     if self.as_array()[29] == other.as_array()[29] {  -1  } else { 0 },\n     if self.as_array()[30] == other.as_array()[30] {  -1  } else { 0 },\n     if self.as_array()[31] == other.as_array()[31] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi8)\n\n\n [`VPCMPEQB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I8x32) -> I8x32 {
        I8x32::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                -1
            } else {
                0
            },
            if self.as_array()[8] == other.as_array()[8] {
                -1
            } else {
                0
            },
            if self.as_array()[9] == other.as_array()[9] {
                -1
            } else {
                0
            },
            if self.as_array()[10] == other.as_array()[10] {
                -1
            } else {
                0
            },
            if self.as_array()[11] == other.as_array()[11] {
                -1
            } else {
                0
            },
            if self.as_array()[12] == other.as_array()[12] {
                -1
            } else {
                0
            },
            if self.as_array()[13] == other.as_array()[13] {
                -1
            } else {
                0
            },
            if self.as_array()[14] == other.as_array()[14] {
                -1
            } else {
                0
            },
            if self.as_array()[15] == other.as_array()[15] {
                -1
            } else {
                0
            },
            if self.as_array()[16] == other.as_array()[16] {
                -1
            } else {
                0
            },
            if self.as_array()[17] == other.as_array()[17] {
                -1
            } else {
                0
            },
            if self.as_array()[18] == other.as_array()[18] {
                -1
            } else {
                0
            },
            if self.as_array()[19] == other.as_array()[19] {
                -1
            } else {
                0
            },
            if self.as_array()[20] == other.as_array()[20] {
                -1
            } else {
                0
            },
            if self.as_array()[21] == other.as_array()[21] {
                -1
            } else {
                0
            },
            if self.as_array()[22] == other.as_array()[22] {
                -1
            } else {
                0
            },
            if self.as_array()[23] == other.as_array()[23] {
                -1
            } else {
                0
            },
            if self.as_array()[24] == other.as_array()[24] {
                -1
            } else {
                0
            },
            if self.as_array()[25] == other.as_array()[25] {
                -1
            } else {
                0
            },
            if self.as_array()[26] == other.as_array()[26] {
                -1
            } else {
                0
            },
            if self.as_array()[27] == other.as_array()[27] {
                -1
            } else {
                0
            },
            if self.as_array()[28] == other.as_array()[28] {
                -1
            } else {
                0
            },
            if self.as_array()[29] == other.as_array()[29] {
                -1
            } else {
                0
            },
            if self.as_array()[30] == other.as_array()[30] {
                -1
            } else {
                0
            },
            if self.as_array()[31] == other.as_array()[31] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  -1  } else { 0 },\n     if self.as_array()[8] > other.as_array()[8] {  -1  } else { 0 },\n     if self.as_array()[9] > other.as_array()[9] {  -1  } else { 0 },\n     if self.as_array()[10] > other.as_array()[10] {  -1  } else { 0 },\n     if self.as_array()[11] > other.as_array()[11] {  -1  } else { 0 },\n     if self.as_array()[12] > other.as_array()[12] {  -1  } else { 0 },\n     if self.as_array()[13] > other.as_array()[13] {  -1  } else { 0 },\n     if self.as_array()[14] > other.as_array()[14] {  -1  } else { 0 },\n     if self.as_array()[15] > other.as_array()[15] {  -1  } else { 0 },\n     if self.as_array()[16] > other.as_array()[16] {  -1  } else { 0 },\n     if self.as_array()[17] > other.as_array()[17] {  -1  } else { 0 },\n     if self.as_array()[18] > other.as_array()[18] {  -1  } else { 0 },\n     if self.as_array()[19] > other.as_array()[19] {  -1  } else { 0 },\n     if self.as_array()[20] > other.as_array()[20] {  -1  } else { 0 },\n     if self.as_array()[21] > other.as_array()[21] {  -1  } else { 0 },\n     if self.as_array()[22] > other.as_array()[22] {  -1  } else { 0 },\n     if self.as_array()[23] > other.as_array()[23] {  -1  } else { 0 },\n     if self.as_array()[24] > other.as_array()[24] {  -1  } else { 0 },\n     if self.as_array()[25] > other.as_array()[25] {  -1  } else { 0 },\n     if self.as_array()[26] > other.as_array()[26] {  -1  } else { 0 },\n     if self.as_array()[27] > other.as_array()[27] {  -1  } else { 0 },\n     if self.as_array()[28] > other.as_array()[28] {  -1  } else { 0 },\n     if self.as_array()[29] > other.as_array()[29] {  -1  } else { 0 },\n     if self.as_array()[30] > other.as_array()[30] {  -1  } else { 0 },\n     if self.as_array()[31] > other.as_array()[31] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpgt_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpgt_epi8)\n\n\n [`VPCMPGTB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html): Compare Packed Signed Integers for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I8x32) -> I8x32 {
        I8x32::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                -1
            } else {
                0
            },
            if self.as_array()[8] > other.as_array()[8] {
                -1
            } else {
                0
            },
            if self.as_array()[9] > other.as_array()[9] {
                -1
            } else {
                0
            },
            if self.as_array()[10] > other.as_array()[10] {
                -1
            } else {
                0
            },
            if self.as_array()[11] > other.as_array()[11] {
                -1
            } else {
                0
            },
            if self.as_array()[12] > other.as_array()[12] {
                -1
            } else {
                0
            },
            if self.as_array()[13] > other.as_array()[13] {
                -1
            } else {
                0
            },
            if self.as_array()[14] > other.as_array()[14] {
                -1
            } else {
                0
            },
            if self.as_array()[15] > other.as_array()[15] {
                -1
            } else {
                0
            },
            if self.as_array()[16] > other.as_array()[16] {
                -1
            } else {
                0
            },
            if self.as_array()[17] > other.as_array()[17] {
                -1
            } else {
                0
            },
            if self.as_array()[18] > other.as_array()[18] {
                -1
            } else {
                0
            },
            if self.as_array()[19] > other.as_array()[19] {
                -1
            } else {
                0
            },
            if self.as_array()[20] > other.as_array()[20] {
                -1
            } else {
                0
            },
            if self.as_array()[21] > other.as_array()[21] {
                -1
            } else {
                0
            },
            if self.as_array()[22] > other.as_array()[22] {
                -1
            } else {
                0
            },
            if self.as_array()[23] > other.as_array()[23] {
                -1
            } else {
                0
            },
            if self.as_array()[24] > other.as_array()[24] {
                -1
            } else {
                0
            },
            if self.as_array()[25] > other.as_array()[25] {
                -1
            } else {
                0
            },
            if self.as_array()[26] > other.as_array()[26] {
                -1
            } else {
                0
            },
            if self.as_array()[27] > other.as_array()[27] {
                -1
            } else {
                0
            },
            if self.as_array()[28] > other.as_array()[28] {
                -1
            } else {
                0
            },
            if self.as_array()[29] > other.as_array()[29] {
                -1
            } else {
                0
            },
            if self.as_array()[30] > other.as_array()[30] {
                -1
            } else {
                0
            },
            if self.as_array()[31] > other.as_array()[31] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I8x32 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I8x32 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n     // Lane# 1\n     self.as_array()[16],\n     other.as_array()[16],\n     self.as_array()[17],\n     other.as_array()[17],\n     self.as_array()[18],\n     other.as_array()[18],\n     self.as_array()[19],\n     other.as_array()[19],\n     self.as_array()[20],\n     other.as_array()[20],\n     self.as_array()[21],\n     other.as_array()[21],\n     self.as_array()[22],\n     other.as_array()[22],\n     self.as_array()[23],\n     other.as_array()[23],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi8)\n\n\n [`VPUNPCKLBW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLBW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLBW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLBW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I8x32) -> I8x32 {
        I8x32::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7], // Lane# 1
            self.as_array()[16],
            other.as_array()[16],
            self.as_array()[17],
            other.as_array()[17],
            self.as_array()[18],
            other.as_array()[18],
            self.as_array()[19],
            other.as_array()[19],
            self.as_array()[20],
            other.as_array()[20],
            self.as_array()[21],
            other.as_array()[21],
            self.as_array()[22],
            other.as_array()[22],
            self.as_array()[23],
            other.as_array()[23],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     // Lane# 0\n     self.as_array()[8],\n     other.as_array()[8],\n     self.as_array()[9],\n     other.as_array()[9],\n     self.as_array()[10],\n     other.as_array()[10],\n     self.as_array()[11],\n     other.as_array()[11],\n     self.as_array()[12],\n     other.as_array()[12],\n     self.as_array()[13],\n     other.as_array()[13],\n     self.as_array()[14],\n     other.as_array()[14],\n     self.as_array()[15],\n     other.as_array()[15],\n     // Lane# 1\n     self.as_array()[24],\n     other.as_array()[24],\n     self.as_array()[25],\n     other.as_array()[25],\n     self.as_array()[26],\n     other.as_array()[26],\n     self.as_array()[27],\n     other.as_array()[27],\n     self.as_array()[28],\n     other.as_array()[28],\n     self.as_array()[29],\n     other.as_array()[29],\n     self.as_array()[30],\n     other.as_array()[30],\n     self.as_array()[31],\n     other.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi8)\n\n\n [`VPUNPCKHBW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHBW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHBW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHBW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I8x32) -> I8x32 {
        I8x32::from([
            // Lane# 0
            self.as_array()[8],
            other.as_array()[8],
            self.as_array()[9],
            other.as_array()[9],
            self.as_array()[10],
            other.as_array()[10],
            self.as_array()[11],
            other.as_array()[11],
            self.as_array()[12],
            other.as_array()[12],
            self.as_array()[13],
            other.as_array()[13],
            self.as_array()[14],
            other.as_array()[14],
            self.as_array()[15],
            other.as_array()[15], // Lane# 1
            self.as_array()[24],
            other.as_array()[24],
            self.as_array()[25],
            other.as_array()[25],
            self.as_array()[26],
            other.as_array()[26],
            self.as_array()[27],
            other.as_array()[27],
            self.as_array()[28],
            other.as_array()[28],
            self.as_array()[29],
            other.as_array()[29],
            self.as_array()[30],
            other.as_array()[30],
            self.as_array()[31],
            other.as_array()[31],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n     self.as_array()[8].max(other.as_array()[8]),\n     self.as_array()[9].max(other.as_array()[9]),\n     self.as_array()[10].max(other.as_array()[10]),\n     self.as_array()[11].max(other.as_array()[11]),\n     self.as_array()[12].max(other.as_array()[12]),\n     self.as_array()[13].max(other.as_array()[13]),\n     self.as_array()[14].max(other.as_array()[14]),\n     self.as_array()[15].max(other.as_array()[15]),\n     self.as_array()[16].max(other.as_array()[16]),\n     self.as_array()[17].max(other.as_array()[17]),\n     self.as_array()[18].max(other.as_array()[18]),\n     self.as_array()[19].max(other.as_array()[19]),\n     self.as_array()[20].max(other.as_array()[20]),\n     self.as_array()[21].max(other.as_array()[21]),\n     self.as_array()[22].max(other.as_array()[22]),\n     self.as_array()[23].max(other.as_array()[23]),\n     self.as_array()[24].max(other.as_array()[24]),\n     self.as_array()[25].max(other.as_array()[25]),\n     self.as_array()[26].max(other.as_array()[26]),\n     self.as_array()[27].max(other.as_array()[27]),\n     self.as_array()[28].max(other.as_array()[28]),\n     self.as_array()[29].max(other.as_array()[29]),\n     self.as_array()[30].max(other.as_array()[30]),\n     self.as_array()[31].max(other.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_max_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_max_epi8)\n\n\n [`VPMAXSB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html): Maximum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
            self.as_array()[8].max(other.as_array()[8]),
            self.as_array()[9].max(other.as_array()[9]),
            self.as_array()[10].max(other.as_array()[10]),
            self.as_array()[11].max(other.as_array()[11]),
            self.as_array()[12].max(other.as_array()[12]),
            self.as_array()[13].max(other.as_array()[13]),
            self.as_array()[14].max(other.as_array()[14]),
            self.as_array()[15].max(other.as_array()[15]),
            self.as_array()[16].max(other.as_array()[16]),
            self.as_array()[17].max(other.as_array()[17]),
            self.as_array()[18].max(other.as_array()[18]),
            self.as_array()[19].max(other.as_array()[19]),
            self.as_array()[20].max(other.as_array()[20]),
            self.as_array()[21].max(other.as_array()[21]),
            self.as_array()[22].max(other.as_array()[22]),
            self.as_array()[23].max(other.as_array()[23]),
            self.as_array()[24].max(other.as_array()[24]),
            self.as_array()[25].max(other.as_array()[25]),
            self.as_array()[26].max(other.as_array()[26]),
            self.as_array()[27].max(other.as_array()[27]),
            self.as_array()[28].max(other.as_array()[28]),
            self.as_array()[29].max(other.as_array()[29]),
            self.as_array()[30].max(other.as_array()[30]),
            self.as_array()[31].max(other.as_array()[31]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I8x32  ,\n # )  -> I8x32\n # {\n I8x32::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n     self.as_array()[8].min(other.as_array()[8]),\n     self.as_array()[9].min(other.as_array()[9]),\n     self.as_array()[10].min(other.as_array()[10]),\n     self.as_array()[11].min(other.as_array()[11]),\n     self.as_array()[12].min(other.as_array()[12]),\n     self.as_array()[13].min(other.as_array()[13]),\n     self.as_array()[14].min(other.as_array()[14]),\n     self.as_array()[15].min(other.as_array()[15]),\n     self.as_array()[16].min(other.as_array()[16]),\n     self.as_array()[17].min(other.as_array()[17]),\n     self.as_array()[18].min(other.as_array()[18]),\n     self.as_array()[19].min(other.as_array()[19]),\n     self.as_array()[20].min(other.as_array()[20]),\n     self.as_array()[21].min(other.as_array()[21]),\n     self.as_array()[22].min(other.as_array()[22]),\n     self.as_array()[23].min(other.as_array()[23]),\n     self.as_array()[24].min(other.as_array()[24]),\n     self.as_array()[25].min(other.as_array()[25]),\n     self.as_array()[26].min(other.as_array()[26]),\n     self.as_array()[27].min(other.as_array()[27]),\n     self.as_array()[28].min(other.as_array()[28]),\n     self.as_array()[29].min(other.as_array()[29]),\n     self.as_array()[30].min(other.as_array()[30]),\n     self.as_array()[31].min(other.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_min_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_min_epi8)\n\n\n [`VPMINSB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMINSB:PMINSW.html): Minimum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: I8x32) -> I8x32 {
        I8x32::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
            self.as_array()[8].min(other.as_array()[8]),
            self.as_array()[9].min(other.as_array()[9]),
            self.as_array()[10].min(other.as_array()[10]),
            self.as_array()[11].min(other.as_array()[11]),
            self.as_array()[12].min(other.as_array()[12]),
            self.as_array()[13].min(other.as_array()[13]),
            self.as_array()[14].min(other.as_array()[14]),
            self.as_array()[15].min(other.as_array()[15]),
            self.as_array()[16].min(other.as_array()[16]),
            self.as_array()[17].min(other.as_array()[17]),
            self.as_array()[18].min(other.as_array()[18]),
            self.as_array()[19].min(other.as_array()[19]),
            self.as_array()[20].min(other.as_array()[20]),
            self.as_array()[21].min(other.as_array()[21]),
            self.as_array()[22].min(other.as_array()[22]),
            self.as_array()[23].min(other.as_array()[23]),
            self.as_array()[24].min(other.as_array()[24]),
            self.as_array()[25].min(other.as_array()[25]),
            self.as_array()[26].min(other.as_array()[26]),
            self.as_array()[27].min(other.as_array()[27]),
            self.as_array()[28].min(other.as_array()[28]),
            self.as_array()[29].min(other.as_array()[29]),
            self.as_array()[30].min(other.as_array()[30]),
            self.as_array()[31].min(other.as_array()[31]),
        ])
    }
}
impl crate::SimdBase8<i8> for I8x32 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # {\n let mut out = [0; 32];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);\n }\n I8x32::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_si256)\n\n\n [`VPSLLDQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLDQ.html): Shift Double Quadword Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLDQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLDQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLDQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_left<const AMOUNT: usize>(&self) -> I8x32 {
        let mut out = [0; 32];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);
        }
        I8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I8x32\n # {\n let mut out = [0; 32];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);\n }\n I8x32::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srli_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srli_si256)\n\n\n [`VPSRLDQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRLDQ.html): Shift Double Quadword Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLDQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLDQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLDQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_right<const AMOUNT: usize>(&self) -> I8x32 {
        let mut out = [0; 32];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);
        }
        I8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # ;}\n # impl SomeTraitForDoc for I8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # {\n let mut out: u32 = 0;\n for (i, value) in self.as_array().iter().copied().enumerate() {\n     out |= u32::from((value as u8) >> 7) << i;\n }\n out\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_movemask_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_movemask_epi8)\n\n\n [`VPMOVMSKB (R32, YMM)`](https://felixcloutier.com/x86/PMOVMSKB.html): Move Byte Mask\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVMSKB_R32_YMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVMSKB_R32_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVMSKB_R32_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn most_significant_bits(&self) -> u32 {
        let mut out: u32 = 0;
        for (i, value) in self.as_array().iter().copied().enumerate() {
            out |= u32::from((value as u8) >> 7) << i;
        }
        out
    }
}
type I16x8Internal = [i16; 8];
#[doc = "`[i16; 8]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I16x8(I16x8Internal);
unsafe impl bytemuck::Pod for I16x8 {}
unsafe impl bytemuck::Zeroable for I16x8 {}
impl PartialEq for I16x8 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I16x8 {}
impl Default for I16x8 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I16x8 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I16x8 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I16x8({:?})", <[i16; 8]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i16> for I16x8 {}
impl BitXorAssign for I16x8 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
        ])
    }
}
impl BitOrAssign for I16x8 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
        ])
    }
}
impl BitAndAssign for I16x8 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
        ])
    }
}
impl AddAssign for I16x8 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi16)\n\n\n [`PADDW (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
        ])
    }
}
impl SubAssign for I16x8 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi16)\n\n\n [`PSUBW (XMM, XMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
        ])
    }
}
impl I16x8 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I16x8Internal) -> Self {
        Self(x)
    }
}
impl From<[i16; 8]> for I16x8 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i16; 8]) -> I16x8 {
        I16x8(array)
    }
}
impl From<I16x8> for [i16; 8] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I16x8) -> [i16; 8] {
        vector.0
    }
}
impl From<I8x16> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: I8x16) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: I32x4) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: I64x2) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: U8x16) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: U16x8) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: U32x4) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for I16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of I16x8."]
    #[inline(always)]
    fn from(x: U64x2) -> I16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
} // Static shift
impl ShlAssign<u64> for I16x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x8\n # {\n if amount >= 16 {\n     I16x8::ZERO\n } else {\n     I16x8::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sll_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sll_epi16)\n\n\n [`PSLLW (XMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> I16x8 {
        if amount >= 16 {
            I16x8::ZERO
        } else {
            I16x8::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I16x8> for I16x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I16x8) {
        *self = (*self) << amount;
    }
}
impl Shl<I16x8> for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x8  ,\n # )  -> I16x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I16x8::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: I16x8) -> I16x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 || amm < 0 { 0 } else { *x << amm };
        }
        I16x8::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I16x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x8\n # {\n if amount >= 16 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I16x8::from(out)\n } else {\n     I16x8::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sra_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sra_epi16)\n\n\n [`PSRAW (XMM, XMM)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> I16x8 {
        if amount >= 16 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I16x8::from(out)
        } else {
            I16x8::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I16x8> for I16x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I16x8) {
        *self = (*self) >> amount;
    }
}
impl Shr<I16x8> for I16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x8  ,\n # )  -> I16x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I16x8::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: I16x8) -> I16x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I16x8::from(out)
    }
}
impl SimdBase<i16> for I16x8 {
    type Array = [i16; 8];
    type Signed = I16x8;
    type Unsigned = U16x8;
    const LANES: usize = 8;
    const ZERO: Self = { Self([0; 8]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i16  ,\n # )  -> I16x8\n # {\n let mut out = [0; 8];\n out[0] = scalar;\n I16x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i16) -> I16x8 {
        let mut out = [0; 8];
        out[0] = scalar;
        I16x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i16\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i16\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi16)\n\n\n [`PEXTRW (R32, XMM, I8)`](https://felixcloutier.com/x86/PEXTRW.html): Extract Word\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRW_R32_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRW_R32_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRW_R32_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i16 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i16  ,\n # )  -> I16x8\n # {\n I16x8::from([scalar; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i16) -> I16x8 {
        I16x8::from([scalar; 8])
    }
    type BroadcastLoInput = I16x8;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([vector.as_array()[0]; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastw_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastw_epi16)\n\n\n [`VPBROADCASTW (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I16x8) -> I16x8 {
        I16x8::from([vector.as_array()[0]; 8])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi16)\n\n\n [`PCMPEQW (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I16x8) -> I16x8 {
        I16x8::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpgt_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpgt_epi16)\n\n\n [`PCMPGTW (XMM, XMM)`](https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html): Compare Packed Signed Integers for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I16x8) -> I16x8 {
        I16x8::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I16x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_epi16)\n\n\n [`PSLLW (XMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I16x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I16x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I16x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srai_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srai_epi16)\n\n\n [`PSRAW (XMM, I8)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAW_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAW_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAW_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I16x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I16x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi16)\n\n\n [`PUNPCKLWD (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLWD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLWD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLWD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I16x8) -> I16x8 {
        I16x8::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     // Lane# 0\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi16)\n\n\n [`PUNPCKHWD (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHWD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHWD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHWD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I16x8) -> I16x8 {
        I16x8::from([
            // Lane# 0
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_max_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_max_epi16)\n\n\n [`PMAXSW (XMM, XMM)`](https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html): Maximum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_min_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_min_epi16)\n\n\n [`PMINSW (XMM, XMM)`](https://felixcloutier.com/x86/PMINSB:PMINSW.html): Minimum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: I16x8) -> I16x8 {
        I16x8::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
        ])
    }
}
impl crate::SimdBase8x<i16> for I16x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I16x8  ,\n # )  -> I16x8\n # ;}\n # impl SomeTraitForDoc for I16x8 {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I16x8  ,\n # )  -> I16x8\n # {\n I16x8::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n         (if B4 { if_true } else { *self }).as_array()[4],\n         (if B5 { if_true } else { *self }).as_array()[5],\n         (if B6 { if_true } else { *self }).as_array()[6],\n         (if B7 { if_true } else { *self }).as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_blend_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_blend_epi16)\n\n\n [`PBLENDW (XMM, XMM, I8)`](https://felixcloutier.com/x86/PBLENDW.html): Blend Packed Words\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PBLENDW_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PBLENDW_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PBLENDW_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<
        const B7: bool,
        const B6: bool,
        const B5: bool,
        const B4: bool,
        const B3: bool,
        const B2: bool,
        const B1: bool,
        const B0: bool,
    >(
        &self,
        if_true: I16x8,
    ) -> I16x8 {
        I16x8::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
            (if B4 { if_true } else { *self }).as_array()[4],
            (if B5 { if_true } else { *self }).as_array()[5],
            (if B6 { if_true } else { *self }).as_array()[6],
            (if B7 { if_true } else { *self }).as_array()[7],
        ])
    }
}
type I16x16Internal = [i16; 16];
#[doc = "`[i16; 16]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I16x16(I16x16Internal);
unsafe impl bytemuck::Pod for I16x16 {}
unsafe impl bytemuck::Zeroable for I16x16 {}
impl PartialEq for I16x16 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I16x16 {}
impl Default for I16x16 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I16x16 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I16x16 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I16x16({:?})", <[i16; 16]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i16> for I16x16 {}
impl BitXorAssign for I16x16 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n     self.as_array()[8] ^ rhs.as_array()[8],\n     self.as_array()[9] ^ rhs.as_array()[9],\n     self.as_array()[10] ^ rhs.as_array()[10],\n     self.as_array()[11] ^ rhs.as_array()[11],\n     self.as_array()[12] ^ rhs.as_array()[12],\n     self.as_array()[13] ^ rhs.as_array()[13],\n     self.as_array()[14] ^ rhs.as_array()[14],\n     self.as_array()[15] ^ rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
            self.as_array()[8] ^ rhs.as_array()[8],
            self.as_array()[9] ^ rhs.as_array()[9],
            self.as_array()[10] ^ rhs.as_array()[10],
            self.as_array()[11] ^ rhs.as_array()[11],
            self.as_array()[12] ^ rhs.as_array()[12],
            self.as_array()[13] ^ rhs.as_array()[13],
            self.as_array()[14] ^ rhs.as_array()[14],
            self.as_array()[15] ^ rhs.as_array()[15],
        ])
    }
}
impl BitOrAssign for I16x16 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n     self.as_array()[8] | rhs.as_array()[8],\n     self.as_array()[9] | rhs.as_array()[9],\n     self.as_array()[10] | rhs.as_array()[10],\n     self.as_array()[11] | rhs.as_array()[11],\n     self.as_array()[12] | rhs.as_array()[12],\n     self.as_array()[13] | rhs.as_array()[13],\n     self.as_array()[14] | rhs.as_array()[14],\n     self.as_array()[15] | rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
            self.as_array()[8] | rhs.as_array()[8],
            self.as_array()[9] | rhs.as_array()[9],
            self.as_array()[10] | rhs.as_array()[10],
            self.as_array()[11] | rhs.as_array()[11],
            self.as_array()[12] | rhs.as_array()[12],
            self.as_array()[13] | rhs.as_array()[13],
            self.as_array()[14] | rhs.as_array()[14],
            self.as_array()[15] | rhs.as_array()[15],
        ])
    }
}
impl BitAndAssign for I16x16 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n     self.as_array()[8] & rhs.as_array()[8],\n     self.as_array()[9] & rhs.as_array()[9],\n     self.as_array()[10] & rhs.as_array()[10],\n     self.as_array()[11] & rhs.as_array()[11],\n     self.as_array()[12] & rhs.as_array()[12],\n     self.as_array()[13] & rhs.as_array()[13],\n     self.as_array()[14] & rhs.as_array()[14],\n     self.as_array()[15] & rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
            self.as_array()[8] & rhs.as_array()[8],
            self.as_array()[9] & rhs.as_array()[9],
            self.as_array()[10] & rhs.as_array()[10],
            self.as_array()[11] & rhs.as_array()[11],
            self.as_array()[12] & rhs.as_array()[12],
            self.as_array()[13] & rhs.as_array()[13],
            self.as_array()[14] & rhs.as_array()[14],
            self.as_array()[15] & rhs.as_array()[15],
        ])
    }
}
impl AddAssign for I16x16 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_add(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_add(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_add(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_add(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_add(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_add(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_add(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_add(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi16)\n\n\n [`VPADDW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
            self.as_array()[8].wrapping_add(rhs.as_array()[8]),
            self.as_array()[9].wrapping_add(rhs.as_array()[9]),
            self.as_array()[10].wrapping_add(rhs.as_array()[10]),
            self.as_array()[11].wrapping_add(rhs.as_array()[11]),
            self.as_array()[12].wrapping_add(rhs.as_array()[12]),
            self.as_array()[13].wrapping_add(rhs.as_array()[13]),
            self.as_array()[14].wrapping_add(rhs.as_array()[14]),
            self.as_array()[15].wrapping_add(rhs.as_array()[15]),
        ])
    }
}
impl SubAssign for I16x16 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_sub(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_sub(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_sub(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_sub(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_sub(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_sub(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_sub(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_sub(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi16)\n\n\n [`VPSUBW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
            self.as_array()[8].wrapping_sub(rhs.as_array()[8]),
            self.as_array()[9].wrapping_sub(rhs.as_array()[9]),
            self.as_array()[10].wrapping_sub(rhs.as_array()[10]),
            self.as_array()[11].wrapping_sub(rhs.as_array()[11]),
            self.as_array()[12].wrapping_sub(rhs.as_array()[12]),
            self.as_array()[13].wrapping_sub(rhs.as_array()[13]),
            self.as_array()[14].wrapping_sub(rhs.as_array()[14]),
            self.as_array()[15].wrapping_sub(rhs.as_array()[15]),
        ])
    }
}
impl I16x16 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I16x16Internal) -> Self {
        Self(x)
    }
}
impl From<[i16; 16]> for I16x16 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i16; 16]) -> I16x16 {
        I16x16(array)
    }
}
impl From<I16x16> for [i16; 16] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I16x16) -> [i16; 16] {
        vector.0
    }
}
impl From<I8x32> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: I8x32) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: I32x8) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: I64x4) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: U8x32) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: U16x16) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: U32x8) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for I16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of I16x16."]
    #[inline(always)]
    fn from(x: U64x4) -> I16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I8x16> for I16x16 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I8x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n         i16::from(vector.as_array()[0]),\n         i16::from(vector.as_array()[1]),\n         i16::from(vector.as_array()[2]),\n         i16::from(vector.as_array()[3]),\n         i16::from(vector.as_array()[4]),\n         i16::from(vector.as_array()[5]),\n         i16::from(vector.as_array()[6]),\n         i16::from(vector.as_array()[7]),\n         i16::from(vector.as_array()[8]),\n         i16::from(vector.as_array()[9]),\n         i16::from(vector.as_array()[10]),\n         i16::from(vector.as_array()[11]),\n         i16::from(vector.as_array()[12]),\n         i16::from(vector.as_array()[13]),\n         i16::from(vector.as_array()[14]),\n         i16::from(vector.as_array()[15]),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cvtepi8_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepi8_epi16)\n\n\n [`VPMOVSXBW (YMM, XMM)`](https://felixcloutier.com/x86/PMOVSX.html): Packed Move with Sign Extend\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXBW_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXBW_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXBW_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I8x16) -> I16x16 {
        I16x16::from([
            i16::from(vector.as_array()[0]),
            i16::from(vector.as_array()[1]),
            i16::from(vector.as_array()[2]),
            i16::from(vector.as_array()[3]),
            i16::from(vector.as_array()[4]),
            i16::from(vector.as_array()[5]),
            i16::from(vector.as_array()[6]),
            i16::from(vector.as_array()[7]),
            i16::from(vector.as_array()[8]),
            i16::from(vector.as_array()[9]),
            i16::from(vector.as_array()[10]),
            i16::from(vector.as_array()[11]),
            i16::from(vector.as_array()[12]),
            i16::from(vector.as_array()[13]),
            i16::from(vector.as_array()[14]),
            i16::from(vector.as_array()[15]),
        ])
    }
}
impl From<I16x8> for I16x16 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I16x8  ,\n # )  -> I16x16\n # {\n let mut out = [0; 16];\n out[0..8].copy_from_slice(&vector.as_array());\n I16x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I16x8) -> I16x16 {
        let mut out = [0; 16];
        out[0..8].copy_from_slice(&vector.as_array());
        I16x16::from(out)
    }
}
impl From<[I16x8; 2]> for I16x16 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [I16x8; 2]  ,\n # )  -> I16x16\n # {\n let mut out = [0; 16];\n out[0..8].copy_from_slice(&vectors[0].as_array());\n out[8..].copy_from_slice(&vectors[1].as_array());\n I16x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [I16x8; 2]) -> I16x16 {
        let mut out = [0; 16];
        out[0..8].copy_from_slice(&vectors[0].as_array());
        out[8..].copy_from_slice(&vectors[1].as_array());
        I16x16::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<I16x16> for [I16x8; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I16x16  ,\n # )  -> [I16x8; 2]\n # {\n let mut lo = [0; 8];\n let mut hi = [0; 8];\n lo.copy_from_slice(&vector.as_array()[0..8]);\n hi.copy_from_slice(&vector.as_array()[8..]);\n [I16x8::from(lo), I16x8::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I16x16) -> [I16x8; 2] {
        let mut lo = [0; 8];
        let mut hi = [0; 8];
        lo.copy_from_slice(&vector.as_array()[0..8]);
        hi.copy_from_slice(&vector.as_array()[8..]);
        [I16x8::from(lo), I16x8::from(hi)]
    }
} // Static shift
impl ShlAssign<u64> for I16x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x16\n # {\n if amount >= 16 {\n     I16x16::ZERO\n } else {\n     I16x16::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n         self.as_array()[8] << amount,\n         self.as_array()[9] << amount,\n         self.as_array()[10] << amount,\n         self.as_array()[11] << amount,\n         self.as_array()[12] << amount,\n         self.as_array()[13] << amount,\n         self.as_array()[14] << amount,\n         self.as_array()[15] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sll_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sll_epi16)\n\n\n [`VPSLLW (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> I16x16 {
        if amount >= 16 {
            I16x16::ZERO
        } else {
            I16x16::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
                self.as_array()[8] << amount,
                self.as_array()[9] << amount,
                self.as_array()[10] << amount,
                self.as_array()[11] << amount,
                self.as_array()[12] << amount,
                self.as_array()[13] << amount,
                self.as_array()[14] << amount,
                self.as_array()[15] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I16x16> for I16x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I16x16) {
        *self = (*self) << amount;
    }
}
impl Shl<I16x16> for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x16  ,\n # )  -> I16x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I16x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: I16x16) -> I16x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 || amm < 0 { 0 } else { *x << amm };
        }
        I16x16::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I16x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I16x16\n # {\n if amount >= 16 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I16x16::from(out)\n } else {\n     I16x16::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n         self.as_array()[8] >> amount,\n         self.as_array()[9] >> amount,\n         self.as_array()[10] >> amount,\n         self.as_array()[11] >> amount,\n         self.as_array()[12] >> amount,\n         self.as_array()[13] >> amount,\n         self.as_array()[14] >> amount,\n         self.as_array()[15] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sra_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sra_epi16)\n\n\n [`VPSRAW (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAW_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAW_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAW_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> I16x16 {
        if amount >= 16 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I16x16::from(out)
        } else {
            I16x16::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
                self.as_array()[8] >> amount,
                self.as_array()[9] >> amount,
                self.as_array()[10] >> amount,
                self.as_array()[11] >> amount,
                self.as_array()[12] >> amount,
                self.as_array()[13] >> amount,
                self.as_array()[14] >> amount,
                self.as_array()[15] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I16x16> for I16x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I16x16) {
        *self = (*self) >> amount;
    }
}
impl Shr<I16x16> for I16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I16x16  ,\n # )  -> I16x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I16x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: I16x16) -> I16x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I16x16::from(out)
    }
}
impl SimdBase<i16> for I16x16 {
    type Array = [i16; 16];
    type Signed = I16x16;
    type Unsigned = U16x16;
    const LANES: usize = 16;
    const ZERO: Self = { Self([0; 16]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i16  ,\n # )  -> I16x16\n # {\n let mut out = [0; 16];\n out[0] = scalar;\n I16x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i16) -> I16x16 {
        let mut out = [0; 16];
        out[0] = scalar;
        I16x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i16\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i16 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i16  ,\n # )  -> I16x16\n # {\n I16x16::from([scalar; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i16) -> I16x16 {
        I16x16::from([scalar; 16])
    }
    type BroadcastLoInput = I16x8;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I16x8  ,\n # )  -> I16x16\n # {\n I16x16::from([vector.as_array()[0]; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastw_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastw_epi16)\n\n\n [`VPBROADCASTW (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I16x8) -> I16x16 {
        I16x16::from([vector.as_array()[0]; 16])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  -1  } else { 0 },\n     if self.as_array()[8] == other.as_array()[8] {  -1  } else { 0 },\n     if self.as_array()[9] == other.as_array()[9] {  -1  } else { 0 },\n     if self.as_array()[10] == other.as_array()[10] {  -1  } else { 0 },\n     if self.as_array()[11] == other.as_array()[11] {  -1  } else { 0 },\n     if self.as_array()[12] == other.as_array()[12] {  -1  } else { 0 },\n     if self.as_array()[13] == other.as_array()[13] {  -1  } else { 0 },\n     if self.as_array()[14] == other.as_array()[14] {  -1  } else { 0 },\n     if self.as_array()[15] == other.as_array()[15] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi16)\n\n\n [`VPCMPEQW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I16x16) -> I16x16 {
        I16x16::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                -1
            } else {
                0
            },
            if self.as_array()[8] == other.as_array()[8] {
                -1
            } else {
                0
            },
            if self.as_array()[9] == other.as_array()[9] {
                -1
            } else {
                0
            },
            if self.as_array()[10] == other.as_array()[10] {
                -1
            } else {
                0
            },
            if self.as_array()[11] == other.as_array()[11] {
                -1
            } else {
                0
            },
            if self.as_array()[12] == other.as_array()[12] {
                -1
            } else {
                0
            },
            if self.as_array()[13] == other.as_array()[13] {
                -1
            } else {
                0
            },
            if self.as_array()[14] == other.as_array()[14] {
                -1
            } else {
                0
            },
            if self.as_array()[15] == other.as_array()[15] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  -1  } else { 0 },\n     if self.as_array()[8] > other.as_array()[8] {  -1  } else { 0 },\n     if self.as_array()[9] > other.as_array()[9] {  -1  } else { 0 },\n     if self.as_array()[10] > other.as_array()[10] {  -1  } else { 0 },\n     if self.as_array()[11] > other.as_array()[11] {  -1  } else { 0 },\n     if self.as_array()[12] > other.as_array()[12] {  -1  } else { 0 },\n     if self.as_array()[13] > other.as_array()[13] {  -1  } else { 0 },\n     if self.as_array()[14] > other.as_array()[14] {  -1  } else { 0 },\n     if self.as_array()[15] > other.as_array()[15] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpgt_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpgt_epi16)\n\n\n [`VPCMPGTW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html): Compare Packed Signed Integers for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I16x16) -> I16x16 {
        I16x16::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                -1
            } else {
                0
            },
            if self.as_array()[8] > other.as_array()[8] {
                -1
            } else {
                0
            },
            if self.as_array()[9] > other.as_array()[9] {
                -1
            } else {
                0
            },
            if self.as_array()[10] > other.as_array()[10] {
                -1
            } else {
                0
            },
            if self.as_array()[11] > other.as_array()[11] {
                -1
            } else {
                0
            },
            if self.as_array()[12] > other.as_array()[12] {
                -1
            } else {
                0
            },
            if self.as_array()[13] > other.as_array()[13] {
                -1
            } else {
                0
            },
            if self.as_array()[14] > other.as_array()[14] {
                -1
            } else {
                0
            },
            if self.as_array()[15] > other.as_array()[15] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I16x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_epi16)\n\n\n [`VPSLLW (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I16x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I16x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I16x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I16x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srai_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srai_epi16)\n\n\n [`VPSRAW (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAW_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAW_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAW_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I16x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I16x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     // Lane# 1\n     self.as_array()[8],\n     other.as_array()[8],\n     self.as_array()[9],\n     other.as_array()[9],\n     self.as_array()[10],\n     other.as_array()[10],\n     self.as_array()[11],\n     other.as_array()[11],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi16)\n\n\n [`VPUNPCKLWD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLWD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLWD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLWD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I16x16) -> I16x16 {
        I16x16::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3], // Lane# 1
            self.as_array()[8],
            other.as_array()[8],
            self.as_array()[9],
            other.as_array()[9],
            self.as_array()[10],
            other.as_array()[10],
            self.as_array()[11],
            other.as_array()[11],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     // Lane# 0\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n     // Lane# 1\n     self.as_array()[12],\n     other.as_array()[12],\n     self.as_array()[13],\n     other.as_array()[13],\n     self.as_array()[14],\n     other.as_array()[14],\n     self.as_array()[15],\n     other.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi16)\n\n\n [`VPUNPCKHWD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHWD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHWD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHWD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I16x16) -> I16x16 {
        I16x16::from([
            // Lane# 0
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7], // Lane# 1
            self.as_array()[12],
            other.as_array()[12],
            self.as_array()[13],
            other.as_array()[13],
            self.as_array()[14],
            other.as_array()[14],
            self.as_array()[15],
            other.as_array()[15],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n     self.as_array()[8].max(other.as_array()[8]),\n     self.as_array()[9].max(other.as_array()[9]),\n     self.as_array()[10].max(other.as_array()[10]),\n     self.as_array()[11].max(other.as_array()[11]),\n     self.as_array()[12].max(other.as_array()[12]),\n     self.as_array()[13].max(other.as_array()[13]),\n     self.as_array()[14].max(other.as_array()[14]),\n     self.as_array()[15].max(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_max_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_max_epi16)\n\n\n [`VPMAXSW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html): Maximum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
            self.as_array()[8].max(other.as_array()[8]),
            self.as_array()[9].max(other.as_array()[9]),
            self.as_array()[10].max(other.as_array()[10]),
            self.as_array()[11].max(other.as_array()[11]),
            self.as_array()[12].max(other.as_array()[12]),
            self.as_array()[13].max(other.as_array()[13]),
            self.as_array()[14].max(other.as_array()[14]),
            self.as_array()[15].max(other.as_array()[15]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # ;}\n # impl SomeTraitForDoc for I16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I16x16  ,\n # )  -> I16x16\n # {\n I16x16::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n     self.as_array()[8].min(other.as_array()[8]),\n     self.as_array()[9].min(other.as_array()[9]),\n     self.as_array()[10].min(other.as_array()[10]),\n     self.as_array()[11].min(other.as_array()[11]),\n     self.as_array()[12].min(other.as_array()[12]),\n     self.as_array()[13].min(other.as_array()[13]),\n     self.as_array()[14].min(other.as_array()[14]),\n     self.as_array()[15].min(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_min_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_min_epi16)\n\n\n [`VPMINSW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMINSB:PMINSW.html): Minimum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: I16x16) -> I16x16 {
        I16x16::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
            self.as_array()[8].min(other.as_array()[8]),
            self.as_array()[9].min(other.as_array()[9]),
            self.as_array()[10].min(other.as_array()[10]),
            self.as_array()[11].min(other.as_array()[11]),
            self.as_array()[12].min(other.as_array()[12]),
            self.as_array()[13].min(other.as_array()[13]),
            self.as_array()[14].min(other.as_array()[14]),
            self.as_array()[15].min(other.as_array()[15]),
        ])
    }
}
type I32x4Internal = [i32; 4];
#[doc = "`[i32; 4]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I32x4(I32x4Internal);
unsafe impl bytemuck::Pod for I32x4 {}
unsafe impl bytemuck::Zeroable for I32x4 {}
impl PartialEq for I32x4 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I32x4 {}
impl Default for I32x4 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I32x4 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I32x4 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I32x4({:?})", <[i32; 4]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i32> for I32x4 {}
impl BitXorAssign for I32x4 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
        ])
    }
}
impl BitOrAssign for I32x4 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
        ])
    }
}
impl BitAndAssign for I32x4 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
        ])
    }
}
impl AddAssign for I32x4 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi32)\n\n\n [`PADDD (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
        ])
    }
}
impl SubAssign for I32x4 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi32)\n\n\n [`PSUBD (XMM, XMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
        ])
    }
}
impl I32x4 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I32x4Internal) -> Self {
        Self(x)
    }
}
impl From<[i32; 4]> for I32x4 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i32; 4]) -> I32x4 {
        I32x4(array)
    }
}
impl From<I32x4> for [i32; 4] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I32x4) -> [i32; 4] {
        vector.0
    }
}
impl From<I8x16> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: I8x16) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: I16x8) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: I64x2) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: U8x16) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: U16x8) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: U32x4) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for I32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of I32x4."]
    #[inline(always)]
    fn from(x: U64x2) -> I32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i32, i32, I32x4> for I32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i32gather_epi32)\n\n\n [`VPGATHERDD (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i32, indices: I32x4) -> I32x4 {
        I32x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : I32x4  ,\n #         mask  : I32x4  ,\n #         src  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     if ((mask.as_array()[0] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mask_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_i32gather_epi32)\n\n\n [`VPGATHERDD (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i32, indices: I32x4, mask: I32x4, src: I32x4) -> I32x4 {
        I32x4::from([
            if ((mask.as_array()[0] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i32, u64, U64x4> for I32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : U64x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i32, indices: U64x4) -> I32x4 {
        I32x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : U64x4  ,\n #         mask  : I32x4  ,\n #         src  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     if ((mask.as_array()[0] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i32, indices: U64x4, mask: I32x4, src: I32x4) -> I32x4 {
        I32x4::from([
            if ((mask.as_array()[0] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i32, i64, I64x4> for I32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : I64x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i32, indices: I64x4) -> I32x4 {
        I32x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : I64x4  ,\n #         mask  : I32x4  ,\n #         src  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     if ((mask.as_array()[0] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i32, indices: I64x4, mask: I32x4, src: I32x4) -> I32x4 {
        I32x4::from([
            if ((mask.as_array()[0] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for I32x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x4\n # {\n if amount >= 32 {\n     I32x4::ZERO\n } else {\n     I32x4::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sll_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sll_epi32)\n\n\n [`PSLLD (XMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> I32x4 {
        if amount >= 32 {
            I32x4::ZERO
        } else {
            I32x4::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I32x4> for I32x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I32x4) {
        *self = (*self) << amount;
    }
}
impl Shl<I32x4> for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x4  ,\n # )  -> I32x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sllv_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sllv_epi32)\n\n\n [`VPSLLVD (XMM, XMM, XMM)`](https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html): Variable Bit Shift Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_XMM_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_XMM_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_XMM_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: I32x4) -> I32x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 || amm < 0 { 0 } else { *x << amm };
        }
        I32x4::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I32x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x4\n # {\n if amount >= 32 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I32x4::from(out)\n } else {\n     I32x4::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sra_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sra_epi32)\n\n\n [`PSRAD (XMM, XMM)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> I32x4 {
        if amount >= 32 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I32x4::from(out)
        } else {
            I32x4::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I32x4> for I32x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I32x4) {
        *self = (*self) >> amount;
    }
}
impl Shr<I32x4> for I32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x4  ,\n # )  -> I32x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srav_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srav_epi32)\n\n\n [`VPSRAVD (XMM, XMM, XMM)`](https://felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html): Variable Bit Shift Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAVD_XMM_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAVD_XMM_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAVD_XMM_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: I32x4) -> I32x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I32x4::from(out)
    }
}
impl SimdBase<i32> for I32x4 {
    type Array = [i32; 4];
    type Signed = I32x4;
    type Unsigned = U32x4;
    const LANES: usize = 4;
    const ZERO: Self = { Self([0; 4]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i32  ,\n # )  -> I32x4\n # {\n let mut out = [0; 4];\n out[0] = scalar;\n I32x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i32) -> I32x4 {
        let mut out = [0; 4];
        out[0] = scalar;
        I32x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i32\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i32\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi32)\n\n\n [`PEXTRD (R32, XMM, I8)`](https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html): Extract Byte/Dword/Qword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRD_R32_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRD_R32_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRD_R32_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i32 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i32  ,\n # )  -> I32x4\n # {\n I32x4::from([scalar; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i32) -> I32x4 {
        I32x4::from([scalar; 4])
    }
    type BroadcastLoInput = I32x4;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([vector.as_array()[0]; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastd_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastd_epi32)\n\n\n [`VPBROADCASTD (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I32x4) -> I32x4 {
        I32x4::from([vector.as_array()[0]; 4])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi32)\n\n\n [`PCMPEQD (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I32x4) -> I32x4 {
        I32x4::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpgt_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpgt_epi32)\n\n\n [`PCMPGTD (XMM, XMM)`](https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html): Compare Packed Signed Integers for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I32x4) -> I32x4 {
        I32x4::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_epi32)\n\n\n [`PSLLD (XMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I32x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I32x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srai_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srai_epi32)\n\n\n [`PSRAD (XMM, I8)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAD_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAD_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRAD_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I32x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I32x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi32)\n\n\n [`PUNPCKLDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I32x4) -> I32x4 {
        I32x4::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     // Lane# 0\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi32)\n\n\n [`PUNPCKHDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I32x4) -> I32x4 {
        I32x4::from([
            // Lane# 0
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_max_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_max_epi32)\n\n\n [`PMAXSD (XMM, XMM)`](https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html): Maximum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXSD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_min_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_min_epi32)\n\n\n [`PMINSD (XMM, XMM)`](https://felixcloutier.com/x86/PMINSD:PMINSQ.html): Minimum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINSD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: I32x4) -> I32x4 {
        I32x4::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
        ])
    }
}
impl crate::SimdBase32<i32> for I32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x4\n # {\n I32x4::from([\n     // 128-bit Lane #0\n     self.as_array()[I0 + 0 * 4],\n     self.as_array()[I1 + 0 * 4],\n     self.as_array()[I2 + 0 * 4],\n     self.as_array()[I3 + 0 * 4],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_shuffle_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_shuffle_epi32)\n\n\n [`PSHUFD (XMM, XMM, I8)`](https://felixcloutier.com/x86/PSHUFD.html): Shuffle Packed Doublewords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSHUFD_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSHUFD_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSHUFD_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shuffle<const I3: usize, const I2: usize, const I1: usize, const I0: usize>(&self) -> I32x4 {
        I32x4::from([
            // 128-bit Lane #0
            self.as_array()[I0 + 0 * 4],
            self.as_array()[I1 + 0 * 4],
            self.as_array()[I2 + 0 * 4],
            self.as_array()[I3 + 0 * 4],
        ])
    }
}
impl crate::SimdBase4x<i32> for I32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I32x4  ,\n # )  -> I32x4\n # ;}\n # impl SomeTraitForDoc for I32x4 {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I32x4  ,\n # )  -> I32x4\n # {\n I32x4::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_blend_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_blend_epi32)\n\n\n [`VPBLENDD (XMM, XMM, XMM, I8)`](https://felixcloutier.com/x86/VPBLENDD.html): Blend Packed Dwords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_XMM_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_XMM_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_XMM_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<const B3: bool, const B2: bool, const B1: bool, const B0: bool>(
        &self,
        if_true: I32x4,
    ) -> I32x4 {
        I32x4::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
        ])
    }
}
type I32x8Internal = [i32; 8];
#[doc = "`[i32; 8]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I32x8(I32x8Internal);
unsafe impl bytemuck::Pod for I32x8 {}
unsafe impl bytemuck::Zeroable for I32x8 {}
impl PartialEq for I32x8 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I32x8 {}
impl Default for I32x8 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I32x8 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I32x8 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I32x8({:?})", <[i32; 8]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i32> for I32x8 {}
impl BitXorAssign for I32x8 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
        ])
    }
}
impl BitOrAssign for I32x8 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
        ])
    }
}
impl BitAndAssign for I32x8 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
        ])
    }
}
impl AddAssign for I32x8 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi32)\n\n\n [`VPADDD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
        ])
    }
}
impl SubAssign for I32x8 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi32)\n\n\n [`VPSUBD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
        ])
    }
}
impl I32x8 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I32x8Internal) -> Self {
        Self(x)
    }
}
impl From<[i32; 8]> for I32x8 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i32; 8]) -> I32x8 {
        I32x8(array)
    }
}
impl From<I32x8> for [i32; 8] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I32x8) -> [i32; 8] {
        vector.0
    }
}
impl From<I8x32> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: I8x32) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x16> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: I16x16) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: I64x4) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: U8x32) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: U16x16) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: U32x8) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for I32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of I32x8."]
    #[inline(always)]
    fn from(x: U64x4) -> I32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for I32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I16x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n         i32::from(vector.as_array()[0]),\n         i32::from(vector.as_array()[1]),\n         i32::from(vector.as_array()[2]),\n         i32::from(vector.as_array()[3]),\n         i32::from(vector.as_array()[4]),\n         i32::from(vector.as_array()[5]),\n         i32::from(vector.as_array()[6]),\n         i32::from(vector.as_array()[7]),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cvtepi16_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepi16_epi32)\n\n\n [`VPMOVSXWD (YMM, XMM)`](https://felixcloutier.com/x86/PMOVSX.html): Packed Move with Sign Extend\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXWD_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXWD_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXWD_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I16x8) -> I32x8 {
        I32x8::from([
            i32::from(vector.as_array()[0]),
            i32::from(vector.as_array()[1]),
            i32::from(vector.as_array()[2]),
            i32::from(vector.as_array()[3]),
            i32::from(vector.as_array()[4]),
            i32::from(vector.as_array()[5]),
            i32::from(vector.as_array()[6]),
            i32::from(vector.as_array()[7]),
        ])
    }
}
impl From<I32x4> for I32x8 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I32x4  ,\n # )  -> I32x8\n # {\n let mut out = [0; 8];\n out[0..4].copy_from_slice(&vector.as_array());\n I32x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I32x4) -> I32x8 {
        let mut out = [0; 8];
        out[0..4].copy_from_slice(&vector.as_array());
        I32x8::from(out)
    }
}
impl From<[I32x4; 2]> for I32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [I32x4; 2]  ,\n # )  -> I32x8\n # {\n let mut out = [0; 8];\n out[0..4].copy_from_slice(&vectors[0].as_array());\n out[4..].copy_from_slice(&vectors[1].as_array());\n I32x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [I32x4; 2]) -> I32x8 {
        let mut out = [0; 8];
        out[0..4].copy_from_slice(&vectors[0].as_array());
        out[4..].copy_from_slice(&vectors[1].as_array());
        I32x8::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<I32x8> for [I32x4; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I32x8  ,\n # )  -> [I32x4; 2]\n # {\n let mut lo = [0; 4];\n let mut hi = [0; 4];\n lo.copy_from_slice(&vector.as_array()[0..4]);\n hi.copy_from_slice(&vector.as_array()[4..]);\n [I32x4::from(lo), I32x4::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I32x8) -> [I32x4; 2] {
        let mut lo = [0; 4];
        let mut hi = [0; 4];
        lo.copy_from_slice(&vector.as_array()[0..4]);
        hi.copy_from_slice(&vector.as_array()[4..]);
        [I32x4::from(lo), I32x4::from(hi)]
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i32, i32, I32x8> for I32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n     base.offset(indices.as_array()[4] as isize).read_unaligned(),\n     base.offset(indices.as_array()[5] as isize).read_unaligned(),\n     base.offset(indices.as_array()[6] as isize).read_unaligned(),\n     base.offset(indices.as_array()[7] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i32gather_epi32)\n\n\n [`VPGATHERDD (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i32, indices: I32x8) -> I32x8 {
        I32x8::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
            base.offset(indices.as_array()[4] as isize).read_unaligned(),
            base.offset(indices.as_array()[5] as isize).read_unaligned(),
            base.offset(indices.as_array()[6] as isize).read_unaligned(),
            base.offset(indices.as_array()[7] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i32  ,\n #         indices  : I32x8  ,\n #         mask  : I32x8  ,\n #         src  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     if ((mask.as_array()[0] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n     if ((mask.as_array()[4] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[4] as isize).read_unaligned()\n     } else {\n         src.as_array()[4]\n     },\n     if ((mask.as_array()[5] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[5] as isize).read_unaligned()\n     } else {\n         src.as_array()[5]\n     },\n     if ((mask.as_array()[6] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[6] as isize).read_unaligned()\n     } else {\n         src.as_array()[6]\n     },\n     if ((mask.as_array()[7] as u32) >> 31) == 1 {\n         base.offset(indices.as_array()[7] as isize).read_unaligned()\n     } else {\n         src.as_array()[7]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i32gather_epi32)\n\n\n [`VPGATHERDD (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i32, indices: I32x8, mask: I32x8, src: I32x8) -> I32x8 {
        I32x8::from([
            if ((mask.as_array()[0] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
            if ((mask.as_array()[4] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[4] as isize).read_unaligned()
            } else {
                src.as_array()[4]
            },
            if ((mask.as_array()[5] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[5] as isize).read_unaligned()
            } else {
                src.as_array()[5]
            },
            if ((mask.as_array()[6] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[6] as isize).read_unaligned()
            } else {
                src.as_array()[6]
            },
            if ((mask.as_array()[7] as u32) >> 31) == 1 {
                base.offset(indices.as_array()[7] as isize).read_unaligned()
            } else {
                src.as_array()[7]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for I32x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x8\n # {\n if amount >= 32 {\n     I32x8::ZERO\n } else {\n     I32x8::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sll_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sll_epi32)\n\n\n [`VPSLLD (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> I32x8 {
        if amount >= 32 {
            I32x8::ZERO
        } else {
            I32x8::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I32x8> for I32x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I32x8) {
        *self = (*self) << amount;
    }
}
impl Shl<I32x8> for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x8  ,\n # )  -> I32x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sllv_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sllv_epi32)\n\n\n [`VPSLLVD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html): Variable Bit Shift Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: I32x8) -> I32x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 || amm < 0 { 0 } else { *x << amm };
        }
        I32x8::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I32x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I32x8\n # {\n if amount >= 32 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I32x8::from(out)\n } else {\n     I32x8::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sra_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sra_epi32)\n\n\n [`VPSRAD (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAD_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAD_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAD_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> I32x8 {
        if amount >= 32 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I32x8::from(out)
        } else {
            I32x8::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I32x8> for I32x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I32x8) {
        *self = (*self) >> amount;
    }
}
impl Shr<I32x8> for I32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I32x8  ,\n # )  -> I32x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srav_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srav_epi32)\n\n\n [`VPSRAVD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html): Variable Bit Shift Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAVD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAVD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAVD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: I32x8) -> I32x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I32x8::from(out)
    }
}
impl SimdBase<i32> for I32x8 {
    type Array = [i32; 8];
    type Signed = I32x8;
    type Unsigned = U32x8;
    const LANES: usize = 8;
    const ZERO: Self = { Self([0; 8]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i32  ,\n # )  -> I32x8\n # {\n let mut out = [0; 8];\n out[0] = scalar;\n I32x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i32) -> I32x8 {
        let mut out = [0; 8];
        out[0] = scalar;
        I32x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i32\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i32\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i32 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i32  ,\n # )  -> I32x8\n # {\n I32x8::from([scalar; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i32) -> I32x8 {
        I32x8::from([scalar; 8])
    }
    type BroadcastLoInput = I32x4;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I32x4  ,\n # )  -> I32x8\n # {\n I32x8::from([vector.as_array()[0]; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastd_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastd_epi32)\n\n\n [`VPBROADCASTD (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I32x4) -> I32x8 {
        I32x8::from([vector.as_array()[0]; 8])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi32)\n\n\n [`VPCMPEQD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I32x8) -> I32x8 {
        I32x8::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  -1  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  -1  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  -1  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpgt_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpgt_epi32)\n\n\n [`VPCMPGTD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html): Compare Packed Signed Integers for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I32x8) -> I32x8 {
        I32x8::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                -1
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                -1
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                -1
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_epi32)\n\n\n [`VPSLLD (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I32x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I32x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srai_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srai_epi32)\n\n\n [`VPSRAD (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html): Shift Packed Data Right Arithmetic\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAD_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAD_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRAD_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I32x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I32x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     // Lane# 1\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi32)\n\n\n [`VPUNPCKLDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I32x8) -> I32x8 {
        I32x8::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1], // Lane# 1
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     // Lane# 0\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     // Lane# 1\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi32)\n\n\n [`VPUNPCKHDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I32x8) -> I32x8 {
        I32x8::from([
            // Lane# 0
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3], // Lane# 1
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_max_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_max_epi32)\n\n\n [`VPMAXSD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html): Maximum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXSD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_min_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_min_epi32)\n\n\n [`VPMINSD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMINSD:PMINSQ.html): Minimum of Packed Signed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINSD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: I32x8) -> I32x8 {
        I32x8::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
        ])
    }
}
impl crate::SimdBase32<i32> for I32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I32x8\n # {\n I32x8::from([\n     // 128-bit Lane #0\n     self.as_array()[I0 + 0 * 4],\n     self.as_array()[I1 + 0 * 4],\n     self.as_array()[I2 + 0 * 4],\n     self.as_array()[I3 + 0 * 4],\n     // 128-bit Lane #1\n     self.as_array()[I0 + 1 * 4],\n     self.as_array()[I1 + 1 * 4],\n     self.as_array()[I2 + 1 * 4],\n     self.as_array()[I3 + 1 * 4],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_shuffle_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_shuffle_epi32)\n\n\n [`VPSHUFD (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSHUFD.html): Shuffle Packed Doublewords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSHUFD_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSHUFD_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSHUFD_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shuffle<const I3: usize, const I2: usize, const I1: usize, const I0: usize>(&self) -> I32x8 {
        I32x8::from([
            // 128-bit Lane #0
            self.as_array()[I0 + 0 * 4],
            self.as_array()[I1 + 0 * 4],
            self.as_array()[I2 + 0 * 4],
            self.as_array()[I3 + 0 * 4], // 128-bit Lane #1
            self.as_array()[I0 + 1 * 4],
            self.as_array()[I1 + 1 * 4],
            self.as_array()[I2 + 1 * 4],
            self.as_array()[I3 + 1 * 4],
        ])
    }
}
impl crate::SimdBase8x<i32> for I32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I32x8  ,\n # )  -> I32x8\n # ;}\n # impl SomeTraitForDoc for I32x8 {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I32x8  ,\n # )  -> I32x8\n # {\n I32x8::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n         (if B4 { if_true } else { *self }).as_array()[4],\n         (if B5 { if_true } else { *self }).as_array()[5],\n         (if B6 { if_true } else { *self }).as_array()[6],\n         (if B7 { if_true } else { *self }).as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_blend_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_blend_epi32)\n\n\n [`VPBLENDD (YMM, YMM, YMM, I8)`](https://felixcloutier.com/x86/VPBLENDD.html): Blend Packed Dwords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<
        const B7: bool,
        const B6: bool,
        const B5: bool,
        const B4: bool,
        const B3: bool,
        const B2: bool,
        const B1: bool,
        const B0: bool,
    >(
        &self,
        if_true: I32x8,
    ) -> I32x8 {
        I32x8::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
            (if B4 { if_true } else { *self }).as_array()[4],
            (if B5 { if_true } else { *self }).as_array()[5],
            (if B6 { if_true } else { *self }).as_array()[6],
            (if B7 { if_true } else { *self }).as_array()[7],
        ])
    }
}
type I64x2Internal = [i64; 2];
#[doc = "`[i64; 2]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I64x2(I64x2Internal);
unsafe impl bytemuck::Pod for I64x2 {}
unsafe impl bytemuck::Zeroable for I64x2 {}
impl PartialEq for I64x2 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I64x2 {}
impl Default for I64x2 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I64x2 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I64x2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I64x2({:?})", <[i64; 2]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i64> for I64x2 {}
impl BitXorAssign for I64x2 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
        ])
    }
}
impl BitOrAssign for I64x2 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
        ])
    }
}
impl BitAndAssign for I64x2 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
        ])
    }
}
impl AddAssign for I64x2 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi64)\n\n\n [`PADDQ (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
        ])
    }
}
impl SubAssign for I64x2 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi64)\n\n\n [`PSUBQ (XMM, XMM)`](https://felixcloutier.com/x86/PSUBQ.html): Subtract Packed Quadword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
        ])
    }
}
impl I64x2 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I64x2Internal) -> Self {
        Self(x)
    }
}
impl From<[i64; 2]> for I64x2 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i64; 2]) -> I64x2 {
        I64x2(array)
    }
}
impl From<I64x2> for [i64; 2] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I64x2) -> [i64; 2] {
        vector.0
    }
}
impl From<I8x16> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: I8x16) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: I16x8) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: I32x4) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: U8x16) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: U16x8) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: U32x4) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for I64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of I64x2."]
    #[inline(always)]
    fn from(x: U64x2) -> I64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i64, u64, U64x2> for I64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : U64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i64, indices: U64x2) -> I64x2 {
        I64x2::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : U64x2  ,\n #         mask  : I64x2  ,\n #         src  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     if ((mask.as_array()[0] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i64, indices: U64x2, mask: I64x2, src: I64x2) -> I64x2 {
        I64x2::from([
            if ((mask.as_array()[0] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i64, i64, I64x2> for I64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i64, indices: I64x2) -> I64x2 {
        I64x2::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : I64x2  ,\n #         mask  : I64x2  ,\n #         src  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     if ((mask.as_array()[0] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i64, indices: I64x2, mask: I64x2, src: I64x2) -> I64x2 {
        I64x2::from([
            if ((mask.as_array()[0] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for I64x2 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x2\n # {\n if amount >= 64 {\n     I64x2::ZERO\n } else {\n     I64x2::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: u64) -> I64x2 {
        if amount >= 64 {
            I64x2::ZERO
        } else {
            I64x2::from([self.as_array()[0] << amount, self.as_array()[1] << amount])
        }
    }
} // Variable shift
impl ShlAssign<I64x2> for I64x2 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I64x2) {
        *self = (*self) << amount;
    }
}
impl Shl<I64x2> for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x2  ,\n # )  -> I64x2\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I64x2::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: I64x2) -> I64x2 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 || amm < 0 { 0 } else { *x << amm };
        }
        I64x2::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I64x2 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x2\n # {\n if amount >= 64 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I64x2::from(out)\n } else {\n     I64x2::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: u64) -> I64x2 {
        if amount >= 64 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I64x2::from(out)
        } else {
            I64x2::from([self.as_array()[0] >> amount, self.as_array()[1] >> amount])
        }
    }
} // Variable shift
impl ShrAssign<I64x2> for I64x2 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I64x2) {
        *self = (*self) >> amount;
    }
}
impl Shr<I64x2> for I64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x2  ,\n # )  -> I64x2\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I64x2::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: I64x2) -> I64x2 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I64x2::from(out)
    }
}
impl SimdBase<i64> for I64x2 {
    type Array = [i64; 2];
    type Signed = I64x2;
    type Unsigned = U64x2;
    const LANES: usize = 2;
    const ZERO: Self = { Self([0; 2]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i64  ,\n # )  -> I64x2\n # {\n let mut out = [0; 2];\n out[0] = scalar;\n I64x2::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i64) -> I64x2 {
        let mut out = [0; 2];
        out[0] = scalar;
        I64x2::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i64\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i64\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi64)\n\n\n [`PEXTRQ (R64, XMM, I8)`](https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html): Extract Byte/Dword/Qword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRQ_R64_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRQ_R64_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRQ_R64_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i64 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i64  ,\n # )  -> I64x2\n # {\n I64x2::from([scalar; 2])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i64) -> I64x2 {
        I64x2::from([scalar; 2])
    }
    type BroadcastLoInput = I64x2;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([vector.as_array()[0]; 2])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastq_epi64)\n\n\n [`VPBROADCASTQ (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I64x2) -> I64x2 {
        I64x2::from([vector.as_array()[0]; 2])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi64)\n\n\n [`PCMPEQQ (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQQ.html): Compare Packed Qword Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpgt_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpgt_epi64)\n\n\n [`PCMPGTQ (XMM, XMM)`](https://felixcloutier.com/x86/PCMPGTQ.html): Compare Packed Data for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;3]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;3]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPGTQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;3]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x2\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I64x2::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_epi64)\n\n\n [`PSLLQ (XMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I64x2 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I64x2::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x2\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I64x2::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I64x2 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I64x2::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi64)\n\n\n [`PUNPCKLQDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLQDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLQDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLQDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     // Lane# 0\n     self.as_array()[1],\n     other.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi64)\n\n\n [`PUNPCKHQDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHQDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHQDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHQDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            // Lane# 0
            self.as_array()[1],
            other.as_array()[1],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn max(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn min(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
        ])
    }
}
impl crate::SimdBase64<i64> for I64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # ;}\n # impl SomeTraitForDoc for I64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x2  ,\n # )  -> I64x2\n # {\n I64x2::from([\n     ((self.as_array()[0] as i32) as i64) * ((other.as_array()[0] as i32) as i64),\n     ((self.as_array()[1] as i32) as i64) * ((other.as_array()[1] as i32) as i64),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mul_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mul_epi32)\n\n\n [`PMULDQ (XMM, XMM)`](https://felixcloutier.com/x86/PMULDQ.html): Multiply Packed Doubleword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMULDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMULDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMULDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn mul_lo(&self, other: I64x2) -> I64x2 {
        I64x2::from([
            ((self.as_array()[0] as i32) as i64) * ((other.as_array()[0] as i32) as i64),
            ((self.as_array()[1] as i32) as i64) * ((other.as_array()[1] as i32) as i64),
        ])
    }
}
type I64x4Internal = [i64; 4];
#[doc = "`[i64; 4]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct I64x4(I64x4Internal);
unsafe impl bytemuck::Pod for I64x4 {}
unsafe impl bytemuck::Zeroable for I64x4 {}
impl PartialEq for I64x4 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for I64x4 {}
impl Default for I64x4 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for I64x4 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for I64x4 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "I64x4({:?})", <[i64; 4]>::from(*self))
    }
}
impl crate::SimdBaseSigned<i64> for I64x4 {}
impl BitXorAssign for I64x4 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
        ])
    }
}
impl BitOrAssign for I64x4 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
        ])
    }
}
impl BitAndAssign for I64x4 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
        ])
    }
}
impl AddAssign for I64x4 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi64)\n\n\n [`VPADDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
        ])
    }
}
impl SubAssign for I64x4 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi64)\n\n\n [`VPSUBQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBQ.html): Subtract Packed Quadword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
        ])
    }
}
impl I64x4 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: I64x4Internal) -> Self {
        Self(x)
    }
}
impl From<[i64; 4]> for I64x4 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [i64; 4]) -> I64x4 {
        I64x4(array)
    }
}
impl From<I64x4> for [i64; 4] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I64x4) -> [i64; 4] {
        vector.0
    }
}
impl From<I8x32> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: I8x32) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x16> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: I16x16) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: I32x8) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: U8x32) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: U16x16) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: U32x8) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for I64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of I64x4."]
    #[inline(always)]
    fn from(x: U64x4) -> I64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I32x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n         i64::from(vector.as_array()[0]),\n         i64::from(vector.as_array()[1]),\n         i64::from(vector.as_array()[2]),\n         i64::from(vector.as_array()[3]),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cvtepi32_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepi32_epi64)\n\n\n [`VPMOVSXDQ (YMM, XMM)`](https://felixcloutier.com/x86/PMOVSX.html): Packed Move with Sign Extend\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXDQ_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXDQ_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVSXDQ_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I32x4) -> I64x4 {
        I64x4::from([
            i64::from(vector.as_array()[0]),
            i64::from(vector.as_array()[1]),
            i64::from(vector.as_array()[2]),
            i64::from(vector.as_array()[3]),
        ])
    }
}
impl From<I64x2> for I64x4 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I64x2  ,\n # )  -> I64x4\n # {\n let mut out = [0; 4];\n out[0..2].copy_from_slice(&vector.as_array());\n I64x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I64x2) -> I64x4 {
        let mut out = [0; 4];
        out[0..2].copy_from_slice(&vector.as_array());
        I64x4::from(out)
    }
}
impl From<[I64x2; 2]> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [I64x2; 2]  ,\n # )  -> I64x4\n # {\n let mut out = [0; 4];\n out[0..2].copy_from_slice(&vectors[0].as_array());\n out[2..].copy_from_slice(&vectors[1].as_array());\n I64x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [I64x2; 2]) -> I64x4 {
        let mut out = [0; 4];
        out[0..2].copy_from_slice(&vectors[0].as_array());
        out[2..].copy_from_slice(&vectors[1].as_array());
        I64x4::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<I64x4> for [I64x2; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I64x4  ,\n # )  -> [I64x2; 2]\n # {\n let mut lo = [0; 2];\n let mut hi = [0; 2];\n lo.copy_from_slice(&vector.as_array()[0..2]);\n hi.copy_from_slice(&vector.as_array()[2..]);\n [I64x2::from(lo), I64x2::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: I64x4) -> [I64x2; 2] {
        let mut lo = [0; 2];
        let mut hi = [0; 2];
        lo.copy_from_slice(&vector.as_array()[0..2]);
        hi.copy_from_slice(&vector.as_array()[2..]);
        [I64x2::from(lo), I64x2::from(hi)]
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i64, i32, I32x4> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : I32x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i32gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i32gather_epi64)\n\n\n [`VPGATHERDQ (YMM, VSIB_XMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i64, indices: I32x4) -> I64x4 {
        I64x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : I32x4  ,\n #         mask  : I64x4  ,\n #         src  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     if ((mask.as_array()[0] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i32gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i32gather_epi64)\n\n\n [`VPGATHERDQ (YMM, VSIB_XMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i64, indices: I32x4, mask: I64x4, src: I64x4) -> I64x4 {
        I64x4::from([
            if ((mask.as_array()[0] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i64, u64, U64x4> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : U64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i64, indices: U64x4) -> I64x4 {
        I64x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : U64x4  ,\n #         mask  : I64x4  ,\n #         src  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     if ((mask.as_array()[0] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i64, indices: U64x4, mask: I64x4, src: I64x4) -> I64x4 {
        I64x4::from([
            if ((mask.as_array()[0] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<i64, i64, I64x4> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const i64, indices: I64x4) -> I64x4 {
        I64x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const i64  ,\n #         indices  : I64x4  ,\n #         mask  : I64x4  ,\n #         src  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     if ((mask.as_array()[0] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if ((mask.as_array()[1] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if ((mask.as_array()[2] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if ((mask.as_array()[3] as u64) >> 63) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const i64, indices: I64x4, mask: I64x4, src: I64x4) -> I64x4 {
        I64x4::from([
            if ((mask.as_array()[0] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if ((mask.as_array()[1] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if ((mask.as_array()[2] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if ((mask.as_array()[3] as u64) >> 63) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for I64x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x4\n # {\n if amount >= 64 {\n     I64x4::ZERO\n } else {\n     I64x4::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: u64) -> I64x4 {
        if amount >= 64 {
            I64x4::ZERO
        } else {
            I64x4::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<I64x4> for I64x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: I64x4) {
        *self = (*self) << amount;
    }
}
impl Shl<I64x4> for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x4  ,\n # )  -> I64x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64 || amm < 0 {\n         0\n     } else {\n         *x << amm\n     };\n }\n I64x4::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: I64x4) -> I64x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 || amm < 0 { 0 } else { *x << amm };
        }
        I64x4::from(out)
    }
} // Static shift
impl ShrAssign<u64> for I64x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> I64x4\n # {\n if amount >= 64 {\n     let mut out = self.as_array();\n     for x in out.iter_mut() {\n         *x = if *x < 0 { -1 } else { 0 };\n     }\n     I64x4::from(out)\n } else {\n     I64x4::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: u64) -> I64x4 {
        if amount >= 64 {
            let mut out = self.as_array();
            for x in out.iter_mut() {
                *x = if *x < 0 { -1 } else { 0 };
            }
            I64x4::from(out)
        } else {
            I64x4::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<I64x4> for I64x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: I64x4) {
        *self = (*self) >> amount;
    }
}
impl Shr<I64x4> for I64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : I64x4  ,\n # )  -> I64x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64 || amm < 0 {\n         if *x < 0 { -1 } else { 0 }\n     } else {\n         *x >> amm\n     };\n }\n I64x4::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: I64x4) -> I64x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 || amm < 0 {
                if *x < 0 {
                    -1
                } else {
                    0
                }
            } else {
                *x >> amm
            };
        }
        I64x4::from(out)
    }
}
impl SimdBase<i64> for I64x4 {
    type Array = [i64; 4];
    type Signed = I64x4;
    type Unsigned = U64x4;
    const LANES: usize = 4;
    const ZERO: Self = { Self([0; 4]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i64  ,\n # )  -> I64x4\n # {\n let mut out = [0; 4];\n out[0] = scalar;\n I64x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: i64) -> I64x4 {
        let mut out = [0; 4];
        out[0] = scalar;
        I64x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i64\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> i64\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi64)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> i64 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : i64  ,\n # )  -> I64x4\n # {\n I64x4::from([scalar; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: i64) -> I64x4 {
        I64x4::from([scalar; 4])
    }
    type BroadcastLoInput = I64x2;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : I64x2  ,\n # )  -> I64x4\n # {\n I64x4::from([vector.as_array()[0]; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastq_epi64)\n\n\n [`VPBROADCASTQ (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: I64x2) -> I64x4 {
        I64x4::from([vector.as_array()[0]; 4])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     if self.as_array()[0] == other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi64)\n\n\n [`VPCMPEQQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQQ.html): Compare Packed Qword Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            if self.as_array()[0] == other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     if self.as_array()[0] > other.as_array()[0] {  -1  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  -1  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  -1  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  -1  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpgt_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpgt_epi64)\n\n\n [`VPCMPGTQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPGTQ.html): Compare Packed Data for Greater Than\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;3]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;3]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPGTQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;3]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_gt(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            if self.as_array()[0] > other.as_array()[0] {
                -1
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                -1
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                -1
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                -1
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n I64x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_epi64)\n\n\n [`VPSLLQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> I64x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        I64x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n I64x4::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> I64x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        I64x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     // Lane# 1\n     self.as_array()[2],\n     other.as_array()[2],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi64)\n\n\n [`VPUNPCKLQDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLQDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLQDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLQDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0], // Lane# 1
            self.as_array()[2],
            other.as_array()[2],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     // Lane# 0\n     self.as_array()[1],\n     other.as_array()[1],\n     // Lane# 1\n     self.as_array()[3],\n     other.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi64)\n\n\n [`VPUNPCKHQDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHQDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHQDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHQDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            // Lane# 0
            self.as_array()[1],
            other.as_array()[1], // Lane# 1
            self.as_array()[3],
            other.as_array()[3],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn max(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn min(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
        ])
    }
}
impl crate::SimdBase4x<i64> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_blend_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_blend_epi32)\n\n\n [`VPBLENDD (YMM, YMM, YMM, I8)`](https://felixcloutier.com/x86/VPBLENDD.html): Blend Packed Dwords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<const B3: bool, const B2: bool, const B1: bool, const B0: bool>(
        &self,
        if_true: I64x4,
    ) -> I64x4 {
        I64x4::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
        ])
    }
}
impl crate::SimdBase64<i64> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : I64x4  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     ((self.as_array()[0] as i32) as i64) * ((other.as_array()[0] as i32) as i64),\n     ((self.as_array()[1] as i32) as i64) * ((other.as_array()[1] as i32) as i64),\n     ((self.as_array()[2] as i32) as i64) * ((other.as_array()[2] as i32) as i64),\n     ((self.as_array()[3] as i32) as i64) * ((other.as_array()[3] as i32) as i64),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mul_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mul_epi32)\n\n\n [`VPMULDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMULDQ.html): Multiply Packed Doubleword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMULDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMULDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMULDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn mul_lo(&self, other: I64x4) -> I64x4 {
        I64x4::from([
            ((self.as_array()[0] as i32) as i64) * ((other.as_array()[0] as i32) as i64),
            ((self.as_array()[1] as i32) as i64) * ((other.as_array()[1] as i32) as i64),
            ((self.as_array()[2] as i32) as i64) * ((other.as_array()[2] as i32) as i64),
            ((self.as_array()[3] as i32) as i64) * ((other.as_array()[3] as i32) as i64),
        ])
    }
}
impl crate::SimdBase4x64<i64> for I64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x4\n # ;}\n # impl SomeTraitForDoc for I64x4 {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> I64x4\n # {\n I64x4::from([\n     self.as_array()[I0],\n     self.as_array()[I1],\n     self.as_array()[I2],\n     self.as_array()[I3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_permute4x64_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_permute4x64_epi64)\n\n\n [`VPERMQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/VPERMQ.html): Qwords Element Permutation\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPERMQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPERMQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPERMQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shuffle<const I3: usize, const I2: usize, const I1: usize, const I0: usize>(&self) -> I64x4 {
        I64x4::from([
            self.as_array()[I0],
            self.as_array()[I1],
            self.as_array()[I2],
            self.as_array()[I3],
        ])
    }
}
type U8x16Internal = [u8; 16];
#[doc = "`[u8; 16]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U8x16(U8x16Internal);
unsafe impl bytemuck::Pod for U8x16 {}
unsafe impl bytemuck::Zeroable for U8x16 {}
impl PartialEq for U8x16 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U8x16 {}
impl Default for U8x16 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U8x16 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U8x16 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U8x16({:?})", <[u8; 16]>::from(*self))
    }
}
impl BitXorAssign for U8x16 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n     self.as_array()[8] ^ rhs.as_array()[8],\n     self.as_array()[9] ^ rhs.as_array()[9],\n     self.as_array()[10] ^ rhs.as_array()[10],\n     self.as_array()[11] ^ rhs.as_array()[11],\n     self.as_array()[12] ^ rhs.as_array()[12],\n     self.as_array()[13] ^ rhs.as_array()[13],\n     self.as_array()[14] ^ rhs.as_array()[14],\n     self.as_array()[15] ^ rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
            self.as_array()[8] ^ rhs.as_array()[8],
            self.as_array()[9] ^ rhs.as_array()[9],
            self.as_array()[10] ^ rhs.as_array()[10],
            self.as_array()[11] ^ rhs.as_array()[11],
            self.as_array()[12] ^ rhs.as_array()[12],
            self.as_array()[13] ^ rhs.as_array()[13],
            self.as_array()[14] ^ rhs.as_array()[14],
            self.as_array()[15] ^ rhs.as_array()[15],
        ])
    }
}
impl BitOrAssign for U8x16 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n     self.as_array()[8] | rhs.as_array()[8],\n     self.as_array()[9] | rhs.as_array()[9],\n     self.as_array()[10] | rhs.as_array()[10],\n     self.as_array()[11] | rhs.as_array()[11],\n     self.as_array()[12] | rhs.as_array()[12],\n     self.as_array()[13] | rhs.as_array()[13],\n     self.as_array()[14] | rhs.as_array()[14],\n     self.as_array()[15] | rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
            self.as_array()[8] | rhs.as_array()[8],
            self.as_array()[9] | rhs.as_array()[9],
            self.as_array()[10] | rhs.as_array()[10],
            self.as_array()[11] | rhs.as_array()[11],
            self.as_array()[12] | rhs.as_array()[12],
            self.as_array()[13] | rhs.as_array()[13],
            self.as_array()[14] | rhs.as_array()[14],
            self.as_array()[15] | rhs.as_array()[15],
        ])
    }
}
impl BitAndAssign for U8x16 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n     self.as_array()[8] & rhs.as_array()[8],\n     self.as_array()[9] & rhs.as_array()[9],\n     self.as_array()[10] & rhs.as_array()[10],\n     self.as_array()[11] & rhs.as_array()[11],\n     self.as_array()[12] & rhs.as_array()[12],\n     self.as_array()[13] & rhs.as_array()[13],\n     self.as_array()[14] & rhs.as_array()[14],\n     self.as_array()[15] & rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
            self.as_array()[8] & rhs.as_array()[8],
            self.as_array()[9] & rhs.as_array()[9],
            self.as_array()[10] & rhs.as_array()[10],
            self.as_array()[11] & rhs.as_array()[11],
            self.as_array()[12] & rhs.as_array()[12],
            self.as_array()[13] & rhs.as_array()[13],
            self.as_array()[14] & rhs.as_array()[14],
            self.as_array()[15] & rhs.as_array()[15],
        ])
    }
}
impl AddAssign for U8x16 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_add(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_add(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_add(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_add(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_add(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_add(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_add(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_add(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi8)\n\n\n [`PADDB (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
            self.as_array()[8].wrapping_add(rhs.as_array()[8]),
            self.as_array()[9].wrapping_add(rhs.as_array()[9]),
            self.as_array()[10].wrapping_add(rhs.as_array()[10]),
            self.as_array()[11].wrapping_add(rhs.as_array()[11]),
            self.as_array()[12].wrapping_add(rhs.as_array()[12]),
            self.as_array()[13].wrapping_add(rhs.as_array()[13]),
            self.as_array()[14].wrapping_add(rhs.as_array()[14]),
            self.as_array()[15].wrapping_add(rhs.as_array()[15]),
        ])
    }
}
impl SubAssign for U8x16 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_sub(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_sub(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_sub(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_sub(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_sub(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_sub(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_sub(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_sub(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi8)\n\n\n [`PSUBB (XMM, XMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
            self.as_array()[8].wrapping_sub(rhs.as_array()[8]),
            self.as_array()[9].wrapping_sub(rhs.as_array()[9]),
            self.as_array()[10].wrapping_sub(rhs.as_array()[10]),
            self.as_array()[11].wrapping_sub(rhs.as_array()[11]),
            self.as_array()[12].wrapping_sub(rhs.as_array()[12]),
            self.as_array()[13].wrapping_sub(rhs.as_array()[13]),
            self.as_array()[14].wrapping_sub(rhs.as_array()[14]),
            self.as_array()[15].wrapping_sub(rhs.as_array()[15]),
        ])
    }
}
impl U8x16 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U8x16Internal) -> Self {
        Self(x)
    }
}
impl From<[u8; 16]> for U8x16 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u8; 16]) -> U8x16 {
        U8x16(array)
    }
}
impl From<U8x16> for [u8; 16] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U8x16) -> [u8; 16] {
        vector.0
    }
}
impl From<I8x16> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: I8x16) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: I16x8) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: I32x4) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: I64x2) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: U16x8) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: U32x4) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for U8x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of U8x16."]
    #[inline(always)]
    fn from(x: U64x2) -> U8x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
} // Static shift
impl ShlAssign<u64> for U8x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x16\n # {\n if amount >= 8 {\n     U8x16::ZERO\n } else {\n     U8x16::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n         self.as_array()[8] << amount,\n         self.as_array()[9] << amount,\n         self.as_array()[10] << amount,\n         self.as_array()[11] << amount,\n         self.as_array()[12] << amount,\n         self.as_array()[13] << amount,\n         self.as_array()[14] << amount,\n         self.as_array()[15] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: u64) -> U8x16 {
        if amount >= 8 {
            U8x16::ZERO
        } else {
            U8x16::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
                self.as_array()[8] << amount,
                self.as_array()[9] << amount,
                self.as_array()[10] << amount,
                self.as_array()[11] << amount,
                self.as_array()[12] << amount,
                self.as_array()[13] << amount,
                self.as_array()[14] << amount,
                self.as_array()[15] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U8x16> for U8x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U8x16) {
        *self = (*self) << amount;
    }
}
impl Shl<U8x16> for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x16  ,\n # )  -> U8x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: U8x16) -> U8x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 { 0 } else { *x << amm };
        }
        U8x16::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U8x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x16\n # {\n if amount >= 8 {\n     U8x16::ZERO\n } else {\n     U8x16::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n         self.as_array()[8] >> amount,\n         self.as_array()[9] >> amount,\n         self.as_array()[10] >> amount,\n         self.as_array()[11] >> amount,\n         self.as_array()[12] >> amount,\n         self.as_array()[13] >> amount,\n         self.as_array()[14] >> amount,\n         self.as_array()[15] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: u64) -> U8x16 {
        if amount >= 8 {
            U8x16::ZERO
        } else {
            U8x16::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
                self.as_array()[8] >> amount,
                self.as_array()[9] >> amount,
                self.as_array()[10] >> amount,
                self.as_array()[11] >> amount,
                self.as_array()[12] >> amount,
                self.as_array()[13] >> amount,
                self.as_array()[14] >> amount,
                self.as_array()[15] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U8x16> for U8x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U8x16) {
        *self = (*self) >> amount;
    }
}
impl Shr<U8x16> for U8x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x16  ,\n # )  -> U8x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: U8x16) -> U8x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 { 0 } else { *x >> amm };
        }
        U8x16::from(out)
    }
}
impl SimdBase<u8> for U8x16 {
    type Array = [u8; 16];
    type Signed = I8x16;
    type Unsigned = U8x16;
    const LANES: usize = 16;
    const ZERO: Self = { Self([0; 16]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u8  ,\n # )  -> U8x16\n # {\n let mut out = [0; 16];\n out[0] = scalar;\n U8x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u8) -> U8x16 {
        let mut out = [0; 16];
        out[0] = scalar;
        U8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u8\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u8\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi8)\n\n\n [`PEXTRB (R32, XMM, I8)`](https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html): Extract Byte/Dword/Qword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRB_R32_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRB_R32_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRB_R32_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u8 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u8  ,\n # )  -> U8x16\n # {\n U8x16::from([scalar; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u8) -> U8x16 {
        U8x16::from([scalar; 16])
    }
    type BroadcastLoInput = U8x16;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([vector.as_array()[0]; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastb_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastb_epi8)\n\n\n [`VPBROADCASTB (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U8x16) -> U8x16 {
        U8x16::from([vector.as_array()[0]; 16])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     if self.as_array()[0] == other.as_array()[0] {  u8::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u8::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u8::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u8::MAX  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  u8::MAX  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  u8::MAX  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  u8::MAX  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  u8::MAX  } else { 0 },\n     if self.as_array()[8] == other.as_array()[8] {  u8::MAX  } else { 0 },\n     if self.as_array()[9] == other.as_array()[9] {  u8::MAX  } else { 0 },\n     if self.as_array()[10] == other.as_array()[10] {  u8::MAX  } else { 0 },\n     if self.as_array()[11] == other.as_array()[11] {  u8::MAX  } else { 0 },\n     if self.as_array()[12] == other.as_array()[12] {  u8::MAX  } else { 0 },\n     if self.as_array()[13] == other.as_array()[13] {  u8::MAX  } else { 0 },\n     if self.as_array()[14] == other.as_array()[14] {  u8::MAX  } else { 0 },\n     if self.as_array()[15] == other.as_array()[15] {  u8::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi8)\n\n\n [`PCMPEQB (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U8x16) -> U8x16 {
        U8x16::from([
            if self.as_array()[0] == other.as_array()[0] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[8] == other.as_array()[8] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[9] == other.as_array()[9] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[10] == other.as_array()[10] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[11] == other.as_array()[11] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[12] == other.as_array()[12] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[13] == other.as_array()[13] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[14] == other.as_array()[14] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[15] == other.as_array()[15] {
                u8::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     if self.as_array()[0] > other.as_array()[0] {  u8::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u8::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u8::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u8::MAX  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  u8::MAX  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  u8::MAX  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  u8::MAX  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  u8::MAX  } else { 0 },\n     if self.as_array()[8] > other.as_array()[8] {  u8::MAX  } else { 0 },\n     if self.as_array()[9] > other.as_array()[9] {  u8::MAX  } else { 0 },\n     if self.as_array()[10] > other.as_array()[10] {  u8::MAX  } else { 0 },\n     if self.as_array()[11] > other.as_array()[11] {  u8::MAX  } else { 0 },\n     if self.as_array()[12] > other.as_array()[12] {  u8::MAX  } else { 0 },\n     if self.as_array()[13] > other.as_array()[13] {  u8::MAX  } else { 0 },\n     if self.as_array()[14] > other.as_array()[14] {  u8::MAX  } else { 0 },\n     if self.as_array()[15] > other.as_array()[15] {  u8::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 7);\n Self::from(I8x16::from(*self ^ sign_bit).cmp_gt(\n     I8x16::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U8x16) -> U8x16 {
        U8x16::from([
            if self.as_array()[0] > other.as_array()[0] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[8] > other.as_array()[8] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[9] > other.as_array()[9] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[10] > other.as_array()[10] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[11] > other.as_array()[11] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[12] > other.as_array()[12] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[13] > other.as_array()[13] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[14] > other.as_array()[14] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[15] > other.as_array()[15] {
                u8::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U8x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U8x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U8x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi8)\n\n\n [`PUNPCKLBW (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLBW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLBW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLBW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U8x16) -> U8x16 {
        U8x16::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     // Lane# 0\n     self.as_array()[8],\n     other.as_array()[8],\n     self.as_array()[9],\n     other.as_array()[9],\n     self.as_array()[10],\n     other.as_array()[10],\n     self.as_array()[11],\n     other.as_array()[11],\n     self.as_array()[12],\n     other.as_array()[12],\n     self.as_array()[13],\n     other.as_array()[13],\n     self.as_array()[14],\n     other.as_array()[14],\n     self.as_array()[15],\n     other.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi8)\n\n\n [`PUNPCKHBW (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHBW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHBW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHBW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U8x16) -> U8x16 {
        U8x16::from([
            // Lane# 0
            self.as_array()[8],
            other.as_array()[8],
            self.as_array()[9],
            other.as_array()[9],
            self.as_array()[10],
            other.as_array()[10],
            self.as_array()[11],
            other.as_array()[11],
            self.as_array()[12],
            other.as_array()[12],
            self.as_array()[13],
            other.as_array()[13],
            self.as_array()[14],
            other.as_array()[14],
            self.as_array()[15],
            other.as_array()[15],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n     self.as_array()[8].max(other.as_array()[8]),\n     self.as_array()[9].max(other.as_array()[9]),\n     self.as_array()[10].max(other.as_array()[10]),\n     self.as_array()[11].max(other.as_array()[11]),\n     self.as_array()[12].max(other.as_array()[12]),\n     self.as_array()[13].max(other.as_array()[13]),\n     self.as_array()[14].max(other.as_array()[14]),\n     self.as_array()[15].max(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_max_epu8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_max_epu8)\n\n\n [`PMAXUB (XMM, XMM)`](https://felixcloutier.com/x86/PMAXUB:PMAXUW.html): Maximum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
            self.as_array()[8].max(other.as_array()[8]),
            self.as_array()[9].max(other.as_array()[9]),
            self.as_array()[10].max(other.as_array()[10]),
            self.as_array()[11].max(other.as_array()[11]),
            self.as_array()[12].max(other.as_array()[12]),
            self.as_array()[13].max(other.as_array()[13]),
            self.as_array()[14].max(other.as_array()[14]),
            self.as_array()[15].max(other.as_array()[15]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x16  ,\n # )  -> U8x16\n # {\n U8x16::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n     self.as_array()[8].min(other.as_array()[8]),\n     self.as_array()[9].min(other.as_array()[9]),\n     self.as_array()[10].min(other.as_array()[10]),\n     self.as_array()[11].min(other.as_array()[11]),\n     self.as_array()[12].min(other.as_array()[12]),\n     self.as_array()[13].min(other.as_array()[13]),\n     self.as_array()[14].min(other.as_array()[14]),\n     self.as_array()[15].min(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_min_epu8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_min_epu8)\n\n\n [`PMINUB (XMM, XMM)`](https://felixcloutier.com/x86/PMINUB:PMINUW.html): Minimum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: U8x16) -> U8x16 {
        U8x16::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
            self.as_array()[8].min(other.as_array()[8]),
            self.as_array()[9].min(other.as_array()[9]),
            self.as_array()[10].min(other.as_array()[10]),
            self.as_array()[11].min(other.as_array()[11]),
            self.as_array()[12].min(other.as_array()[12]),
            self.as_array()[13].min(other.as_array()[13]),
            self.as_array()[14].min(other.as_array()[14]),
            self.as_array()[15].min(other.as_array()[15]),
        ])
    }
}
impl crate::SimdBase8<u8> for U8x16 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # {\n let mut out = [0; 16];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);\n }\n U8x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_si128)\n\n\n [`PSLLDQ (XMM, I8)`](https://felixcloutier.com/x86/PSLLDQ.html): Shift Double Quadword Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLDQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLDQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLDQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_left<const AMOUNT: usize>(&self) -> U8x16 {
        let mut out = [0; 16];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);
        }
        U8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x16\n # {\n let mut out = [0; 16];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);\n }\n U8x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srli_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srli_si128)\n\n\n [`PSRLDQ (XMM, I8)`](https://felixcloutier.com/x86/PSRLDQ.html): Shift Double Quadword Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLDQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLDQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLDQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_right<const AMOUNT: usize>(&self) -> U8x16 {
        let mut out = [0; 16];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);
        }
        U8x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # ;}\n # impl SomeTraitForDoc for U8x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # {\n let mut out: u32 = 0;\n for (i, value) in self.as_array().iter().copied().enumerate() {\n     out |= u32::from((value as u8) >> 7) << i;\n }\n out\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_movemask_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_movemask_epi8)\n\n\n [`PMOVMSKB (R32, XMM)`](https://felixcloutier.com/x86/PMOVMSKB.html): Move Byte Mask\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMOVMSKB_R32_XMM.html#SKL\">Skylake</a></td>\n <td>&le;3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMOVMSKB_R32_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMOVMSKB_R32_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn most_significant_bits(&self) -> u32 {
        let mut out: u32 = 0;
        for (i, value) in self.as_array().iter().copied().enumerate() {
            out |= u32::from((value as u8) >> 7) << i;
        }
        out
    }
}
type U8x32Internal = [u8; 32];
#[doc = "`[u8; 32]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U8x32(U8x32Internal);
unsafe impl bytemuck::Pod for U8x32 {}
unsafe impl bytemuck::Zeroable for U8x32 {}
impl PartialEq for U8x32 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U8x32 {}
impl Default for U8x32 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U8x32 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U8x32 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U8x32({:?})", <[u8; 32]>::from(*self))
    }
}
impl BitXorAssign for U8x32 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n     self.as_array()[8] ^ rhs.as_array()[8],\n     self.as_array()[9] ^ rhs.as_array()[9],\n     self.as_array()[10] ^ rhs.as_array()[10],\n     self.as_array()[11] ^ rhs.as_array()[11],\n     self.as_array()[12] ^ rhs.as_array()[12],\n     self.as_array()[13] ^ rhs.as_array()[13],\n     self.as_array()[14] ^ rhs.as_array()[14],\n     self.as_array()[15] ^ rhs.as_array()[15],\n     self.as_array()[16] ^ rhs.as_array()[16],\n     self.as_array()[17] ^ rhs.as_array()[17],\n     self.as_array()[18] ^ rhs.as_array()[18],\n     self.as_array()[19] ^ rhs.as_array()[19],\n     self.as_array()[20] ^ rhs.as_array()[20],\n     self.as_array()[21] ^ rhs.as_array()[21],\n     self.as_array()[22] ^ rhs.as_array()[22],\n     self.as_array()[23] ^ rhs.as_array()[23],\n     self.as_array()[24] ^ rhs.as_array()[24],\n     self.as_array()[25] ^ rhs.as_array()[25],\n     self.as_array()[26] ^ rhs.as_array()[26],\n     self.as_array()[27] ^ rhs.as_array()[27],\n     self.as_array()[28] ^ rhs.as_array()[28],\n     self.as_array()[29] ^ rhs.as_array()[29],\n     self.as_array()[30] ^ rhs.as_array()[30],\n     self.as_array()[31] ^ rhs.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
            self.as_array()[8] ^ rhs.as_array()[8],
            self.as_array()[9] ^ rhs.as_array()[9],
            self.as_array()[10] ^ rhs.as_array()[10],
            self.as_array()[11] ^ rhs.as_array()[11],
            self.as_array()[12] ^ rhs.as_array()[12],
            self.as_array()[13] ^ rhs.as_array()[13],
            self.as_array()[14] ^ rhs.as_array()[14],
            self.as_array()[15] ^ rhs.as_array()[15],
            self.as_array()[16] ^ rhs.as_array()[16],
            self.as_array()[17] ^ rhs.as_array()[17],
            self.as_array()[18] ^ rhs.as_array()[18],
            self.as_array()[19] ^ rhs.as_array()[19],
            self.as_array()[20] ^ rhs.as_array()[20],
            self.as_array()[21] ^ rhs.as_array()[21],
            self.as_array()[22] ^ rhs.as_array()[22],
            self.as_array()[23] ^ rhs.as_array()[23],
            self.as_array()[24] ^ rhs.as_array()[24],
            self.as_array()[25] ^ rhs.as_array()[25],
            self.as_array()[26] ^ rhs.as_array()[26],
            self.as_array()[27] ^ rhs.as_array()[27],
            self.as_array()[28] ^ rhs.as_array()[28],
            self.as_array()[29] ^ rhs.as_array()[29],
            self.as_array()[30] ^ rhs.as_array()[30],
            self.as_array()[31] ^ rhs.as_array()[31],
        ])
    }
}
impl BitOrAssign for U8x32 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n     self.as_array()[8] | rhs.as_array()[8],\n     self.as_array()[9] | rhs.as_array()[9],\n     self.as_array()[10] | rhs.as_array()[10],\n     self.as_array()[11] | rhs.as_array()[11],\n     self.as_array()[12] | rhs.as_array()[12],\n     self.as_array()[13] | rhs.as_array()[13],\n     self.as_array()[14] | rhs.as_array()[14],\n     self.as_array()[15] | rhs.as_array()[15],\n     self.as_array()[16] | rhs.as_array()[16],\n     self.as_array()[17] | rhs.as_array()[17],\n     self.as_array()[18] | rhs.as_array()[18],\n     self.as_array()[19] | rhs.as_array()[19],\n     self.as_array()[20] | rhs.as_array()[20],\n     self.as_array()[21] | rhs.as_array()[21],\n     self.as_array()[22] | rhs.as_array()[22],\n     self.as_array()[23] | rhs.as_array()[23],\n     self.as_array()[24] | rhs.as_array()[24],\n     self.as_array()[25] | rhs.as_array()[25],\n     self.as_array()[26] | rhs.as_array()[26],\n     self.as_array()[27] | rhs.as_array()[27],\n     self.as_array()[28] | rhs.as_array()[28],\n     self.as_array()[29] | rhs.as_array()[29],\n     self.as_array()[30] | rhs.as_array()[30],\n     self.as_array()[31] | rhs.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
            self.as_array()[8] | rhs.as_array()[8],
            self.as_array()[9] | rhs.as_array()[9],
            self.as_array()[10] | rhs.as_array()[10],
            self.as_array()[11] | rhs.as_array()[11],
            self.as_array()[12] | rhs.as_array()[12],
            self.as_array()[13] | rhs.as_array()[13],
            self.as_array()[14] | rhs.as_array()[14],
            self.as_array()[15] | rhs.as_array()[15],
            self.as_array()[16] | rhs.as_array()[16],
            self.as_array()[17] | rhs.as_array()[17],
            self.as_array()[18] | rhs.as_array()[18],
            self.as_array()[19] | rhs.as_array()[19],
            self.as_array()[20] | rhs.as_array()[20],
            self.as_array()[21] | rhs.as_array()[21],
            self.as_array()[22] | rhs.as_array()[22],
            self.as_array()[23] | rhs.as_array()[23],
            self.as_array()[24] | rhs.as_array()[24],
            self.as_array()[25] | rhs.as_array()[25],
            self.as_array()[26] | rhs.as_array()[26],
            self.as_array()[27] | rhs.as_array()[27],
            self.as_array()[28] | rhs.as_array()[28],
            self.as_array()[29] | rhs.as_array()[29],
            self.as_array()[30] | rhs.as_array()[30],
            self.as_array()[31] | rhs.as_array()[31],
        ])
    }
}
impl BitAndAssign for U8x32 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n     self.as_array()[8] & rhs.as_array()[8],\n     self.as_array()[9] & rhs.as_array()[9],\n     self.as_array()[10] & rhs.as_array()[10],\n     self.as_array()[11] & rhs.as_array()[11],\n     self.as_array()[12] & rhs.as_array()[12],\n     self.as_array()[13] & rhs.as_array()[13],\n     self.as_array()[14] & rhs.as_array()[14],\n     self.as_array()[15] & rhs.as_array()[15],\n     self.as_array()[16] & rhs.as_array()[16],\n     self.as_array()[17] & rhs.as_array()[17],\n     self.as_array()[18] & rhs.as_array()[18],\n     self.as_array()[19] & rhs.as_array()[19],\n     self.as_array()[20] & rhs.as_array()[20],\n     self.as_array()[21] & rhs.as_array()[21],\n     self.as_array()[22] & rhs.as_array()[22],\n     self.as_array()[23] & rhs.as_array()[23],\n     self.as_array()[24] & rhs.as_array()[24],\n     self.as_array()[25] & rhs.as_array()[25],\n     self.as_array()[26] & rhs.as_array()[26],\n     self.as_array()[27] & rhs.as_array()[27],\n     self.as_array()[28] & rhs.as_array()[28],\n     self.as_array()[29] & rhs.as_array()[29],\n     self.as_array()[30] & rhs.as_array()[30],\n     self.as_array()[31] & rhs.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
            self.as_array()[8] & rhs.as_array()[8],
            self.as_array()[9] & rhs.as_array()[9],
            self.as_array()[10] & rhs.as_array()[10],
            self.as_array()[11] & rhs.as_array()[11],
            self.as_array()[12] & rhs.as_array()[12],
            self.as_array()[13] & rhs.as_array()[13],
            self.as_array()[14] & rhs.as_array()[14],
            self.as_array()[15] & rhs.as_array()[15],
            self.as_array()[16] & rhs.as_array()[16],
            self.as_array()[17] & rhs.as_array()[17],
            self.as_array()[18] & rhs.as_array()[18],
            self.as_array()[19] & rhs.as_array()[19],
            self.as_array()[20] & rhs.as_array()[20],
            self.as_array()[21] & rhs.as_array()[21],
            self.as_array()[22] & rhs.as_array()[22],
            self.as_array()[23] & rhs.as_array()[23],
            self.as_array()[24] & rhs.as_array()[24],
            self.as_array()[25] & rhs.as_array()[25],
            self.as_array()[26] & rhs.as_array()[26],
            self.as_array()[27] & rhs.as_array()[27],
            self.as_array()[28] & rhs.as_array()[28],
            self.as_array()[29] & rhs.as_array()[29],
            self.as_array()[30] & rhs.as_array()[30],
            self.as_array()[31] & rhs.as_array()[31],
        ])
    }
}
impl AddAssign for U8x32 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_add(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_add(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_add(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_add(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_add(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_add(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_add(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_add(rhs.as_array()[15]),\n     self.as_array()[16].wrapping_add(rhs.as_array()[16]),\n     self.as_array()[17].wrapping_add(rhs.as_array()[17]),\n     self.as_array()[18].wrapping_add(rhs.as_array()[18]),\n     self.as_array()[19].wrapping_add(rhs.as_array()[19]),\n     self.as_array()[20].wrapping_add(rhs.as_array()[20]),\n     self.as_array()[21].wrapping_add(rhs.as_array()[21]),\n     self.as_array()[22].wrapping_add(rhs.as_array()[22]),\n     self.as_array()[23].wrapping_add(rhs.as_array()[23]),\n     self.as_array()[24].wrapping_add(rhs.as_array()[24]),\n     self.as_array()[25].wrapping_add(rhs.as_array()[25]),\n     self.as_array()[26].wrapping_add(rhs.as_array()[26]),\n     self.as_array()[27].wrapping_add(rhs.as_array()[27]),\n     self.as_array()[28].wrapping_add(rhs.as_array()[28]),\n     self.as_array()[29].wrapping_add(rhs.as_array()[29]),\n     self.as_array()[30].wrapping_add(rhs.as_array()[30]),\n     self.as_array()[31].wrapping_add(rhs.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi8)\n\n\n [`VPADDB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
            self.as_array()[8].wrapping_add(rhs.as_array()[8]),
            self.as_array()[9].wrapping_add(rhs.as_array()[9]),
            self.as_array()[10].wrapping_add(rhs.as_array()[10]),
            self.as_array()[11].wrapping_add(rhs.as_array()[11]),
            self.as_array()[12].wrapping_add(rhs.as_array()[12]),
            self.as_array()[13].wrapping_add(rhs.as_array()[13]),
            self.as_array()[14].wrapping_add(rhs.as_array()[14]),
            self.as_array()[15].wrapping_add(rhs.as_array()[15]),
            self.as_array()[16].wrapping_add(rhs.as_array()[16]),
            self.as_array()[17].wrapping_add(rhs.as_array()[17]),
            self.as_array()[18].wrapping_add(rhs.as_array()[18]),
            self.as_array()[19].wrapping_add(rhs.as_array()[19]),
            self.as_array()[20].wrapping_add(rhs.as_array()[20]),
            self.as_array()[21].wrapping_add(rhs.as_array()[21]),
            self.as_array()[22].wrapping_add(rhs.as_array()[22]),
            self.as_array()[23].wrapping_add(rhs.as_array()[23]),
            self.as_array()[24].wrapping_add(rhs.as_array()[24]),
            self.as_array()[25].wrapping_add(rhs.as_array()[25]),
            self.as_array()[26].wrapping_add(rhs.as_array()[26]),
            self.as_array()[27].wrapping_add(rhs.as_array()[27]),
            self.as_array()[28].wrapping_add(rhs.as_array()[28]),
            self.as_array()[29].wrapping_add(rhs.as_array()[29]),
            self.as_array()[30].wrapping_add(rhs.as_array()[30]),
            self.as_array()[31].wrapping_add(rhs.as_array()[31]),
        ])
    }
}
impl SubAssign for U8x32 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_sub(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_sub(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_sub(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_sub(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_sub(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_sub(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_sub(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_sub(rhs.as_array()[15]),\n     self.as_array()[16].wrapping_sub(rhs.as_array()[16]),\n     self.as_array()[17].wrapping_sub(rhs.as_array()[17]),\n     self.as_array()[18].wrapping_sub(rhs.as_array()[18]),\n     self.as_array()[19].wrapping_sub(rhs.as_array()[19]),\n     self.as_array()[20].wrapping_sub(rhs.as_array()[20]),\n     self.as_array()[21].wrapping_sub(rhs.as_array()[21]),\n     self.as_array()[22].wrapping_sub(rhs.as_array()[22]),\n     self.as_array()[23].wrapping_sub(rhs.as_array()[23]),\n     self.as_array()[24].wrapping_sub(rhs.as_array()[24]),\n     self.as_array()[25].wrapping_sub(rhs.as_array()[25]),\n     self.as_array()[26].wrapping_sub(rhs.as_array()[26]),\n     self.as_array()[27].wrapping_sub(rhs.as_array()[27]),\n     self.as_array()[28].wrapping_sub(rhs.as_array()[28]),\n     self.as_array()[29].wrapping_sub(rhs.as_array()[29]),\n     self.as_array()[30].wrapping_sub(rhs.as_array()[30]),\n     self.as_array()[31].wrapping_sub(rhs.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi8)\n\n\n [`VPSUBB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
            self.as_array()[8].wrapping_sub(rhs.as_array()[8]),
            self.as_array()[9].wrapping_sub(rhs.as_array()[9]),
            self.as_array()[10].wrapping_sub(rhs.as_array()[10]),
            self.as_array()[11].wrapping_sub(rhs.as_array()[11]),
            self.as_array()[12].wrapping_sub(rhs.as_array()[12]),
            self.as_array()[13].wrapping_sub(rhs.as_array()[13]),
            self.as_array()[14].wrapping_sub(rhs.as_array()[14]),
            self.as_array()[15].wrapping_sub(rhs.as_array()[15]),
            self.as_array()[16].wrapping_sub(rhs.as_array()[16]),
            self.as_array()[17].wrapping_sub(rhs.as_array()[17]),
            self.as_array()[18].wrapping_sub(rhs.as_array()[18]),
            self.as_array()[19].wrapping_sub(rhs.as_array()[19]),
            self.as_array()[20].wrapping_sub(rhs.as_array()[20]),
            self.as_array()[21].wrapping_sub(rhs.as_array()[21]),
            self.as_array()[22].wrapping_sub(rhs.as_array()[22]),
            self.as_array()[23].wrapping_sub(rhs.as_array()[23]),
            self.as_array()[24].wrapping_sub(rhs.as_array()[24]),
            self.as_array()[25].wrapping_sub(rhs.as_array()[25]),
            self.as_array()[26].wrapping_sub(rhs.as_array()[26]),
            self.as_array()[27].wrapping_sub(rhs.as_array()[27]),
            self.as_array()[28].wrapping_sub(rhs.as_array()[28]),
            self.as_array()[29].wrapping_sub(rhs.as_array()[29]),
            self.as_array()[30].wrapping_sub(rhs.as_array()[30]),
            self.as_array()[31].wrapping_sub(rhs.as_array()[31]),
        ])
    }
}
impl U8x32 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U8x32Internal) -> Self {
        Self(x)
    }
}
impl From<[u8; 32]> for U8x32 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u8; 32]) -> U8x32 {
        U8x32(array)
    }
}
impl From<U8x32> for [u8; 32] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U8x32) -> [u8; 32] {
        vector.0
    }
}
impl From<I8x32> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: I8x32) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x16> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: I16x16) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: I32x8) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: I64x4) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: U16x16) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: U32x8) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for U8x32 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of U8x32."]
    #[inline(always)]
    fn from(x: U64x4) -> U8x32 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for U8x32 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U8x16  ,\n # )  -> U8x32\n # {\n let mut out = [0; 32];\n out[0..16].copy_from_slice(&vector.as_array());\n U8x32::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U8x16) -> U8x32 {
        let mut out = [0; 32];
        out[0..16].copy_from_slice(&vector.as_array());
        U8x32::from(out)
    }
}
impl From<[U8x16; 2]> for U8x32 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [U8x16; 2]  ,\n # )  -> U8x32\n # {\n let mut out = [0; 32];\n out[0..16].copy_from_slice(&vectors[0].as_array());\n out[16..].copy_from_slice(&vectors[1].as_array());\n U8x32::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [U8x16; 2]) -> U8x32 {
        let mut out = [0; 32];
        out[0..16].copy_from_slice(&vectors[0].as_array());
        out[16..].copy_from_slice(&vectors[1].as_array());
        U8x32::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<U8x32> for [U8x16; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U8x32  ,\n # )  -> [U8x16; 2]\n # {\n let mut lo = [0; 16];\n let mut hi = [0; 16];\n lo.copy_from_slice(&vector.as_array()[0..16]);\n hi.copy_from_slice(&vector.as_array()[16..]);\n [U8x16::from(lo), U8x16::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U8x32) -> [U8x16; 2] {
        let mut lo = [0; 16];
        let mut hi = [0; 16];
        lo.copy_from_slice(&vector.as_array()[0..16]);
        hi.copy_from_slice(&vector.as_array()[16..]);
        [U8x16::from(lo), U8x16::from(hi)]
    }
} // Static shift
impl ShlAssign<u64> for U8x32 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x32\n # {\n if amount >= 8 {\n     U8x32::ZERO\n } else {\n     U8x32::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n         self.as_array()[8] << amount,\n         self.as_array()[9] << amount,\n         self.as_array()[10] << amount,\n         self.as_array()[11] << amount,\n         self.as_array()[12] << amount,\n         self.as_array()[13] << amount,\n         self.as_array()[14] << amount,\n         self.as_array()[15] << amount,\n         self.as_array()[16] << amount,\n         self.as_array()[17] << amount,\n         self.as_array()[18] << amount,\n         self.as_array()[19] << amount,\n         self.as_array()[20] << amount,\n         self.as_array()[21] << amount,\n         self.as_array()[22] << amount,\n         self.as_array()[23] << amount,\n         self.as_array()[24] << amount,\n         self.as_array()[25] << amount,\n         self.as_array()[26] << amount,\n         self.as_array()[27] << amount,\n         self.as_array()[28] << amount,\n         self.as_array()[29] << amount,\n         self.as_array()[30] << amount,\n         self.as_array()[31] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: u64) -> U8x32 {
        if amount >= 8 {
            U8x32::ZERO
        } else {
            U8x32::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
                self.as_array()[8] << amount,
                self.as_array()[9] << amount,
                self.as_array()[10] << amount,
                self.as_array()[11] << amount,
                self.as_array()[12] << amount,
                self.as_array()[13] << amount,
                self.as_array()[14] << amount,
                self.as_array()[15] << amount,
                self.as_array()[16] << amount,
                self.as_array()[17] << amount,
                self.as_array()[18] << amount,
                self.as_array()[19] << amount,
                self.as_array()[20] << amount,
                self.as_array()[21] << amount,
                self.as_array()[22] << amount,
                self.as_array()[23] << amount,
                self.as_array()[24] << amount,
                self.as_array()[25] << amount,
                self.as_array()[26] << amount,
                self.as_array()[27] << amount,
                self.as_array()[28] << amount,
                self.as_array()[29] << amount,
                self.as_array()[30] << amount,
                self.as_array()[31] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U8x32> for U8x32 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U8x32) {
        *self = (*self) << amount;
    }
}
impl Shl<U8x32> for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x32  ,\n # )  -> U8x32\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: U8x32) -> U8x32 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 { 0 } else { *x << amm };
        }
        U8x32::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U8x32 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U8x32\n # {\n if amount >= 8 {\n     U8x32::ZERO\n } else {\n     U8x32::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n         self.as_array()[8] >> amount,\n         self.as_array()[9] >> amount,\n         self.as_array()[10] >> amount,\n         self.as_array()[11] >> amount,\n         self.as_array()[12] >> amount,\n         self.as_array()[13] >> amount,\n         self.as_array()[14] >> amount,\n         self.as_array()[15] >> amount,\n         self.as_array()[16] >> amount,\n         self.as_array()[17] >> amount,\n         self.as_array()[18] >> amount,\n         self.as_array()[19] >> amount,\n         self.as_array()[20] >> amount,\n         self.as_array()[21] >> amount,\n         self.as_array()[22] >> amount,\n         self.as_array()[23] >> amount,\n         self.as_array()[24] >> amount,\n         self.as_array()[25] >> amount,\n         self.as_array()[26] >> amount,\n         self.as_array()[27] >> amount,\n         self.as_array()[28] >> amount,\n         self.as_array()[29] >> amount,\n         self.as_array()[30] >> amount,\n         self.as_array()[31] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: u64) -> U8x32 {
        if amount >= 8 {
            U8x32::ZERO
        } else {
            U8x32::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
                self.as_array()[8] >> amount,
                self.as_array()[9] >> amount,
                self.as_array()[10] >> amount,
                self.as_array()[11] >> amount,
                self.as_array()[12] >> amount,
                self.as_array()[13] >> amount,
                self.as_array()[14] >> amount,
                self.as_array()[15] >> amount,
                self.as_array()[16] >> amount,
                self.as_array()[17] >> amount,
                self.as_array()[18] >> amount,
                self.as_array()[19] >> amount,
                self.as_array()[20] >> amount,
                self.as_array()[21] >> amount,
                self.as_array()[22] >> amount,
                self.as_array()[23] >> amount,
                self.as_array()[24] >> amount,
                self.as_array()[25] >> amount,
                self.as_array()[26] >> amount,
                self.as_array()[27] >> amount,
                self.as_array()[28] >> amount,
                self.as_array()[29] >> amount,
                self.as_array()[30] >> amount,
                self.as_array()[31] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U8x32> for U8x32 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U8x32) {
        *self = (*self) >> amount;
    }
}
impl Shr<U8x32> for U8x32 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U8x32  ,\n # )  -> U8x32\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 8  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: U8x32) -> U8x32 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 8 { 0 } else { *x >> amm };
        }
        U8x32::from(out)
    }
}
impl SimdBase<u8> for U8x32 {
    type Array = [u8; 32];
    type Signed = I8x32;
    type Unsigned = U8x32;
    const LANES: usize = 32;
    const ZERO: Self = { Self([0; 32]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u8  ,\n # )  -> U8x32\n # {\n let mut out = [0; 32];\n out[0] = scalar;\n U8x32::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u8) -> U8x32 {
        let mut out = [0; 32];
        out[0] = scalar;
        U8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u8\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u8\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u8 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u8  ,\n # )  -> U8x32\n # {\n U8x32::from([scalar; 32])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi8)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u8) -> U8x32 {
        U8x32::from([scalar; 32])
    }
    type BroadcastLoInput = U8x16;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U8x16  ,\n # )  -> U8x32\n # {\n U8x32::from([vector.as_array()[0]; 32])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastb_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastb_epi8)\n\n\n [`VPBROADCASTB (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U8x16) -> U8x32 {
        U8x32::from([vector.as_array()[0]; 32])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     if self.as_array()[0] == other.as_array()[0] {  u8::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u8::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u8::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u8::MAX  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  u8::MAX  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  u8::MAX  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  u8::MAX  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  u8::MAX  } else { 0 },\n     if self.as_array()[8] == other.as_array()[8] {  u8::MAX  } else { 0 },\n     if self.as_array()[9] == other.as_array()[9] {  u8::MAX  } else { 0 },\n     if self.as_array()[10] == other.as_array()[10] {  u8::MAX  } else { 0 },\n     if self.as_array()[11] == other.as_array()[11] {  u8::MAX  } else { 0 },\n     if self.as_array()[12] == other.as_array()[12] {  u8::MAX  } else { 0 },\n     if self.as_array()[13] == other.as_array()[13] {  u8::MAX  } else { 0 },\n     if self.as_array()[14] == other.as_array()[14] {  u8::MAX  } else { 0 },\n     if self.as_array()[15] == other.as_array()[15] {  u8::MAX  } else { 0 },\n     if self.as_array()[16] == other.as_array()[16] {  u8::MAX  } else { 0 },\n     if self.as_array()[17] == other.as_array()[17] {  u8::MAX  } else { 0 },\n     if self.as_array()[18] == other.as_array()[18] {  u8::MAX  } else { 0 },\n     if self.as_array()[19] == other.as_array()[19] {  u8::MAX  } else { 0 },\n     if self.as_array()[20] == other.as_array()[20] {  u8::MAX  } else { 0 },\n     if self.as_array()[21] == other.as_array()[21] {  u8::MAX  } else { 0 },\n     if self.as_array()[22] == other.as_array()[22] {  u8::MAX  } else { 0 },\n     if self.as_array()[23] == other.as_array()[23] {  u8::MAX  } else { 0 },\n     if self.as_array()[24] == other.as_array()[24] {  u8::MAX  } else { 0 },\n     if self.as_array()[25] == other.as_array()[25] {  u8::MAX  } else { 0 },\n     if self.as_array()[26] == other.as_array()[26] {  u8::MAX  } else { 0 },\n     if self.as_array()[27] == other.as_array()[27] {  u8::MAX  } else { 0 },\n     if self.as_array()[28] == other.as_array()[28] {  u8::MAX  } else { 0 },\n     if self.as_array()[29] == other.as_array()[29] {  u8::MAX  } else { 0 },\n     if self.as_array()[30] == other.as_array()[30] {  u8::MAX  } else { 0 },\n     if self.as_array()[31] == other.as_array()[31] {  u8::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi8)\n\n\n [`VPCMPEQB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U8x32) -> U8x32 {
        U8x32::from([
            if self.as_array()[0] == other.as_array()[0] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[8] == other.as_array()[8] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[9] == other.as_array()[9] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[10] == other.as_array()[10] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[11] == other.as_array()[11] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[12] == other.as_array()[12] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[13] == other.as_array()[13] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[14] == other.as_array()[14] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[15] == other.as_array()[15] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[16] == other.as_array()[16] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[17] == other.as_array()[17] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[18] == other.as_array()[18] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[19] == other.as_array()[19] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[20] == other.as_array()[20] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[21] == other.as_array()[21] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[22] == other.as_array()[22] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[23] == other.as_array()[23] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[24] == other.as_array()[24] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[25] == other.as_array()[25] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[26] == other.as_array()[26] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[27] == other.as_array()[27] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[28] == other.as_array()[28] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[29] == other.as_array()[29] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[30] == other.as_array()[30] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[31] == other.as_array()[31] {
                u8::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     if self.as_array()[0] > other.as_array()[0] {  u8::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u8::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u8::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u8::MAX  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  u8::MAX  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  u8::MAX  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  u8::MAX  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  u8::MAX  } else { 0 },\n     if self.as_array()[8] > other.as_array()[8] {  u8::MAX  } else { 0 },\n     if self.as_array()[9] > other.as_array()[9] {  u8::MAX  } else { 0 },\n     if self.as_array()[10] > other.as_array()[10] {  u8::MAX  } else { 0 },\n     if self.as_array()[11] > other.as_array()[11] {  u8::MAX  } else { 0 },\n     if self.as_array()[12] > other.as_array()[12] {  u8::MAX  } else { 0 },\n     if self.as_array()[13] > other.as_array()[13] {  u8::MAX  } else { 0 },\n     if self.as_array()[14] > other.as_array()[14] {  u8::MAX  } else { 0 },\n     if self.as_array()[15] > other.as_array()[15] {  u8::MAX  } else { 0 },\n     if self.as_array()[16] > other.as_array()[16] {  u8::MAX  } else { 0 },\n     if self.as_array()[17] > other.as_array()[17] {  u8::MAX  } else { 0 },\n     if self.as_array()[18] > other.as_array()[18] {  u8::MAX  } else { 0 },\n     if self.as_array()[19] > other.as_array()[19] {  u8::MAX  } else { 0 },\n     if self.as_array()[20] > other.as_array()[20] {  u8::MAX  } else { 0 },\n     if self.as_array()[21] > other.as_array()[21] {  u8::MAX  } else { 0 },\n     if self.as_array()[22] > other.as_array()[22] {  u8::MAX  } else { 0 },\n     if self.as_array()[23] > other.as_array()[23] {  u8::MAX  } else { 0 },\n     if self.as_array()[24] > other.as_array()[24] {  u8::MAX  } else { 0 },\n     if self.as_array()[25] > other.as_array()[25] {  u8::MAX  } else { 0 },\n     if self.as_array()[26] > other.as_array()[26] {  u8::MAX  } else { 0 },\n     if self.as_array()[27] > other.as_array()[27] {  u8::MAX  } else { 0 },\n     if self.as_array()[28] > other.as_array()[28] {  u8::MAX  } else { 0 },\n     if self.as_array()[29] > other.as_array()[29] {  u8::MAX  } else { 0 },\n     if self.as_array()[30] > other.as_array()[30] {  u8::MAX  } else { 0 },\n     if self.as_array()[31] > other.as_array()[31] {  u8::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 7);\n Self::from(I8x32::from(*self ^ sign_bit).cmp_gt(\n     I8x32::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U8x32) -> U8x32 {
        U8x32::from([
            if self.as_array()[0] > other.as_array()[0] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[8] > other.as_array()[8] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[9] > other.as_array()[9] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[10] > other.as_array()[10] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[11] > other.as_array()[11] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[12] > other.as_array()[12] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[13] > other.as_array()[13] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[14] > other.as_array()[14] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[15] > other.as_array()[15] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[16] > other.as_array()[16] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[17] > other.as_array()[17] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[18] > other.as_array()[18] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[19] > other.as_array()[19] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[20] > other.as_array()[20] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[21] > other.as_array()[21] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[22] > other.as_array()[22] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[23] > other.as_array()[23] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[24] > other.as_array()[24] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[25] > other.as_array()[25] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[26] > other.as_array()[26] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[27] > other.as_array()[27] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[28] > other.as_array()[28] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[29] > other.as_array()[29] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[30] > other.as_array()[30] {
                u8::MAX
            } else {
                0
            },
            if self.as_array()[31] > other.as_array()[31] {
                u8::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U8x32 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U8x32::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U8x32 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n     // Lane# 1\n     self.as_array()[16],\n     other.as_array()[16],\n     self.as_array()[17],\n     other.as_array()[17],\n     self.as_array()[18],\n     other.as_array()[18],\n     self.as_array()[19],\n     other.as_array()[19],\n     self.as_array()[20],\n     other.as_array()[20],\n     self.as_array()[21],\n     other.as_array()[21],\n     self.as_array()[22],\n     other.as_array()[22],\n     self.as_array()[23],\n     other.as_array()[23],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi8)\n\n\n [`VPUNPCKLBW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLBW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLBW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLBW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U8x32) -> U8x32 {
        U8x32::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7], // Lane# 1
            self.as_array()[16],
            other.as_array()[16],
            self.as_array()[17],
            other.as_array()[17],
            self.as_array()[18],
            other.as_array()[18],
            self.as_array()[19],
            other.as_array()[19],
            self.as_array()[20],
            other.as_array()[20],
            self.as_array()[21],
            other.as_array()[21],
            self.as_array()[22],
            other.as_array()[22],
            self.as_array()[23],
            other.as_array()[23],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     // Lane# 0\n     self.as_array()[8],\n     other.as_array()[8],\n     self.as_array()[9],\n     other.as_array()[9],\n     self.as_array()[10],\n     other.as_array()[10],\n     self.as_array()[11],\n     other.as_array()[11],\n     self.as_array()[12],\n     other.as_array()[12],\n     self.as_array()[13],\n     other.as_array()[13],\n     self.as_array()[14],\n     other.as_array()[14],\n     self.as_array()[15],\n     other.as_array()[15],\n     // Lane# 1\n     self.as_array()[24],\n     other.as_array()[24],\n     self.as_array()[25],\n     other.as_array()[25],\n     self.as_array()[26],\n     other.as_array()[26],\n     self.as_array()[27],\n     other.as_array()[27],\n     self.as_array()[28],\n     other.as_array()[28],\n     self.as_array()[29],\n     other.as_array()[29],\n     self.as_array()[30],\n     other.as_array()[30],\n     self.as_array()[31],\n     other.as_array()[31],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi8)\n\n\n [`VPUNPCKHBW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHBW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHBW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHBW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U8x32) -> U8x32 {
        U8x32::from([
            // Lane# 0
            self.as_array()[8],
            other.as_array()[8],
            self.as_array()[9],
            other.as_array()[9],
            self.as_array()[10],
            other.as_array()[10],
            self.as_array()[11],
            other.as_array()[11],
            self.as_array()[12],
            other.as_array()[12],
            self.as_array()[13],
            other.as_array()[13],
            self.as_array()[14],
            other.as_array()[14],
            self.as_array()[15],
            other.as_array()[15], // Lane# 1
            self.as_array()[24],
            other.as_array()[24],
            self.as_array()[25],
            other.as_array()[25],
            self.as_array()[26],
            other.as_array()[26],
            self.as_array()[27],
            other.as_array()[27],
            self.as_array()[28],
            other.as_array()[28],
            self.as_array()[29],
            other.as_array()[29],
            self.as_array()[30],
            other.as_array()[30],
            self.as_array()[31],
            other.as_array()[31],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n     self.as_array()[8].max(other.as_array()[8]),\n     self.as_array()[9].max(other.as_array()[9]),\n     self.as_array()[10].max(other.as_array()[10]),\n     self.as_array()[11].max(other.as_array()[11]),\n     self.as_array()[12].max(other.as_array()[12]),\n     self.as_array()[13].max(other.as_array()[13]),\n     self.as_array()[14].max(other.as_array()[14]),\n     self.as_array()[15].max(other.as_array()[15]),\n     self.as_array()[16].max(other.as_array()[16]),\n     self.as_array()[17].max(other.as_array()[17]),\n     self.as_array()[18].max(other.as_array()[18]),\n     self.as_array()[19].max(other.as_array()[19]),\n     self.as_array()[20].max(other.as_array()[20]),\n     self.as_array()[21].max(other.as_array()[21]),\n     self.as_array()[22].max(other.as_array()[22]),\n     self.as_array()[23].max(other.as_array()[23]),\n     self.as_array()[24].max(other.as_array()[24]),\n     self.as_array()[25].max(other.as_array()[25]),\n     self.as_array()[26].max(other.as_array()[26]),\n     self.as_array()[27].max(other.as_array()[27]),\n     self.as_array()[28].max(other.as_array()[28]),\n     self.as_array()[29].max(other.as_array()[29]),\n     self.as_array()[30].max(other.as_array()[30]),\n     self.as_array()[31].max(other.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_max_epu8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_max_epu8)\n\n\n [`VPMAXUB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMAXUB:PMAXUW.html): Maximum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
            self.as_array()[8].max(other.as_array()[8]),
            self.as_array()[9].max(other.as_array()[9]),
            self.as_array()[10].max(other.as_array()[10]),
            self.as_array()[11].max(other.as_array()[11]),
            self.as_array()[12].max(other.as_array()[12]),
            self.as_array()[13].max(other.as_array()[13]),
            self.as_array()[14].max(other.as_array()[14]),
            self.as_array()[15].max(other.as_array()[15]),
            self.as_array()[16].max(other.as_array()[16]),
            self.as_array()[17].max(other.as_array()[17]),
            self.as_array()[18].max(other.as_array()[18]),
            self.as_array()[19].max(other.as_array()[19]),
            self.as_array()[20].max(other.as_array()[20]),
            self.as_array()[21].max(other.as_array()[21]),
            self.as_array()[22].max(other.as_array()[22]),
            self.as_array()[23].max(other.as_array()[23]),
            self.as_array()[24].max(other.as_array()[24]),
            self.as_array()[25].max(other.as_array()[25]),
            self.as_array()[26].max(other.as_array()[26]),
            self.as_array()[27].max(other.as_array()[27]),
            self.as_array()[28].max(other.as_array()[28]),
            self.as_array()[29].max(other.as_array()[29]),
            self.as_array()[30].max(other.as_array()[30]),
            self.as_array()[31].max(other.as_array()[31]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U8x32  ,\n # )  -> U8x32\n # {\n U8x32::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n     self.as_array()[8].min(other.as_array()[8]),\n     self.as_array()[9].min(other.as_array()[9]),\n     self.as_array()[10].min(other.as_array()[10]),\n     self.as_array()[11].min(other.as_array()[11]),\n     self.as_array()[12].min(other.as_array()[12]),\n     self.as_array()[13].min(other.as_array()[13]),\n     self.as_array()[14].min(other.as_array()[14]),\n     self.as_array()[15].min(other.as_array()[15]),\n     self.as_array()[16].min(other.as_array()[16]),\n     self.as_array()[17].min(other.as_array()[17]),\n     self.as_array()[18].min(other.as_array()[18]),\n     self.as_array()[19].min(other.as_array()[19]),\n     self.as_array()[20].min(other.as_array()[20]),\n     self.as_array()[21].min(other.as_array()[21]),\n     self.as_array()[22].min(other.as_array()[22]),\n     self.as_array()[23].min(other.as_array()[23]),\n     self.as_array()[24].min(other.as_array()[24]),\n     self.as_array()[25].min(other.as_array()[25]),\n     self.as_array()[26].min(other.as_array()[26]),\n     self.as_array()[27].min(other.as_array()[27]),\n     self.as_array()[28].min(other.as_array()[28]),\n     self.as_array()[29].min(other.as_array()[29]),\n     self.as_array()[30].min(other.as_array()[30]),\n     self.as_array()[31].min(other.as_array()[31]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_min_epu8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_min_epu8)\n\n\n [`VPMINUB (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMINUB:PMINUW.html): Minimum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUB_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUB_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUB_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: U8x32) -> U8x32 {
        U8x32::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
            self.as_array()[8].min(other.as_array()[8]),
            self.as_array()[9].min(other.as_array()[9]),
            self.as_array()[10].min(other.as_array()[10]),
            self.as_array()[11].min(other.as_array()[11]),
            self.as_array()[12].min(other.as_array()[12]),
            self.as_array()[13].min(other.as_array()[13]),
            self.as_array()[14].min(other.as_array()[14]),
            self.as_array()[15].min(other.as_array()[15]),
            self.as_array()[16].min(other.as_array()[16]),
            self.as_array()[17].min(other.as_array()[17]),
            self.as_array()[18].min(other.as_array()[18]),
            self.as_array()[19].min(other.as_array()[19]),
            self.as_array()[20].min(other.as_array()[20]),
            self.as_array()[21].min(other.as_array()[21]),
            self.as_array()[22].min(other.as_array()[22]),
            self.as_array()[23].min(other.as_array()[23]),
            self.as_array()[24].min(other.as_array()[24]),
            self.as_array()[25].min(other.as_array()[25]),
            self.as_array()[26].min(other.as_array()[26]),
            self.as_array()[27].min(other.as_array()[27]),
            self.as_array()[28].min(other.as_array()[28]),
            self.as_array()[29].min(other.as_array()[29]),
            self.as_array()[30].min(other.as_array()[30]),
            self.as_array()[31].min(other.as_array()[31]),
        ])
    }
}
impl crate::SimdBase8<u8> for U8x32 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # {\n let mut out = [0; 32];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);\n }\n U8x32::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_si256)\n\n\n [`VPSLLDQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLDQ.html): Shift Double Quadword Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLDQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLDQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLDQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_left<const AMOUNT: usize>(&self) -> U8x32 {
        let mut out = [0; 32];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[AMOUNT..].copy_from_slice(&src_lane[0..16 - AMOUNT]);
        }
        U8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n #     <\n #             const AMOUNT: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U8x32\n # {\n let mut out = [0; 32];\n for (out_lane, src_lane) in out\n     .chunks_exact_mut(16)\n     .zip(self.as_array().chunks_exact(16))\n {\n     out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);\n }\n U8x32::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srli_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srli_si256)\n\n\n [`VPSRLDQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRLDQ.html): Shift Double Quadword Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLDQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLDQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLDQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_bytes_right<const AMOUNT: usize>(&self) -> U8x32 {
        let mut out = [0; 32];
        for (out_lane, src_lane) in out
            .chunks_exact_mut(16)
            .zip(self.as_array().chunks_exact(16))
        {
            out_lane[0..16 - AMOUNT].copy_from_slice(&src_lane[AMOUNT..]);
        }
        U8x32::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # ;}\n # impl SomeTraitForDoc for U8x32 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> u32\n # {\n let mut out: u32 = 0;\n for (i, value) in self.as_array().iter().copied().enumerate() {\n     out |= u32::from((value as u8) >> 7) << i;\n }\n out\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_movemask_epi8`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_movemask_epi8)\n\n\n [`VPMOVMSKB (R32, YMM)`](https://felixcloutier.com/x86/PMOVMSKB.html): Move Byte Mask\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVMSKB_R32_YMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVMSKB_R32_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVMSKB_R32_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn most_significant_bits(&self) -> u32 {
        let mut out: u32 = 0;
        for (i, value) in self.as_array().iter().copied().enumerate() {
            out |= u32::from((value as u8) >> 7) << i;
        }
        out
    }
}
type U16x8Internal = [u16; 8];
#[doc = "`[u16; 8]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U16x8(U16x8Internal);
unsafe impl bytemuck::Pod for U16x8 {}
unsafe impl bytemuck::Zeroable for U16x8 {}
impl PartialEq for U16x8 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U16x8 {}
impl Default for U16x8 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U16x8 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U16x8 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U16x8({:?})", <[u16; 8]>::from(*self))
    }
}
impl BitXorAssign for U16x8 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
        ])
    }
}
impl BitOrAssign for U16x8 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
        ])
    }
}
impl BitAndAssign for U16x8 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
        ])
    }
}
impl AddAssign for U16x8 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi16)\n\n\n [`PADDW (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
        ])
    }
}
impl SubAssign for U16x8 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi16)\n\n\n [`PSUBW (XMM, XMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
        ])
    }
}
impl U16x8 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U16x8Internal) -> Self {
        Self(x)
    }
}
impl From<[u16; 8]> for U16x8 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u16; 8]) -> U16x8 {
        U16x8(array)
    }
}
impl From<U16x8> for [u16; 8] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U16x8) -> [u16; 8] {
        vector.0
    }
}
impl From<I8x16> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: I8x16) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: I16x8) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: I32x4) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: I64x2) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: U8x16) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: U32x4) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for U16x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of U16x8."]
    #[inline(always)]
    fn from(x: U64x2) -> U16x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
} // Static shift
impl ShlAssign<u64> for U16x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x8\n # {\n if amount >= 16 {\n     U16x8::ZERO\n } else {\n     U16x8::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sll_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sll_epi16)\n\n\n [`PSLLW (XMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> U16x8 {
        if amount >= 16 {
            U16x8::ZERO
        } else {
            U16x8::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U16x8> for U16x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U16x8) {
        *self = (*self) << amount;
    }
}
impl Shl<U16x8> for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x8  ,\n # )  -> U16x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U16x8::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: U16x8) -> U16x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 { 0 } else { *x << amm };
        }
        U16x8::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U16x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x8\n # {\n if amount >= 16 {\n     U16x8::ZERO\n } else {\n     U16x8::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_srl_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srl_epi16)\n\n\n [`PSRLW (XMM, XMM)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> U16x8 {
        if amount >= 16 {
            U16x8::ZERO
        } else {
            U16x8::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U16x8> for U16x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U16x8) {
        *self = (*self) >> amount;
    }
}
impl Shr<U16x8> for U16x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x8  ,\n # )  -> U16x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U16x8::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: U16x8) -> U16x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 { 0 } else { *x >> amm };
        }
        U16x8::from(out)
    }
}
impl SimdBase<u16> for U16x8 {
    type Array = [u16; 8];
    type Signed = I16x8;
    type Unsigned = U16x8;
    const LANES: usize = 8;
    const ZERO: Self = { Self([0; 8]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u16  ,\n # )  -> U16x8\n # {\n let mut out = [0; 8];\n out[0] = scalar;\n U16x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u16) -> U16x8 {
        let mut out = [0; 8];
        out[0] = scalar;
        U16x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u16\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u16\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi16)\n\n\n [`PEXTRW (R32, XMM, I8)`](https://felixcloutier.com/x86/PEXTRW.html): Extract Word\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRW_R32_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRW_R32_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRW_R32_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u16 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u16  ,\n # )  -> U16x8\n # {\n U16x8::from([scalar; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u16) -> U16x8 {
        U16x8::from([scalar; 8])
    }
    type BroadcastLoInput = U16x8;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([vector.as_array()[0]; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastw_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastw_epi16)\n\n\n [`VPBROADCASTW (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U16x8) -> U16x8 {
        U16x8::from([vector.as_array()[0]; 8])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     if self.as_array()[0] == other.as_array()[0] {  u16::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u16::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u16::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u16::MAX  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  u16::MAX  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  u16::MAX  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  u16::MAX  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  u16::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi16)\n\n\n [`PCMPEQW (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U16x8) -> U16x8 {
        U16x8::from([
            if self.as_array()[0] == other.as_array()[0] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                u16::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     if self.as_array()[0] > other.as_array()[0] {  u16::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u16::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u16::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u16::MAX  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  u16::MAX  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  u16::MAX  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  u16::MAX  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  u16::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 15);\n Self::from(I16x8::from(*self ^ sign_bit).cmp_gt(\n     I16x8::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U16x8) -> U16x8 {
        U16x8::from([
            if self.as_array()[0] > other.as_array()[0] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                u16::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U16x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_epi16)\n\n\n [`PSLLW (XMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLW_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U16x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U16x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U16x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srli_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srli_epi16)\n\n\n [`PSRLW (XMM, I8)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLW_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLW_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLW_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U16x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U16x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi16)\n\n\n [`PUNPCKLWD (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLWD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLWD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLWD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U16x8) -> U16x8 {
        U16x8::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     // Lane# 0\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi16)\n\n\n [`PUNPCKHWD (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHWD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHWD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHWD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U16x8) -> U16x8 {
        U16x8::from([
            // Lane# 0
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_max_epu16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_max_epu16)\n\n\n [`PMAXUW (XMM, XMM)`](https://felixcloutier.com/x86/PMAXUB:PMAXUW.html): Maximum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_min_epu16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_min_epu16)\n\n\n [`PMINUW (XMM, XMM)`](https://felixcloutier.com/x86/PMINUB:PMINUW.html): Minimum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUW_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUW_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUW_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: U16x8) -> U16x8 {
        U16x8::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
        ])
    }
}
impl crate::SimdBase8x<u16> for U16x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U16x8  ,\n # )  -> U16x8\n # ;}\n # impl SomeTraitForDoc for U16x8 {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U16x8  ,\n # )  -> U16x8\n # {\n U16x8::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n         (if B4 { if_true } else { *self }).as_array()[4],\n         (if B5 { if_true } else { *self }).as_array()[5],\n         (if B6 { if_true } else { *self }).as_array()[6],\n         (if B7 { if_true } else { *self }).as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_blend_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_blend_epi16)\n\n\n [`PBLENDW (XMM, XMM, I8)`](https://felixcloutier.com/x86/PBLENDW.html): Blend Packed Words\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PBLENDW_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PBLENDW_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PBLENDW_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<
        const B7: bool,
        const B6: bool,
        const B5: bool,
        const B4: bool,
        const B3: bool,
        const B2: bool,
        const B1: bool,
        const B0: bool,
    >(
        &self,
        if_true: U16x8,
    ) -> U16x8 {
        U16x8::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
            (if B4 { if_true } else { *self }).as_array()[4],
            (if B5 { if_true } else { *self }).as_array()[5],
            (if B6 { if_true } else { *self }).as_array()[6],
            (if B7 { if_true } else { *self }).as_array()[7],
        ])
    }
}
type U16x16Internal = [u16; 16];
#[doc = "`[u16; 16]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U16x16(U16x16Internal);
unsafe impl bytemuck::Pod for U16x16 {}
unsafe impl bytemuck::Zeroable for U16x16 {}
impl PartialEq for U16x16 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U16x16 {}
impl Default for U16x16 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U16x16 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U16x16 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U16x16({:?})", <[u16; 16]>::from(*self))
    }
}
impl BitXorAssign for U16x16 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n     self.as_array()[8] ^ rhs.as_array()[8],\n     self.as_array()[9] ^ rhs.as_array()[9],\n     self.as_array()[10] ^ rhs.as_array()[10],\n     self.as_array()[11] ^ rhs.as_array()[11],\n     self.as_array()[12] ^ rhs.as_array()[12],\n     self.as_array()[13] ^ rhs.as_array()[13],\n     self.as_array()[14] ^ rhs.as_array()[14],\n     self.as_array()[15] ^ rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
            self.as_array()[8] ^ rhs.as_array()[8],
            self.as_array()[9] ^ rhs.as_array()[9],
            self.as_array()[10] ^ rhs.as_array()[10],
            self.as_array()[11] ^ rhs.as_array()[11],
            self.as_array()[12] ^ rhs.as_array()[12],
            self.as_array()[13] ^ rhs.as_array()[13],
            self.as_array()[14] ^ rhs.as_array()[14],
            self.as_array()[15] ^ rhs.as_array()[15],
        ])
    }
}
impl BitOrAssign for U16x16 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n     self.as_array()[8] | rhs.as_array()[8],\n     self.as_array()[9] | rhs.as_array()[9],\n     self.as_array()[10] | rhs.as_array()[10],\n     self.as_array()[11] | rhs.as_array()[11],\n     self.as_array()[12] | rhs.as_array()[12],\n     self.as_array()[13] | rhs.as_array()[13],\n     self.as_array()[14] | rhs.as_array()[14],\n     self.as_array()[15] | rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
            self.as_array()[8] | rhs.as_array()[8],
            self.as_array()[9] | rhs.as_array()[9],
            self.as_array()[10] | rhs.as_array()[10],
            self.as_array()[11] | rhs.as_array()[11],
            self.as_array()[12] | rhs.as_array()[12],
            self.as_array()[13] | rhs.as_array()[13],
            self.as_array()[14] | rhs.as_array()[14],
            self.as_array()[15] | rhs.as_array()[15],
        ])
    }
}
impl BitAndAssign for U16x16 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n     self.as_array()[8] & rhs.as_array()[8],\n     self.as_array()[9] & rhs.as_array()[9],\n     self.as_array()[10] & rhs.as_array()[10],\n     self.as_array()[11] & rhs.as_array()[11],\n     self.as_array()[12] & rhs.as_array()[12],\n     self.as_array()[13] & rhs.as_array()[13],\n     self.as_array()[14] & rhs.as_array()[14],\n     self.as_array()[15] & rhs.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
            self.as_array()[8] & rhs.as_array()[8],
            self.as_array()[9] & rhs.as_array()[9],
            self.as_array()[10] & rhs.as_array()[10],
            self.as_array()[11] & rhs.as_array()[11],
            self.as_array()[12] & rhs.as_array()[12],
            self.as_array()[13] & rhs.as_array()[13],
            self.as_array()[14] & rhs.as_array()[14],
            self.as_array()[15] & rhs.as_array()[15],
        ])
    }
}
impl AddAssign for U16x16 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_add(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_add(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_add(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_add(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_add(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_add(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_add(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_add(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi16)\n\n\n [`VPADDW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
            self.as_array()[8].wrapping_add(rhs.as_array()[8]),
            self.as_array()[9].wrapping_add(rhs.as_array()[9]),
            self.as_array()[10].wrapping_add(rhs.as_array()[10]),
            self.as_array()[11].wrapping_add(rhs.as_array()[11]),
            self.as_array()[12].wrapping_add(rhs.as_array()[12]),
            self.as_array()[13].wrapping_add(rhs.as_array()[13]),
            self.as_array()[14].wrapping_add(rhs.as_array()[14]),
            self.as_array()[15].wrapping_add(rhs.as_array()[15]),
        ])
    }
}
impl SubAssign for U16x16 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n     self.as_array()[8].wrapping_sub(rhs.as_array()[8]),\n     self.as_array()[9].wrapping_sub(rhs.as_array()[9]),\n     self.as_array()[10].wrapping_sub(rhs.as_array()[10]),\n     self.as_array()[11].wrapping_sub(rhs.as_array()[11]),\n     self.as_array()[12].wrapping_sub(rhs.as_array()[12]),\n     self.as_array()[13].wrapping_sub(rhs.as_array()[13]),\n     self.as_array()[14].wrapping_sub(rhs.as_array()[14]),\n     self.as_array()[15].wrapping_sub(rhs.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi16)\n\n\n [`VPSUBW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
            self.as_array()[8].wrapping_sub(rhs.as_array()[8]),
            self.as_array()[9].wrapping_sub(rhs.as_array()[9]),
            self.as_array()[10].wrapping_sub(rhs.as_array()[10]),
            self.as_array()[11].wrapping_sub(rhs.as_array()[11]),
            self.as_array()[12].wrapping_sub(rhs.as_array()[12]),
            self.as_array()[13].wrapping_sub(rhs.as_array()[13]),
            self.as_array()[14].wrapping_sub(rhs.as_array()[14]),
            self.as_array()[15].wrapping_sub(rhs.as_array()[15]),
        ])
    }
}
impl U16x16 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U16x16Internal) -> Self {
        Self(x)
    }
}
impl From<[u16; 16]> for U16x16 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u16; 16]) -> U16x16 {
        U16x16(array)
    }
}
impl From<U16x16> for [u16; 16] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U16x16) -> [u16; 16] {
        vector.0
    }
}
impl From<I8x32> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: I8x32) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x16> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: I16x16) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: I32x8) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: I64x4) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: U8x32) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: U32x8) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for U16x16 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of U16x16."]
    #[inline(always)]
    fn from(x: U64x4) -> U16x16 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for U16x16 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U8x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n         u16::from(vector.as_array()[0]),\n         u16::from(vector.as_array()[1]),\n         u16::from(vector.as_array()[2]),\n         u16::from(vector.as_array()[3]),\n         u16::from(vector.as_array()[4]),\n         u16::from(vector.as_array()[5]),\n         u16::from(vector.as_array()[6]),\n         u16::from(vector.as_array()[7]),\n         u16::from(vector.as_array()[8]),\n         u16::from(vector.as_array()[9]),\n         u16::from(vector.as_array()[10]),\n         u16::from(vector.as_array()[11]),\n         u16::from(vector.as_array()[12]),\n         u16::from(vector.as_array()[13]),\n         u16::from(vector.as_array()[14]),\n         u16::from(vector.as_array()[15]),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cvtepu8_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepu8_epi16)\n\n\n [`VPMOVZXBW (YMM, XMM)`](https://felixcloutier.com/x86/PMOVZX.html): Packed Move with Zero Extend\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXBW_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXBW_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXBW_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U8x16) -> U16x16 {
        U16x16::from([
            u16::from(vector.as_array()[0]),
            u16::from(vector.as_array()[1]),
            u16::from(vector.as_array()[2]),
            u16::from(vector.as_array()[3]),
            u16::from(vector.as_array()[4]),
            u16::from(vector.as_array()[5]),
            u16::from(vector.as_array()[6]),
            u16::from(vector.as_array()[7]),
            u16::from(vector.as_array()[8]),
            u16::from(vector.as_array()[9]),
            u16::from(vector.as_array()[10]),
            u16::from(vector.as_array()[11]),
            u16::from(vector.as_array()[12]),
            u16::from(vector.as_array()[13]),
            u16::from(vector.as_array()[14]),
            u16::from(vector.as_array()[15]),
        ])
    }
}
impl From<U16x8> for U16x16 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U16x8  ,\n # )  -> U16x16\n # {\n let mut out = [0; 16];\n out[0..8].copy_from_slice(&vector.as_array());\n U16x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U16x8) -> U16x16 {
        let mut out = [0; 16];
        out[0..8].copy_from_slice(&vector.as_array());
        U16x16::from(out)
    }
}
impl From<[U16x8; 2]> for U16x16 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [U16x8; 2]  ,\n # )  -> U16x16\n # {\n let mut out = [0; 16];\n out[0..8].copy_from_slice(&vectors[0].as_array());\n out[8..].copy_from_slice(&vectors[1].as_array());\n U16x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [U16x8; 2]) -> U16x16 {
        let mut out = [0; 16];
        out[0..8].copy_from_slice(&vectors[0].as_array());
        out[8..].copy_from_slice(&vectors[1].as_array());
        U16x16::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<U16x16> for [U16x8; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U16x16  ,\n # )  -> [U16x8; 2]\n # {\n let mut lo = [0; 8];\n let mut hi = [0; 8];\n lo.copy_from_slice(&vector.as_array()[0..8]);\n hi.copy_from_slice(&vector.as_array()[8..]);\n [U16x8::from(lo), U16x8::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U16x16) -> [U16x8; 2] {
        let mut lo = [0; 8];
        let mut hi = [0; 8];
        lo.copy_from_slice(&vector.as_array()[0..8]);
        hi.copy_from_slice(&vector.as_array()[8..]);
        [U16x8::from(lo), U16x8::from(hi)]
    }
} // Static shift
impl ShlAssign<u64> for U16x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x16\n # {\n if amount >= 16 {\n     U16x16::ZERO\n } else {\n     U16x16::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n         self.as_array()[8] << amount,\n         self.as_array()[9] << amount,\n         self.as_array()[10] << amount,\n         self.as_array()[11] << amount,\n         self.as_array()[12] << amount,\n         self.as_array()[13] << amount,\n         self.as_array()[14] << amount,\n         self.as_array()[15] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sll_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sll_epi16)\n\n\n [`VPSLLW (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> U16x16 {
        if amount >= 16 {
            U16x16::ZERO
        } else {
            U16x16::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
                self.as_array()[8] << amount,
                self.as_array()[9] << amount,
                self.as_array()[10] << amount,
                self.as_array()[11] << amount,
                self.as_array()[12] << amount,
                self.as_array()[13] << amount,
                self.as_array()[14] << amount,
                self.as_array()[15] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U16x16> for U16x16 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U16x16) {
        *self = (*self) << amount;
    }
}
impl Shl<U16x16> for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x16  ,\n # )  -> U16x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U16x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shl(self, amount: U16x16) -> U16x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 { 0 } else { *x << amm };
        }
        U16x16::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U16x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U16x16\n # {\n if amount >= 16 {\n     U16x16::ZERO\n } else {\n     U16x16::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n         self.as_array()[8] >> amount,\n         self.as_array()[9] >> amount,\n         self.as_array()[10] >> amount,\n         self.as_array()[11] >> amount,\n         self.as_array()[12] >> amount,\n         self.as_array()[13] >> amount,\n         self.as_array()[14] >> amount,\n         self.as_array()[15] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srl_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srl_epi16)\n\n\n [`VPSRLW (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLW_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLW_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLW_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> U16x16 {
        if amount >= 16 {
            U16x16::ZERO
        } else {
            U16x16::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
                self.as_array()[8] >> amount,
                self.as_array()[9] >> amount,
                self.as_array()[10] >> amount,
                self.as_array()[11] >> amount,
                self.as_array()[12] >> amount,
                self.as_array()[13] >> amount,
                self.as_array()[14] >> amount,
                self.as_array()[15] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U16x16> for U16x16 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U16x16) {
        *self = (*self) >> amount;
    }
}
impl Shr<U16x16> for U16x16 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U16x16  ,\n # )  -> U16x16\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 16  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U16x16::from(out)\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn shr(self, amount: U16x16) -> U16x16 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 16 { 0 } else { *x >> amm };
        }
        U16x16::from(out)
    }
}
impl SimdBase<u16> for U16x16 {
    type Array = [u16; 16];
    type Signed = I16x16;
    type Unsigned = U16x16;
    const LANES: usize = 16;
    const ZERO: Self = { Self([0; 16]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u16  ,\n # )  -> U16x16\n # {\n let mut out = [0; 16];\n out[0] = scalar;\n U16x16::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u16) -> U16x16 {
        let mut out = [0; 16];
        out[0] = scalar;
        U16x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u16\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u16 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u16  ,\n # )  -> U16x16\n # {\n U16x16::from([scalar; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi16)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u16) -> U16x16 {
        U16x16::from([scalar; 16])
    }
    type BroadcastLoInput = U16x8;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U16x8  ,\n # )  -> U16x16\n # {\n U16x16::from([vector.as_array()[0]; 16])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastw_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastw_epi16)\n\n\n [`VPBROADCASTW (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTW_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U16x8) -> U16x16 {
        U16x16::from([vector.as_array()[0]; 16])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     if self.as_array()[0] == other.as_array()[0] {  u16::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u16::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u16::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u16::MAX  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  u16::MAX  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  u16::MAX  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  u16::MAX  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  u16::MAX  } else { 0 },\n     if self.as_array()[8] == other.as_array()[8] {  u16::MAX  } else { 0 },\n     if self.as_array()[9] == other.as_array()[9] {  u16::MAX  } else { 0 },\n     if self.as_array()[10] == other.as_array()[10] {  u16::MAX  } else { 0 },\n     if self.as_array()[11] == other.as_array()[11] {  u16::MAX  } else { 0 },\n     if self.as_array()[12] == other.as_array()[12] {  u16::MAX  } else { 0 },\n     if self.as_array()[13] == other.as_array()[13] {  u16::MAX  } else { 0 },\n     if self.as_array()[14] == other.as_array()[14] {  u16::MAX  } else { 0 },\n     if self.as_array()[15] == other.as_array()[15] {  u16::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi16)\n\n\n [`VPCMPEQW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U16x16) -> U16x16 {
        U16x16::from([
            if self.as_array()[0] == other.as_array()[0] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[8] == other.as_array()[8] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[9] == other.as_array()[9] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[10] == other.as_array()[10] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[11] == other.as_array()[11] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[12] == other.as_array()[12] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[13] == other.as_array()[13] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[14] == other.as_array()[14] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[15] == other.as_array()[15] {
                u16::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     if self.as_array()[0] > other.as_array()[0] {  u16::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u16::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u16::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u16::MAX  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  u16::MAX  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  u16::MAX  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  u16::MAX  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  u16::MAX  } else { 0 },\n     if self.as_array()[8] > other.as_array()[8] {  u16::MAX  } else { 0 },\n     if self.as_array()[9] > other.as_array()[9] {  u16::MAX  } else { 0 },\n     if self.as_array()[10] > other.as_array()[10] {  u16::MAX  } else { 0 },\n     if self.as_array()[11] > other.as_array()[11] {  u16::MAX  } else { 0 },\n     if self.as_array()[12] > other.as_array()[12] {  u16::MAX  } else { 0 },\n     if self.as_array()[13] > other.as_array()[13] {  u16::MAX  } else { 0 },\n     if self.as_array()[14] > other.as_array()[14] {  u16::MAX  } else { 0 },\n     if self.as_array()[15] > other.as_array()[15] {  u16::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 15);\n Self::from(I16x16::from(*self ^ sign_bit).cmp_gt(\n     I16x16::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U16x16) -> U16x16 {
        U16x16::from([
            if self.as_array()[0] > other.as_array()[0] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[8] > other.as_array()[8] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[9] > other.as_array()[9] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[10] > other.as_array()[10] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[11] > other.as_array()[11] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[12] > other.as_array()[12] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[13] > other.as_array()[13] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[14] > other.as_array()[14] {
                u16::MAX
            } else {
                0
            },
            if self.as_array()[15] > other.as_array()[15] {
                u16::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U16x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_epi16)\n\n\n [`VPSLLW (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLW_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U16x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U16x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U16x16\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U16x16::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srli_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srli_epi16)\n\n\n [`VPSRLW (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLW_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLW_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLW_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U16x16 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U16x16::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     // Lane# 1\n     self.as_array()[8],\n     other.as_array()[8],\n     self.as_array()[9],\n     other.as_array()[9],\n     self.as_array()[10],\n     other.as_array()[10],\n     self.as_array()[11],\n     other.as_array()[11],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi16)\n\n\n [`VPUNPCKLWD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLWD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLWD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLWD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U16x16) -> U16x16 {
        U16x16::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3], // Lane# 1
            self.as_array()[8],
            other.as_array()[8],
            self.as_array()[9],
            other.as_array()[9],
            self.as_array()[10],
            other.as_array()[10],
            self.as_array()[11],
            other.as_array()[11],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     // Lane# 0\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n     // Lane# 1\n     self.as_array()[12],\n     other.as_array()[12],\n     self.as_array()[13],\n     other.as_array()[13],\n     self.as_array()[14],\n     other.as_array()[14],\n     self.as_array()[15],\n     other.as_array()[15],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi16)\n\n\n [`VPUNPCKHWD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHWD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHWD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHWD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U16x16) -> U16x16 {
        U16x16::from([
            // Lane# 0
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7], // Lane# 1
            self.as_array()[12],
            other.as_array()[12],
            self.as_array()[13],
            other.as_array()[13],
            self.as_array()[14],
            other.as_array()[14],
            self.as_array()[15],
            other.as_array()[15],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n     self.as_array()[8].max(other.as_array()[8]),\n     self.as_array()[9].max(other.as_array()[9]),\n     self.as_array()[10].max(other.as_array()[10]),\n     self.as_array()[11].max(other.as_array()[11]),\n     self.as_array()[12].max(other.as_array()[12]),\n     self.as_array()[13].max(other.as_array()[13]),\n     self.as_array()[14].max(other.as_array()[14]),\n     self.as_array()[15].max(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_max_epu16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_max_epu16)\n\n\n [`VPMAXUW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMAXUB:PMAXUW.html): Maximum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
            self.as_array()[8].max(other.as_array()[8]),
            self.as_array()[9].max(other.as_array()[9]),
            self.as_array()[10].max(other.as_array()[10]),
            self.as_array()[11].max(other.as_array()[11]),
            self.as_array()[12].max(other.as_array()[12]),
            self.as_array()[13].max(other.as_array()[13]),
            self.as_array()[14].max(other.as_array()[14]),
            self.as_array()[15].max(other.as_array()[15]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # ;}\n # impl SomeTraitForDoc for U16x16 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U16x16  ,\n # )  -> U16x16\n # {\n U16x16::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n     self.as_array()[8].min(other.as_array()[8]),\n     self.as_array()[9].min(other.as_array()[9]),\n     self.as_array()[10].min(other.as_array()[10]),\n     self.as_array()[11].min(other.as_array()[11]),\n     self.as_array()[12].min(other.as_array()[12]),\n     self.as_array()[13].min(other.as_array()[13]),\n     self.as_array()[14].min(other.as_array()[14]),\n     self.as_array()[15].min(other.as_array()[15]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_min_epu16`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_min_epu16)\n\n\n [`VPMINUW (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMINUB:PMINUW.html): Minimum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUW_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUW_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUW_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: U16x16) -> U16x16 {
        U16x16::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
            self.as_array()[8].min(other.as_array()[8]),
            self.as_array()[9].min(other.as_array()[9]),
            self.as_array()[10].min(other.as_array()[10]),
            self.as_array()[11].min(other.as_array()[11]),
            self.as_array()[12].min(other.as_array()[12]),
            self.as_array()[13].min(other.as_array()[13]),
            self.as_array()[14].min(other.as_array()[14]),
            self.as_array()[15].min(other.as_array()[15]),
        ])
    }
}
type U32x4Internal = [u32; 4];
#[doc = "`[u32; 4]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U32x4(U32x4Internal);
unsafe impl bytemuck::Pod for U32x4 {}
unsafe impl bytemuck::Zeroable for U32x4 {}
impl PartialEq for U32x4 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U32x4 {}
impl Default for U32x4 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U32x4 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U32x4 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U32x4({:?})", <[u32; 4]>::from(*self))
    }
}
impl BitXorAssign for U32x4 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
        ])
    }
}
impl BitOrAssign for U32x4 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
        ])
    }
}
impl BitAndAssign for U32x4 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
        ])
    }
}
impl AddAssign for U32x4 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi32)\n\n\n [`PADDD (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
        ])
    }
}
impl SubAssign for U32x4 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi32)\n\n\n [`PSUBD (XMM, XMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
        ])
    }
}
impl U32x4 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U32x4Internal) -> Self {
        Self(x)
    }
}
impl From<[u32; 4]> for U32x4 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u32; 4]) -> U32x4 {
        U32x4(array)
    }
}
impl From<U32x4> for [u32; 4] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U32x4) -> [u32; 4] {
        vector.0
    }
}
impl From<I8x16> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: I8x16) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: I16x8) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: I32x4) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: I64x2) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: U8x16) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: U16x8) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x2> for U32x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x2\nas little endian bits of U32x4."]
    #[inline(always)]
    fn from(x: U64x2) -> U32x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u32, i32, I32x4> for U32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : I32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i32gather_epi32)\n\n\n [`VPGATHERDD (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u32, indices: I32x4) -> U32x4 {
        U32x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : I32x4  ,\n #         mask  : U32x4  ,\n #         src  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     if (mask.as_array()[0] >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mask_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_i32gather_epi32)\n\n\n [`VPGATHERDD (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u32, indices: I32x4, mask: U32x4, src: U32x4) -> U32x4 {
        U32x4::from([
            if (mask.as_array()[0] >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u32, u64, U64x4> for U32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : U64x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u32, indices: U64x4) -> U32x4 {
        U32x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : U64x4  ,\n #         mask  : U32x4  ,\n #         src  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     if (mask.as_array()[0] >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u32, indices: U64x4, mask: U32x4, src: U32x4) -> U32x4 {
        U32x4::from([
            if (mask.as_array()[0] >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u32, i64, I64x4> for U32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : I64x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u32, indices: I64x4) -> U32x4 {
        U32x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : I64x4  ,\n #         mask  : U32x4  ,\n #         src  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     if (mask.as_array()[0] >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi32)\n\n\n [`VPGATHERQD (XMM, VSIB_YMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQD_XMM_VSIB_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u32, indices: I64x4, mask: U32x4, src: U32x4) -> U32x4 {
        U32x4::from([
            if (mask.as_array()[0] >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for U32x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x4\n # {\n if amount >= 32 {\n     U32x4::ZERO\n } else {\n     U32x4::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sll_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sll_epi32)\n\n\n [`PSLLD (XMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> U32x4 {
        if amount >= 32 {
            U32x4::ZERO
        } else {
            U32x4::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U32x4> for U32x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U32x4) {
        *self = (*self) << amount;
    }
}
impl Shl<U32x4> for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x4  ,\n # )  -> U32x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sllv_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sllv_epi32)\n\n\n [`VPSLLVD (XMM, XMM, XMM)`](https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html): Variable Bit Shift Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_XMM_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_XMM_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_XMM_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: U32x4) -> U32x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 { 0 } else { *x << amm };
        }
        U32x4::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U32x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x4\n # {\n if amount >= 32 {\n     U32x4::ZERO\n } else {\n     U32x4::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_srl_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srl_epi32)\n\n\n [`PSRLD (XMM, XMM)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> U32x4 {
        if amount >= 32 {
            U32x4::ZERO
        } else {
            U32x4::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U32x4> for U32x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U32x4) {
        *self = (*self) >> amount;
    }
}
impl Shr<U32x4> for U32x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x4  ,\n # )  -> U32x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srlv_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srlv_epi32)\n\n\n [`VPSRLVD (XMM, XMM, XMM)`](https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html): Variable Bit Shift Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVD_XMM_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVD_XMM_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVD_XMM_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: U32x4) -> U32x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 { 0 } else { *x >> amm };
        }
        U32x4::from(out)
    }
}
impl SimdBase<u32> for U32x4 {
    type Array = [u32; 4];
    type Signed = I32x4;
    type Unsigned = U32x4;
    const LANES: usize = 4;
    const ZERO: Self = { Self([0; 4]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u32  ,\n # )  -> U32x4\n # {\n let mut out = [0; 4];\n out[0] = scalar;\n U32x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u32) -> U32x4 {
        let mut out = [0; 4];
        out[0] = scalar;
        U32x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u32\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u32\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi32)\n\n\n [`PEXTRD (R32, XMM, I8)`](https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html): Extract Byte/Dword/Qword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRD_R32_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRD_R32_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRD_R32_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u32 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u32  ,\n # )  -> U32x4\n # {\n U32x4::from([scalar; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u32) -> U32x4 {
        U32x4::from([scalar; 4])
    }
    type BroadcastLoInput = U32x4;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([vector.as_array()[0]; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastd_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastd_epi32)\n\n\n [`VPBROADCASTD (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U32x4) -> U32x4 {
        U32x4::from([vector.as_array()[0]; 4])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     if self.as_array()[0] == other.as_array()[0] {  u32::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u32::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u32::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u32::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi32)\n\n\n [`PCMPEQD (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U32x4) -> U32x4 {
        U32x4::from([
            if self.as_array()[0] == other.as_array()[0] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u32::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     if self.as_array()[0] > other.as_array()[0] {  u32::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u32::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u32::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u32::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 31);\n Self::from(I32x4::from(*self ^ sign_bit).cmp_gt(\n     I32x4::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U32x4) -> U32x4 {
        U32x4::from([
            if self.as_array()[0] > other.as_array()[0] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u32::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_epi32)\n\n\n [`PSLLD (XMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLD_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U32x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U32x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U32x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srli_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srli_epi32)\n\n\n [`PSRLD (XMM, I8)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLD_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLD_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLD_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U32x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U32x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi32)\n\n\n [`PUNPCKLDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U32x4) -> U32x4 {
        U32x4::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     // Lane# 0\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi32)\n\n\n [`PUNPCKHDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U32x4) -> U32x4 {
        U32x4::from([
            // Lane# 0
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_max_epu32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_max_epu32)\n\n\n [`PMAXUD (XMM, XMM)`](https://felixcloutier.com/x86/PMAXUD:PMAXUQ.html): Maximum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMAXUD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_min_epu32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_min_epu32)\n\n\n [`PMINUD (XMM, XMM)`](https://felixcloutier.com/x86/PMINUD:PMINUQ.html): Minimum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUD_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUD_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMINUD_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: U32x4) -> U32x4 {
        U32x4::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
        ])
    }
}
impl crate::SimdBase32<u32> for U32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x4\n # {\n U32x4::from([\n     // 128-bit Lane #0\n     self.as_array()[I0 + 0 * 4],\n     self.as_array()[I1 + 0 * 4],\n     self.as_array()[I2 + 0 * 4],\n     self.as_array()[I3 + 0 * 4],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_shuffle_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_shuffle_epi32)\n\n\n [`PSHUFD (XMM, XMM, I8)`](https://felixcloutier.com/x86/PSHUFD.html): Shuffle Packed Doublewords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSHUFD_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSHUFD_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSHUFD_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shuffle<const I3: usize, const I2: usize, const I1: usize, const I0: usize>(&self) -> U32x4 {
        U32x4::from([
            // 128-bit Lane #0
            self.as_array()[I0 + 0 * 4],
            self.as_array()[I1 + 0 * 4],
            self.as_array()[I2 + 0 * 4],
            self.as_array()[I3 + 0 * 4],
        ])
    }
}
impl crate::SimdBase4x<u32> for U32x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U32x4  ,\n # )  -> U32x4\n # ;}\n # impl SomeTraitForDoc for U32x4 {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U32x4  ,\n # )  -> U32x4\n # {\n U32x4::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_blend_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_blend_epi32)\n\n\n [`VPBLENDD (XMM, XMM, XMM, I8)`](https://felixcloutier.com/x86/VPBLENDD.html): Blend Packed Dwords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_XMM_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_XMM_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_XMM_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<const B3: bool, const B2: bool, const B1: bool, const B0: bool>(
        &self,
        if_true: U32x4,
    ) -> U32x4 {
        U32x4::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
        ])
    }
}
type U32x8Internal = [u32; 8];
#[doc = "`[u32; 8]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U32x8(U32x8Internal);
unsafe impl bytemuck::Pod for U32x8 {}
unsafe impl bytemuck::Zeroable for U32x8 {}
impl PartialEq for U32x8 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U32x8 {}
impl Default for U32x8 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U32x8 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U32x8 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U32x8({:?})", <[u32; 8]>::from(*self))
    }
}
impl BitXorAssign for U32x8 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n     self.as_array()[4] ^ rhs.as_array()[4],\n     self.as_array()[5] ^ rhs.as_array()[5],\n     self.as_array()[6] ^ rhs.as_array()[6],\n     self.as_array()[7] ^ rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
            self.as_array()[4] ^ rhs.as_array()[4],
            self.as_array()[5] ^ rhs.as_array()[5],
            self.as_array()[6] ^ rhs.as_array()[6],
            self.as_array()[7] ^ rhs.as_array()[7],
        ])
    }
}
impl BitOrAssign for U32x8 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n     self.as_array()[4] | rhs.as_array()[4],\n     self.as_array()[5] | rhs.as_array()[5],\n     self.as_array()[6] | rhs.as_array()[6],\n     self.as_array()[7] | rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
            self.as_array()[4] | rhs.as_array()[4],
            self.as_array()[5] | rhs.as_array()[5],
            self.as_array()[6] | rhs.as_array()[6],
            self.as_array()[7] | rhs.as_array()[7],
        ])
    }
}
impl BitAndAssign for U32x8 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n     self.as_array()[4] & rhs.as_array()[4],\n     self.as_array()[5] & rhs.as_array()[5],\n     self.as_array()[6] & rhs.as_array()[6],\n     self.as_array()[7] & rhs.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
            self.as_array()[4] & rhs.as_array()[4],
            self.as_array()[5] & rhs.as_array()[5],
            self.as_array()[6] & rhs.as_array()[6],
            self.as_array()[7] & rhs.as_array()[7],
        ])
    }
}
impl AddAssign for U32x8 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_add(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_add(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_add(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_add(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi32)\n\n\n [`VPADDD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
            self.as_array()[4].wrapping_add(rhs.as_array()[4]),
            self.as_array()[5].wrapping_add(rhs.as_array()[5]),
            self.as_array()[6].wrapping_add(rhs.as_array()[6]),
            self.as_array()[7].wrapping_add(rhs.as_array()[7]),
        ])
    }
}
impl SubAssign for U32x8 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n     self.as_array()[4].wrapping_sub(rhs.as_array()[4]),\n     self.as_array()[5].wrapping_sub(rhs.as_array()[5]),\n     self.as_array()[6].wrapping_sub(rhs.as_array()[6]),\n     self.as_array()[7].wrapping_sub(rhs.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi32)\n\n\n [`VPSUBD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html): Subtract Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
            self.as_array()[4].wrapping_sub(rhs.as_array()[4]),
            self.as_array()[5].wrapping_sub(rhs.as_array()[5]),
            self.as_array()[6].wrapping_sub(rhs.as_array()[6]),
            self.as_array()[7].wrapping_sub(rhs.as_array()[7]),
        ])
    }
}
impl U32x8 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U32x8Internal) -> Self {
        Self(x)
    }
}
impl From<[u32; 8]> for U32x8 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u32; 8]) -> U32x8 {
        U32x8(array)
    }
}
impl From<U32x8> for [u32; 8] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U32x8) -> [u32; 8] {
        vector.0
    }
}
impl From<I8x32> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: I8x32) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x16> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: I16x16) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: I32x8) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: I64x4) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: U8x32) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: U16x16) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U64x4> for U32x8 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U64x4\nas little endian bits of U32x8."]
    #[inline(always)]
    fn from(x: U64x4) -> U32x8 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for U32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U16x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n         u32::from(vector.as_array()[0]),\n         u32::from(vector.as_array()[1]),\n         u32::from(vector.as_array()[2]),\n         u32::from(vector.as_array()[3]),\n         u32::from(vector.as_array()[4]),\n         u32::from(vector.as_array()[5]),\n         u32::from(vector.as_array()[6]),\n         u32::from(vector.as_array()[7]),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cvtepu16_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepu16_epi32)\n\n\n [`VPMOVZXWD (YMM, XMM)`](https://felixcloutier.com/x86/PMOVZX.html): Packed Move with Zero Extend\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXWD_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXWD_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXWD_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U16x8) -> U32x8 {
        U32x8::from([
            u32::from(vector.as_array()[0]),
            u32::from(vector.as_array()[1]),
            u32::from(vector.as_array()[2]),
            u32::from(vector.as_array()[3]),
            u32::from(vector.as_array()[4]),
            u32::from(vector.as_array()[5]),
            u32::from(vector.as_array()[6]),
            u32::from(vector.as_array()[7]),
        ])
    }
}
impl From<U32x4> for U32x8 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U32x4  ,\n # )  -> U32x8\n # {\n let mut out = [0; 8];\n out[0..4].copy_from_slice(&vector.as_array());\n U32x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U32x4) -> U32x8 {
        let mut out = [0; 8];
        out[0..4].copy_from_slice(&vector.as_array());
        U32x8::from(out)
    }
}
impl From<[U32x4; 2]> for U32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [U32x4; 2]  ,\n # )  -> U32x8\n # {\n let mut out = [0; 8];\n out[0..4].copy_from_slice(&vectors[0].as_array());\n out[4..].copy_from_slice(&vectors[1].as_array());\n U32x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [U32x4; 2]) -> U32x8 {
        let mut out = [0; 8];
        out[0..4].copy_from_slice(&vectors[0].as_array());
        out[4..].copy_from_slice(&vectors[1].as_array());
        U32x8::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<U32x8> for [U32x4; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U32x8  ,\n # )  -> [U32x4; 2]\n # {\n let mut lo = [0; 4];\n let mut hi = [0; 4];\n lo.copy_from_slice(&vector.as_array()[0..4]);\n hi.copy_from_slice(&vector.as_array()[4..]);\n [U32x4::from(lo), U32x4::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U32x8) -> [U32x4; 2] {
        let mut lo = [0; 4];
        let mut hi = [0; 4];
        lo.copy_from_slice(&vector.as_array()[0..4]);
        hi.copy_from_slice(&vector.as_array()[4..]);
        [U32x4::from(lo), U32x4::from(hi)]
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u32, i32, I32x8> for U32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : I32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n     base.offset(indices.as_array()[4] as isize).read_unaligned(),\n     base.offset(indices.as_array()[5] as isize).read_unaligned(),\n     base.offset(indices.as_array()[6] as isize).read_unaligned(),\n     base.offset(indices.as_array()[7] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i32gather_epi32)\n\n\n [`VPGATHERDD (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u32, indices: I32x8) -> U32x8 {
        U32x8::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
            base.offset(indices.as_array()[4] as isize).read_unaligned(),
            base.offset(indices.as_array()[5] as isize).read_unaligned(),
            base.offset(indices.as_array()[6] as isize).read_unaligned(),
            base.offset(indices.as_array()[7] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u32  ,\n #         indices  : I32x8  ,\n #         mask  : U32x8  ,\n #         src  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     if (mask.as_array()[0] >> 31) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 31) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 31) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 31) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n     if (mask.as_array()[4] >> 31) == 1 {\n         base.offset(indices.as_array()[4] as isize).read_unaligned()\n     } else {\n         src.as_array()[4]\n     },\n     if (mask.as_array()[5] >> 31) == 1 {\n         base.offset(indices.as_array()[5] as isize).read_unaligned()\n     } else {\n         src.as_array()[5]\n     },\n     if (mask.as_array()[6] >> 31) == 1 {\n         base.offset(indices.as_array()[6] as isize).read_unaligned()\n     } else {\n         src.as_array()[6]\n     },\n     if (mask.as_array()[7] >> 31) == 1 {\n         base.offset(indices.as_array()[7] as isize).read_unaligned()\n     } else {\n         src.as_array()[7]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i32gather_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i32gather_epi32)\n\n\n [`VPGATHERDD (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html): Gather Packed Dword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDD_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;22]</td>\n <td>5.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u32, indices: I32x8, mask: U32x8, src: U32x8) -> U32x8 {
        U32x8::from([
            if (mask.as_array()[0] >> 31) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 31) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 31) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 31) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
            if (mask.as_array()[4] >> 31) == 1 {
                base.offset(indices.as_array()[4] as isize).read_unaligned()
            } else {
                src.as_array()[4]
            },
            if (mask.as_array()[5] >> 31) == 1 {
                base.offset(indices.as_array()[5] as isize).read_unaligned()
            } else {
                src.as_array()[5]
            },
            if (mask.as_array()[6] >> 31) == 1 {
                base.offset(indices.as_array()[6] as isize).read_unaligned()
            } else {
                src.as_array()[6]
            },
            if (mask.as_array()[7] >> 31) == 1 {
                base.offset(indices.as_array()[7] as isize).read_unaligned()
            } else {
                src.as_array()[7]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for U32x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x8\n # {\n if amount >= 32 {\n     U32x8::ZERO\n } else {\n     U32x8::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n         self.as_array()[4] << amount,\n         self.as_array()[5] << amount,\n         self.as_array()[6] << amount,\n         self.as_array()[7] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sll_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sll_epi32)\n\n\n [`VPSLLD (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> U32x8 {
        if amount >= 32 {
            U32x8::ZERO
        } else {
            U32x8::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
                self.as_array()[4] << amount,
                self.as_array()[5] << amount,
                self.as_array()[6] << amount,
                self.as_array()[7] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U32x8> for U32x8 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U32x8) {
        *self = (*self) << amount;
    }
}
impl Shl<U32x8> for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x8  ,\n # )  -> U32x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sllv_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sllv_epi32)\n\n\n [`VPSLLVD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html): Variable Bit Shift Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: U32x8) -> U32x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 { 0 } else { *x << amm };
        }
        U32x8::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U32x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U32x8\n # {\n if amount >= 32 {\n     U32x8::ZERO\n } else {\n     U32x8::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n         self.as_array()[4] >> amount,\n         self.as_array()[5] >> amount,\n         self.as_array()[6] >> amount,\n         self.as_array()[7] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srl_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srl_epi32)\n\n\n [`VPSRLD (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLD_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLD_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLD_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> U32x8 {
        if amount >= 32 {
            U32x8::ZERO
        } else {
            U32x8::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
                self.as_array()[4] >> amount,
                self.as_array()[5] >> amount,
                self.as_array()[6] >> amount,
                self.as_array()[7] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U32x8> for U32x8 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U32x8) {
        *self = (*self) >> amount;
    }
}
impl Shr<U32x8> for U32x8 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U32x8  ,\n # )  -> U32x8\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 32  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srlv_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srlv_epi32)\n\n\n [`VPSRLVD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html): Variable Bit Shift Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: U32x8) -> U32x8 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 32 { 0 } else { *x >> amm };
        }
        U32x8::from(out)
    }
}
impl SimdBase<u32> for U32x8 {
    type Array = [u32; 8];
    type Signed = I32x8;
    type Unsigned = U32x8;
    const LANES: usize = 8;
    const ZERO: Self = { Self([0; 8]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u32  ,\n # )  -> U32x8\n # {\n let mut out = [0; 8];\n out[0] = scalar;\n U32x8::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u32) -> U32x8 {
        let mut out = [0; 8];
        out[0] = scalar;
        U32x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u32\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u32\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u32 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u32  ,\n # )  -> U32x8\n # {\n U32x8::from([scalar; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi32)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u32) -> U32x8 {
        U32x8::from([scalar; 8])
    }
    type BroadcastLoInput = U32x4;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U32x4  ,\n # )  -> U32x8\n # {\n U32x8::from([vector.as_array()[0]; 8])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastd_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastd_epi32)\n\n\n [`VPBROADCASTD (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTD_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U32x4) -> U32x8 {
        U32x8::from([vector.as_array()[0]; 8])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     if self.as_array()[0] == other.as_array()[0] {  u32::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u32::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u32::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u32::MAX  } else { 0 },\n     if self.as_array()[4] == other.as_array()[4] {  u32::MAX  } else { 0 },\n     if self.as_array()[5] == other.as_array()[5] {  u32::MAX  } else { 0 },\n     if self.as_array()[6] == other.as_array()[6] {  u32::MAX  } else { 0 },\n     if self.as_array()[7] == other.as_array()[7] {  u32::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi32)\n\n\n [`VPCMPEQD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html): Compare Packed Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U32x8) -> U32x8 {
        U32x8::from([
            if self.as_array()[0] == other.as_array()[0] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[4] == other.as_array()[4] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[5] == other.as_array()[5] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[6] == other.as_array()[6] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[7] == other.as_array()[7] {
                u32::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     if self.as_array()[0] > other.as_array()[0] {  u32::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u32::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u32::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u32::MAX  } else { 0 },\n     if self.as_array()[4] > other.as_array()[4] {  u32::MAX  } else { 0 },\n     if self.as_array()[5] > other.as_array()[5] {  u32::MAX  } else { 0 },\n     if self.as_array()[6] > other.as_array()[6] {  u32::MAX  } else { 0 },\n     if self.as_array()[7] > other.as_array()[7] {  u32::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 31);\n Self::from(I32x8::from(*self ^ sign_bit).cmp_gt(\n     I32x8::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U32x8) -> U32x8 {
        U32x8::from([
            if self.as_array()[0] > other.as_array()[0] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[4] > other.as_array()[4] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[5] > other.as_array()[5] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[6] > other.as_array()[6] {
                u32::MAX
            } else {
                0
            },
            if self.as_array()[7] > other.as_array()[7] {
                u32::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_epi32)\n\n\n [`VPSLLD (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLD_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U32x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U32x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x8\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U32x8::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srli_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srli_epi32)\n\n\n [`VPSRLD (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLD_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLD_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLD_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U32x8 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U32x8::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     self.as_array()[1],\n     other.as_array()[1],\n     // Lane# 1\n     self.as_array()[4],\n     other.as_array()[4],\n     self.as_array()[5],\n     other.as_array()[5],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi32)\n\n\n [`VPUNPCKLDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U32x8) -> U32x8 {
        U32x8::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
            self.as_array()[1],
            other.as_array()[1], // Lane# 1
            self.as_array()[4],
            other.as_array()[4],
            self.as_array()[5],
            other.as_array()[5],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     // Lane# 0\n     self.as_array()[2],\n     other.as_array()[2],\n     self.as_array()[3],\n     other.as_array()[3],\n     // Lane# 1\n     self.as_array()[6],\n     other.as_array()[6],\n     self.as_array()[7],\n     other.as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi32)\n\n\n [`VPUNPCKHDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U32x8) -> U32x8 {
        U32x8::from([
            // Lane# 0
            self.as_array()[2],
            other.as_array()[2],
            self.as_array()[3],
            other.as_array()[3], // Lane# 1
            self.as_array()[6],
            other.as_array()[6],
            self.as_array()[7],
            other.as_array()[7],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n     self.as_array()[4].max(other.as_array()[4]),\n     self.as_array()[5].max(other.as_array()[5]),\n     self.as_array()[6].max(other.as_array()[6]),\n     self.as_array()[7].max(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_max_epu32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_max_epu32)\n\n\n [`VPMAXUD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMAXUD:PMAXUQ.html): Maximum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMAXUD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn max(&self, other: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
            self.as_array()[4].max(other.as_array()[4]),
            self.as_array()[5].max(other.as_array()[5]),
            self.as_array()[6].max(other.as_array()[6]),
            self.as_array()[7].max(other.as_array()[7]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n     self.as_array()[4].min(other.as_array()[4]),\n     self.as_array()[5].min(other.as_array()[5]),\n     self.as_array()[6].min(other.as_array()[6]),\n     self.as_array()[7].min(other.as_array()[7]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_min_epu32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_min_epu32)\n\n\n [`VPMINUD (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMINUD:PMINUQ.html): Minimum of Packed Unsigned Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUD_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUD_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMINUD_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn min(&self, other: U32x8) -> U32x8 {
        U32x8::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
            self.as_array()[4].min(other.as_array()[4]),
            self.as_array()[5].min(other.as_array()[5]),
            self.as_array()[6].min(other.as_array()[6]),
            self.as_array()[7].min(other.as_array()[7]),
        ])
    }
}
impl crate::SimdBase32<u32> for U32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U32x8\n # {\n U32x8::from([\n     // 128-bit Lane #0\n     self.as_array()[I0 + 0 * 4],\n     self.as_array()[I1 + 0 * 4],\n     self.as_array()[I2 + 0 * 4],\n     self.as_array()[I3 + 0 * 4],\n     // 128-bit Lane #1\n     self.as_array()[I0 + 1 * 4],\n     self.as_array()[I1 + 1 * 4],\n     self.as_array()[I2 + 1 * 4],\n     self.as_array()[I3 + 1 * 4],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_shuffle_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_shuffle_epi32)\n\n\n [`VPSHUFD (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSHUFD.html): Shuffle Packed Doublewords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSHUFD_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSHUFD_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSHUFD_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shuffle<const I3: usize, const I2: usize, const I1: usize, const I0: usize>(&self) -> U32x8 {
        U32x8::from([
            // 128-bit Lane #0
            self.as_array()[I0 + 0 * 4],
            self.as_array()[I1 + 0 * 4],
            self.as_array()[I2 + 0 * 4],
            self.as_array()[I3 + 0 * 4], // 128-bit Lane #1
            self.as_array()[I0 + 1 * 4],
            self.as_array()[I1 + 1 * 4],
            self.as_array()[I2 + 1 * 4],
            self.as_array()[I3 + 1 * 4],
        ])
    }
}
impl crate::SimdBase8x<u32> for U32x8 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U32x8  ,\n # )  -> U32x8\n # ;}\n # impl SomeTraitForDoc for U32x8 {\n # fn the_doc_function\n #     <\n #             const B7: bool,\n #             const B6: bool,\n #             const B5: bool,\n #             const B4: bool,\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U32x8  ,\n # )  -> U32x8\n # {\n U32x8::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n         (if B4 { if_true } else { *self }).as_array()[4],\n         (if B5 { if_true } else { *self }).as_array()[5],\n         (if B6 { if_true } else { *self }).as_array()[6],\n         (if B7 { if_true } else { *self }).as_array()[7],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_blend_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_blend_epi32)\n\n\n [`VPBLENDD (YMM, YMM, YMM, I8)`](https://felixcloutier.com/x86/VPBLENDD.html): Blend Packed Dwords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<
        const B7: bool,
        const B6: bool,
        const B5: bool,
        const B4: bool,
        const B3: bool,
        const B2: bool,
        const B1: bool,
        const B0: bool,
    >(
        &self,
        if_true: U32x8,
    ) -> U32x8 {
        U32x8::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
            (if B4 { if_true } else { *self }).as_array()[4],
            (if B5 { if_true } else { *self }).as_array()[5],
            (if B6 { if_true } else { *self }).as_array()[6],
            (if B7 { if_true } else { *self }).as_array()[7],
        ])
    }
}
type U64x2Internal = [u64; 2];
#[doc = "`[u64; 2]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U64x2(U64x2Internal);
unsafe impl bytemuck::Pod for U64x2 {}
unsafe impl bytemuck::Zeroable for U64x2 {}
impl PartialEq for U64x2 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U64x2 {}
impl Default for U64x2 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U64x2 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U64x2 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U64x2({:?})", <[u64; 2]>::from(*self))
    }
}
impl BitXorAssign for U64x2 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_xor_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_xor_si128)\n\n\n [`PXOR (XMM, XMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PXOR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
        ])
    }
}
impl BitOrAssign for U64x2 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_or_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_or_si128)\n\n\n [`POR (XMM, XMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/POR_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
        ])
    }
}
impl BitAndAssign for U64x2 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_and_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_and_si128)\n\n\n [`PAND (XMM, XMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PAND_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
        ])
    }
}
impl AddAssign for U64x2 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_add_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_add_epi64)\n\n\n [`PADDQ (XMM, XMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PADDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
        ])
    }
}
impl SubAssign for U64x2 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sub_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sub_epi64)\n\n\n [`PSUBQ (XMM, XMM)`](https://felixcloutier.com/x86/PSUBQ.html): Subtract Packed Quadword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSUBQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
        ])
    }
}
impl U64x2 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U64x2Internal) -> Self {
        Self(x)
    }
}
impl From<[u64; 2]> for U64x2 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_loadu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_loadu_si128)\n\n\n [`MOVDQU (XMM, M128)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_XMM_M128.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;7]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u64; 2]) -> U64x2 {
        U64x2(array)
    }
}
impl From<U64x2> for [u64; 2] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_storeu_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_storeu_si128)\n\n\n [`MOVDQU (M128, XMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/MOVDQU_M128_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U64x2) -> [u64; 2] {
        vector.0
    }
}
impl From<I8x16> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x16\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: I8x16) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x8> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x8\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: I16x8) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x4> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x4\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: I32x4) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x2> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x2\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: I64x2) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x16> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x16\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: U8x16) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x8> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x8\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: U16x8) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for U64x2 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x4\nas little endian bits of U64x2."]
    #[inline(always)]
    fn from(x: U32x4) -> U64x2 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u64, u64, U64x2> for U64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u64, indices: U64x2) -> U64x2 {
        U64x2::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : U64x2  ,\n #         mask  : U64x2  ,\n #         src  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     if (mask.as_array()[0] >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u64, indices: U64x2, mask: U64x2, src: U64x2) -> U64x2 {
        U64x2::from([
            if (mask.as_array()[0] >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u64, i64, I64x2> for U64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : I64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u64, indices: I64x2) -> U64x2 {
        U64x2::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : I64x2  ,\n #         mask  : U64x2  ,\n #         src  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     if (mask.as_array()[0] >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (XMM, VSIB_XMM, XMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;18]</td>\n <td>2.25</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_XMM_VSIB_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;18]</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u64, indices: I64x2, mask: U64x2, src: U64x2) -> U64x2 {
        U64x2::from([
            if (mask.as_array()[0] >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for U64x2 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x2\n # {\n if amount >= 64 {\n     U64x2::ZERO\n } else {\n     U64x2::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_sll_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sll_epi64)\n\n\n [`PSLLQ (XMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> U64x2 {
        if amount >= 64 {
            U64x2::ZERO
        } else {
            U64x2::from([self.as_array()[0] << amount, self.as_array()[1] << amount])
        }
    }
} // Variable shift
impl ShlAssign<U64x2> for U64x2 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U64x2) {
        *self = (*self) << amount;
    }
}
impl Shl<U64x2> for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x2  ,\n # )  -> U64x2\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U64x2::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_sllv_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_sllv_epi64)\n\n\n [`VPSLLVQ (XMM, XMM, XMM)`](https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html): Variable Bit Shift Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVQ_XMM_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVQ_XMM_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVQ_XMM_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: U64x2) -> U64x2 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 { 0 } else { *x << amm };
        }
        U64x2::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U64x2 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x2\n # {\n if amount >= 64 {\n     U64x2::ZERO\n } else {\n     U64x2::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n <li>\n\n [**`_mm_srl_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srl_epi64)\n\n\n [`PSRLQ (XMM, XMM)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[1;2]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> U64x2 {
        if amount >= 64 {
            U64x2::ZERO
        } else {
            U64x2::from([self.as_array()[0] >> amount, self.as_array()[1] >> amount])
        }
    }
} // Variable shift
impl ShrAssign<U64x2> for U64x2 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U64x2) {
        *self = (*self) >> amount;
    }
}
impl Shr<U64x2> for U64x2 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x2  ,\n # )  -> U64x2\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U64x2::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srlv_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srlv_epi64)\n\n\n [`VPSRLVQ (XMM, XMM, XMM)`](https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html): Variable Bit Shift Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVQ_XMM_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVQ_XMM_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVQ_XMM_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: U64x2) -> U64x2 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 { 0 } else { *x >> amm };
        }
        U64x2::from(out)
    }
}
impl SimdBase<u64> for U64x2 {
    type Array = [u64; 2];
    type Signed = I64x2;
    type Unsigned = U64x2;
    const LANES: usize = 2;
    const ZERO: Self = { Self([0; 2]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_testz_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_testz_si128)\n\n\n [`PTEST (XMM, XMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PTEST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u64  ,\n # )  -> U64x2\n # {\n let mut out = [0; 2];\n out[0] = scalar;\n U64x2::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u64) -> U64x2 {
        let mut out = [0; 2];
        out[0] = scalar;
        U64x2::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u64\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u64\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_extract_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_extract_epi64)\n\n\n [`PEXTRQ (R64, XMM, I8)`](https://felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html): Extract Byte/Dword/Qword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRQ_R64_XMM_I8.html#SKL\">Skylake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRQ_R64_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PEXTRQ_R64_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>&le;4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u64 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u64  ,\n # )  -> U64x2\n # {\n U64x2::from([scalar; 2])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_set1_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set1_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u64) -> U64x2 {
        U64x2::from([scalar; 2])
    }
    type BroadcastLoInput = U64x2;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([vector.as_array()[0]; 2])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_broadcastq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_broadcastq_epi64)\n\n\n [`VPBROADCASTQ (XMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U64x2) -> U64x2 {
        U64x2::from([vector.as_array()[0]; 2])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     if self.as_array()[0] == other.as_array()[0] {  u64::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u64::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_cmpeq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_cmpeq_epi64)\n\n\n [`PCMPEQQ (XMM, XMM)`](https://felixcloutier.com/x86/PCMPEQQ.html): Compare Packed Qword Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCMPEQQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            if self.as_array()[0] == other.as_array()[0] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u64::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     if self.as_array()[0] > other.as_array()[0] {  u64::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u64::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 63);\n Self::from(I64x2::from(*self ^ sign_bit).cmp_gt(\n     I64x2::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            if self.as_array()[0] > other.as_array()[0] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u64::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x2\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U64x2::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_slli_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_slli_epi64)\n\n\n [`PSLLQ (XMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSLLQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U64x2 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U64x2::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x2\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U64x2::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_srli_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_srli_epi64)\n\n\n [`PSRLQ (XMM, I8)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLQ_XMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLQ_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PSRLQ_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U64x2 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U64x2::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpacklo_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpacklo_epi64)\n\n\n [`PUNPCKLQDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLQDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLQDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKLQDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     // Lane# 0\n     self.as_array()[1],\n     other.as_array()[1],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_unpackhi_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_unpackhi_epi64)\n\n\n [`PUNPCKHQDQ (XMM, XMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHQDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHQDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PUNPCKHQDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            // Lane# 0
            self.as_array()[1],
            other.as_array()[1],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn max(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn min(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
        ])
    }
}
impl crate::SimdBase64<u64> for U64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n U64x2::from([\n     ((self.as_array()[0] as u32) as u64) * ((other.as_array()[0] as u32) as u64),\n     ((self.as_array()[1] as u32) as u64) * ((other.as_array()[1] as u32) as u64),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_mul_epu32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_mul_epu32)\n\n\n [`PMULUDQ (XMM, XMM)`](https://felixcloutier.com/x86/PMULUDQ.html): Multiply Packed Unsigned Doubleword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMULUDQ_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMULUDQ_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PMULUDQ_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn mul_lo(&self, other: U64x2) -> U64x2 {
        U64x2::from([
            ((self.as_array()[0] as u32) as u64) * ((other.as_array()[0] as u32) as u64),
            ((self.as_array()[1] as u32) as u64) * ((other.as_array()[1] as u32) as u64),
        ])
    }
}
type U64x4Internal = [u64; 4];
#[doc = "`[u64; 4]` as a vector."]
#[repr(transparent)]
#[derive(Clone, Copy)]
pub struct U64x4(U64x4Internal);
unsafe impl bytemuck::Pod for U64x4 {}
unsafe impl bytemuck::Zeroable for U64x4 {}
impl PartialEq for U64x4 {
    #[inline(always)]
    fn eq(&self, other: &Self) -> bool {
        ((*self) ^ (*other)).is_zero()
    }
}
impl Eq for U64x4 {}
impl Default for U64x4 {
    #[doc = "The zero vector."]
    #[inline(always)]
    fn default() -> Self {
        Self::ZERO
    }
}
impl std::hash::Hash for U64x4 {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        bytemuck::bytes_of(self).hash(state);
    }
}
impl std::fmt::Debug for U64x4 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "U64x4({:?})", <[u64; 4]>::from(*self))
    }
}
impl BitXorAssign for U64x4 {
    #[inline(always)]
    fn bitxor_assign(&mut self, rhs: Self) {
        *self = self.bitxor(rhs);
    }
}
impl BitXor for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0] ^ rhs.as_array()[0],\n     self.as_array()[1] ^ rhs.as_array()[1],\n     self.as_array()[2] ^ rhs.as_array()[2],\n     self.as_array()[3] ^ rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_xor_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_xor_si256)\n\n\n [`VPXOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PXOR.html): Logical Exclusive OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPXOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitxor(self, rhs: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0] ^ rhs.as_array()[0],
            self.as_array()[1] ^ rhs.as_array()[1],
            self.as_array()[2] ^ rhs.as_array()[2],
            self.as_array()[3] ^ rhs.as_array()[3],
        ])
    }
}
impl BitOrAssign for U64x4 {
    #[inline(always)]
    fn bitor_assign(&mut self, rhs: Self) {
        *self = self.bitor(rhs);
    }
}
impl BitOr for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0] | rhs.as_array()[0],\n     self.as_array()[1] | rhs.as_array()[1],\n     self.as_array()[2] | rhs.as_array()[2],\n     self.as_array()[3] | rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_or_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_or_si256)\n\n\n [`VPOR (YMM, YMM, YMM)`](https://felixcloutier.com/x86/POR.html): Bitwise Logical OR\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPOR_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitor(self, rhs: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0] | rhs.as_array()[0],
            self.as_array()[1] | rhs.as_array()[1],
            self.as_array()[2] | rhs.as_array()[2],
            self.as_array()[3] | rhs.as_array()[3],
        ])
    }
}
impl BitAndAssign for U64x4 {
    #[inline(always)]
    fn bitand_assign(&mut self, rhs: Self) {
        *self = self.bitand(rhs);
    }
}
impl BitAnd for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0] & rhs.as_array()[0],\n     self.as_array()[1] & rhs.as_array()[1],\n     self.as_array()[2] & rhs.as_array()[2],\n     self.as_array()[3] & rhs.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_and_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_and_si256)\n\n\n [`VPAND (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PAND.html): Logical AND\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPAND_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn bitand(self, rhs: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0] & rhs.as_array()[0],
            self.as_array()[1] & rhs.as_array()[1],
            self.as_array()[2] & rhs.as_array()[2],
            self.as_array()[3] & rhs.as_array()[3],
        ])
    }
}
impl AddAssign for U64x4 {
    #[inline(always)]
    fn add_assign(&mut self, rhs: Self) {
        *self = self.add(rhs);
    }
}
impl Add for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0].wrapping_add(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_add(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_add(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_add(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_add_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_add_epi64)\n\n\n [`VPADDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html): Add Packed Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPADDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn add(self, rhs: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0].wrapping_add(rhs.as_array()[0]),
            self.as_array()[1].wrapping_add(rhs.as_array()[1]),
            self.as_array()[2].wrapping_add(rhs.as_array()[2]),
            self.as_array()[3].wrapping_add(rhs.as_array()[3]),
        ])
    }
}
impl SubAssign for U64x4 {
    #[inline(always)]
    fn sub_assign(&mut self, rhs: Self) {
        *self = self.sub(rhs);
    }
}
impl Sub for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         rhs  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0].wrapping_sub(rhs.as_array()[0]),\n     self.as_array()[1].wrapping_sub(rhs.as_array()[1]),\n     self.as_array()[2].wrapping_sub(rhs.as_array()[2]),\n     self.as_array()[3].wrapping_sub(rhs.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sub_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sub_epi64)\n\n\n [`VPSUBQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PSUBQ.html): Subtract Packed Quadword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSUBQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[0;1]</td>\n <td>0.33</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn sub(self, rhs: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0].wrapping_sub(rhs.as_array()[0]),
            self.as_array()[1].wrapping_sub(rhs.as_array()[1]),
            self.as_array()[2].wrapping_sub(rhs.as_array()[2]),
            self.as_array()[3].wrapping_sub(rhs.as_array()[3]),
        ])
    }
}
impl U64x4 {
    #[doc(hidden)]
    pub const fn new_from_const_raw_vector(x: U64x4Internal) -> Self {
        Self(x)
    }
}
impl From<[u64; 4]> for U64x4 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_loadu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_loadu_si256)\n\n\n [`VMOVDQU (YMM, M256)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKL\">Skylake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_YMM_M256.html#CLX\">Cascade Lake</a></td>\n <td>[&le;5;&le;8]</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(array: [u64; 4]) -> U64x4 {
        U64x4(array)
    }
}
impl From<U64x4> for [u64; 4] {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_storeu_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256)\n\n\n [`VMOVDQU (M256, YMM)`](https://felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html): Move Unaligned Packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VMOVDQU_M256_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;4;&le;10]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U64x4) -> [u64; 4] {
        vector.0
    }
}
impl From<I8x32> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I8x32\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: I8x32) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I16x16> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I16x16\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: I16x16) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I32x8> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I32x8\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: I32x8) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<I64x4> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of I64x4\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: I64x4) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U8x32> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U8x32\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: U8x32) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U16x16> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U16x16\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: U16x16) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x8> for U64x4 {
    #[doc = "This cast is 100% free. It reinterprets the little-endinan bits of U32x8\nas little endian bits of U64x4."]
    #[inline(always)]
    fn from(x: U32x8) -> U64x4 {
        Self({
            #[cfg(target_endian = "little")]
            bytemuck::cast(x.0) // TODO: big endian.
        })
    }
}
impl From<U32x4> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U32x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n         u64::from(vector.as_array()[0]),\n         u64::from(vector.as_array()[1]),\n         u64::from(vector.as_array()[2]),\n         u64::from(vector.as_array()[3]),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cvtepu32_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepu32_epi64)\n\n\n [`VPMOVZXDQ (YMM, XMM)`](https://felixcloutier.com/x86/PMOVZX.html): Packed Move with Zero Extend\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXDQ_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXDQ_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMOVZXDQ_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U32x4) -> U64x4 {
        U64x4::from([
            u64::from(vector.as_array()[0]),
            u64::from(vector.as_array()[1]),
            u64::from(vector.as_array()[2]),
            u64::from(vector.as_array()[3]),
        ])
    }
}
impl From<U64x2> for U64x4 {
    #[doc = " NOTE: this will _zero_ the upper bits of the destination. Other\n intrinsics are more effcient, but leave the upper bits undefined.\n At present, these more effcient intrinsics are not exposed.\n\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U64x2  ,\n # )  -> U64x4\n # {\n let mut out = [0; 4];\n out[0..2].copy_from_slice(&vector.as_array());\n U64x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_zextsi128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_zextsi128_si256)\n\n\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U64x2) -> U64x4 {
        let mut out = [0; 4];
        out[0..2].copy_from_slice(&vector.as_array());
        U64x4::from(out)
    }
}
impl From<[U64x2; 2]> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vectors  : [U64x2; 2]  ,\n # )  -> U64x4\n # {\n let mut out = [0; 4];\n out[0..2].copy_from_slice(&vectors[0].as_array());\n out[2..].copy_from_slice(&vectors[1].as_array());\n U64x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_m128i`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_m128i)\n\n\n [`VINSERTF128 (YMM, YMM, XMM, I8)`](https://felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html): Insert Packed Floating-Point Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VINSERTF128_YMM_YMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vectors: [U64x2; 2]) -> U64x4 {
        let mut out = [0; 4];
        out[0..2].copy_from_slice(&vectors[0].as_array());
        out[2..].copy_from_slice(&vectors[1].as_array());
        U64x4::from(out)
    }
} // TODO: this doesn't show up in the docs.
impl From<U64x4> for [U64x2; 2] {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U64x4  ,\n # )  -> [U64x2; 2]\n # {\n let mut lo = [0; 2];\n let mut hi = [0; 2];\n lo.copy_from_slice(&vector.as_array()[0..2]);\n hi.copy_from_slice(&vector.as_array()[2..]);\n [U64x2::from(lo), U64x2::from(hi)]\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extracti128_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extracti128_si256)\n\n\n [`VEXTRACTI128 (XMM, YMM, I8)`](https://felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html): Extract packed Integer Values\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VEXTRACTI128_XMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn from(vector: U64x4) -> [U64x2; 2] {
        let mut lo = [0; 2];
        let mut hi = [0; 2];
        lo.copy_from_slice(&vector.as_array()[0..2]);
        hi.copy_from_slice(&vector.as_array()[2..]);
        [U64x2::from(lo), U64x2::from(hi)]
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u64, i32, I32x4> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : I32x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i32gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i32gather_epi64)\n\n\n [`VPGATHERDQ (YMM, VSIB_XMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u64, indices: I32x4) -> U64x4 {
        U64x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : I32x4  ,\n #         mask  : U64x4  ,\n #         src  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     if (mask.as_array()[0] >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 63) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 63) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i32gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i32gather_epi64)\n\n\n [`VPGATHERDQ (YMM, VSIB_XMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERDQ_YMM_VSIB_XMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u64, indices: I32x4, mask: U64x4, src: U64x4) -> U64x4 {
        U64x4::from([
            if (mask.as_array()[0] >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 63) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 63) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u64, u64, U64x4> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u64, indices: U64x4) -> U64x4 {
        U64x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : U64x4  ,\n #         mask  : U64x4  ,\n #         src  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     if (mask.as_array()[0] >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 63) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 63) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u64, indices: U64x4, mask: U64x4, src: U64x4) -> U64x4 {
        U64x4::from([
            if (mask.as_array()[0] >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 63) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 63) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
}
#[doc = "# Safety\n`base` does not need to be aligned. Forall `i`, `base + indices[i]` must meet\nthe safety requirements of [std::ptr::read_unaligned]"]
impl crate::SimdBaseGatherable<u64, i64, I64x4> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : I64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     base.offset(indices.as_array()[0] as isize).read_unaligned(),\n     base.offset(indices.as_array()[1] as isize).read_unaligned(),\n     base.offset(indices.as_array()[2] as isize).read_unaligned(),\n     base.offset(indices.as_array()[3] as isize).read_unaligned(),\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather(base: *const u64, indices: I64x4) -> U64x4 {
        U64x4::from([
            base.offset(indices.as_array()[0] as isize).read_unaligned(),
            base.offset(indices.as_array()[1] as isize).read_unaligned(),
            base.offset(indices.as_array()[2] as isize).read_unaligned(),
            base.offset(indices.as_array()[3] as isize).read_unaligned(),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # unsafe\n # fn the_doc_function\n # (\n #         base  : *const u64  ,\n #         indices  : I64x4  ,\n #         mask  : U64x4  ,\n #         src  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     if (mask.as_array()[0] >> 63) == 1 {\n         base.offset(indices.as_array()[0] as isize).read_unaligned()\n     } else {\n         src.as_array()[0]\n     },\n     if (mask.as_array()[1] >> 63) == 1 {\n         base.offset(indices.as_array()[1] as isize).read_unaligned()\n     } else {\n         src.as_array()[1]\n     },\n     if (mask.as_array()[2] >> 63) == 1 {\n         base.offset(indices.as_array()[2] as isize).read_unaligned()\n     } else {\n         src.as_array()[2]\n     },\n     if (mask.as_array()[3] >> 63) == 1 {\n         base.offset(indices.as_array()[3] as isize).read_unaligned()\n     } else {\n         src.as_array()[3]\n     },\n ])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mask_i64gather_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mask_i64gather_epi64)\n\n\n [`VPGATHERQQ (YMM, VSIB_YMM, YMM)`](https://felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html): Gather Packed Qword Values Using Signed Dword/Qword Indices\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPGATHERQQ_YMM_VSIB_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>[&le;0;20]</td>\n <td>4.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    unsafe fn gather_masked(base: *const u64, indices: I64x4, mask: U64x4, src: U64x4) -> U64x4 {
        U64x4::from([
            if (mask.as_array()[0] >> 63) == 1 {
                base.offset(indices.as_array()[0] as isize).read_unaligned()
            } else {
                src.as_array()[0]
            },
            if (mask.as_array()[1] >> 63) == 1 {
                base.offset(indices.as_array()[1] as isize).read_unaligned()
            } else {
                src.as_array()[1]
            },
            if (mask.as_array()[2] >> 63) == 1 {
                base.offset(indices.as_array()[2] as isize).read_unaligned()
            } else {
                src.as_array()[2]
            },
            if (mask.as_array()[3] >> 63) == 1 {
                base.offset(indices.as_array()[3] as isize).read_unaligned()
            } else {
                src.as_array()[3]
            },
        ])
    }
} // Static shift
impl ShlAssign<u64> for U64x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: u64) {
        *self = (*self) << amount;
    }
}
impl Shl<u64> for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x4\n # {\n if amount >= 64 {\n     U64x4::ZERO\n } else {\n     U64x4::from([\n         self.as_array()[0] << amount,\n         self.as_array()[1] << amount,\n         self.as_array()[2] << amount,\n         self.as_array()[3] << amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sll_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sll_epi64)\n\n\n [`VPSLLQ (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: u64) -> U64x4 {
        if amount >= 64 {
            U64x4::ZERO
        } else {
            U64x4::from([
                self.as_array()[0] << amount,
                self.as_array()[1] << amount,
                self.as_array()[2] << amount,
                self.as_array()[3] << amount,
            ])
        }
    }
} // Variable shift
impl ShlAssign<U64x4> for U64x4 {
    #[inline(always)]
    fn shl_assign(&mut self, amount: U64x4) {
        *self = (*self) << amount;
    }
}
impl Shl<U64x4> for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x4  ,\n # )  -> U64x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64  {\n         0\n     } else {\n         *x << amm\n     };\n }\n U64x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_sllv_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_sllv_epi64)\n\n\n [`VPSLLVQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html): Variable Bit Shift Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLVQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shl(self, amount: U64x4) -> U64x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 { 0 } else { *x << amm };
        }
        U64x4::from(out)
    }
} // Static shift
impl ShrAssign<u64> for U64x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: u64) {
        *self = (*self) >> amount;
    }
}
impl Shr<u64> for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : u64  ,\n # )  -> U64x4\n # {\n if amount >= 64 {\n     U64x4::ZERO\n } else {\n     U64x4::from([\n         self.as_array()[0] >> amount,\n         self.as_array()[1] >> amount,\n         self.as_array()[2] >> amount,\n         self.as_array()[3] >> amount,\n     ])\n }\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srl_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srl_epi64)\n\n\n [`VPSRLQ (YMM, YMM, XMM)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLQ_YMM_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLQ_YMM_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLQ_YMM_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>[3;4]</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: u64) -> U64x4 {
        if amount >= 64 {
            U64x4::ZERO
        } else {
            U64x4::from([
                self.as_array()[0] >> amount,
                self.as_array()[1] >> amount,
                self.as_array()[2] >> amount,
                self.as_array()[3] >> amount,
            ])
        }
    }
} // Variable shift
impl ShrAssign<U64x4> for U64x4 {
    #[inline(always)]
    fn shr_assign(&mut self, amount: U64x4) {
        *self = (*self) >> amount;
    }
}
impl Shr<U64x4> for U64x4 {
    type Output = Self;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         self  ,\n #         amount  : U64x4  ,\n # )  -> U64x4\n # {\n let mut out = self.as_array();\n for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {\n     *x = if amm >= 64  {\n         0\n     } else {\n         *x >> amm\n     };\n }\n U64x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srlv_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srlv_epi64)\n\n\n [`VPSRLVQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html): Variable Bit Shift Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLVQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shr(self, amount: U64x4) -> U64x4 {
        let mut out = self.as_array();
        for (x, amm) in out.iter_mut().zip(amount.as_array().iter().copied()) {
            *x = if amm >= 64 { 0 } else { *x >> amm };
        }
        U64x4::from(out)
    }
}
impl SimdBase<u64> for U64x4 {
    type Array = [u64; 4];
    type Signed = I64x4;
    type Unsigned = U64x4;
    const LANES: usize = 4;
    const ZERO: Self = { Self([0; 4]) };
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n # )  -> bool\n # {\n self.as_array().iter().all(|x| *x == 0)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_testz_si256`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_testz_si256)\n\n\n [`VPTEST (YMM, YMM)`](https://felixcloutier.com/x86/PTEST.html): Logical Compare\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPTEST_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>&le;6</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn is_zero(&self) -> bool {
        self.as_array().iter().all(|x| *x == 0)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u64  ,\n # )  -> U64x4\n # {\n let mut out = [0; 4];\n out[0] = scalar;\n U64x4::from(out)\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn set_lo(scalar: u64) -> U64x4 {
        let mut out = [0; 4];
        out[0] = scalar;
        U64x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u64\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n #     <\n #             const I: usize,\n #     >\n # (\n #         &self  ,\n # )  -> u64\n # {\n self.as_array()[I]\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_extract_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_extract_epi64)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn extract<const I: usize>(&self) -> u64 {
        self.as_array()[I]
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         scalar  : u64  ,\n # )  -> U64x4\n # {\n U64x4::from([scalar; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_set1_epi64x`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_set1_epi64x)\n\n\n Instruction sequence.\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast(scalar: u64) -> U64x4 {
        U64x4::from([scalar; 4])
    }
    type BroadcastLoInput = U64x2;
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # fn the_doc_function\n # (\n #         vector  : U64x2  ,\n # )  -> U64x4\n # {\n U64x4::from([vector.as_array()[0]; 4])\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_broadcastq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastq_epi64)\n\n\n [`VPBROADCASTQ (YMM, XMM)`](https://felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html): Load with Broadcast Integer Data from General Purpose Register\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_YMM_XMM.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_YMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBROADCASTQ_YMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn broadcast_lo(vector: U64x2) -> U64x4 {
        U64x4::from([vector.as_array()[0]; 4])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     if self.as_array()[0] == other.as_array()[0] {  u64::MAX  } else { 0 },\n     if self.as_array()[1] == other.as_array()[1] {  u64::MAX  } else { 0 },\n     if self.as_array()[2] == other.as_array()[2] {  u64::MAX  } else { 0 },\n     if self.as_array()[3] == other.as_array()[3] {  u64::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_cmpeq_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpeq_epi64)\n\n\n [`VPCMPEQQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PCMPEQQ.html): Compare Packed Qword Data for Equal\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPCMPEQQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn cmp_eq(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            if self.as_array()[0] == other.as_array()[0] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[1] == other.as_array()[1] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[2] == other.as_array()[2] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[3] == other.as_array()[3] {
                u64::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     if self.as_array()[0] > other.as_array()[0] {  u64::MAX  } else { 0 },\n     if self.as_array()[1] > other.as_array()[1] {  u64::MAX  } else { 0 },\n     if self.as_array()[2] > other.as_array()[2] {  u64::MAX  } else { 0 },\n     if self.as_array()[3] > other.as_array()[3] {  u64::MAX  } else { 0 },\n ])\n # }\n # }\n ```\n # Avx2\n **NOTE:** this implementation uses an efficient vector polyfill, though this operation is not natively supported.\n ```ignore\n // Based on https://stackoverflow.com/a/33173643 and https://git.io/JmghK\n let sign_bit = Self::broadcast(1 << 63);\n Self::from(I64x4::from(*self ^ sign_bit).cmp_gt(\n     I64x4::from(other ^ sign_bit)\n ))\n ```"]
    #[inline(always)]
    fn cmp_gt(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            if self.as_array()[0] > other.as_array()[0] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[1] > other.as_array()[1] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[2] > other.as_array()[2] {
                u64::MAX
            } else {
                0
            },
            if self.as_array()[3] > other.as_array()[3] {
                u64::MAX
            } else {
                0
            },
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x <<= BITS;\n }\n U64x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_slli_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_slli_epi64)\n\n\n [`VPSLLQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html): Shift Packed Data Left Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSLLQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_left<const BITS: usize>(&self) -> U64x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x <<= BITS;
        }
        U64x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n #     <\n #             const BITS: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x4\n # {\n let mut out = self.as_array();\n for x in out.iter_mut() {\n     *x >>= BITS;\n }\n U64x4::from(out)\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_srli_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_srli_epi64)\n\n\n [`VPSRLQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html): Shift Packed Data Right Logical\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPSRLQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shift_right<const BITS: usize>(&self) -> U64x4 {
        let mut out = self.as_array();
        for x in out.iter_mut() {
            *x >>= BITS;
        }
        U64x4::from(out)
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     // Lane# 0\n     self.as_array()[0],\n     other.as_array()[0],\n     // Lane# 1\n     self.as_array()[2],\n     other.as_array()[2],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpacklo_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpacklo_epi64)\n\n\n [`VPUNPCKLQDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html): Unpack Low Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLQDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLQDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKLQDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_lo(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            // Lane# 0
            self.as_array()[0],
            other.as_array()[0], // Lane# 1
            self.as_array()[2],
            other.as_array()[2],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     // Lane# 0\n     self.as_array()[1],\n     other.as_array()[1],\n     // Lane# 1\n     self.as_array()[3],\n     other.as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_unpackhi_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_unpackhi_epi64)\n\n\n [`VPUNPCKHQDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html): Unpack High Data\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHQDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHQDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPUNPCKHQDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn unpack_hi(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            // Lane# 0
            self.as_array()[1],
            other.as_array()[1], // Lane# 1
            self.as_array()[3],
            other.as_array()[3],
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0].max(other.as_array()[0]),\n     self.as_array()[1].max(other.as_array()[1]),\n     self.as_array()[2].max(other.as_array()[2]),\n     self.as_array()[3].max(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn max(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0].max(other.as_array()[0]),
            self.as_array()[1].max(other.as_array()[1]),
            self.as_array()[2].max(other.as_array()[2]),
            self.as_array()[3].max(other.as_array()[3]),
        ])
    }
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[0].min(other.as_array()[0]),\n     self.as_array()[1].min(other.as_array()[1]),\n     self.as_array()[2].min(other.as_array()[2]),\n     self.as_array()[3].min(other.as_array()[3]),\n ])\n # }\n # }\n ```\n # Avx2\n **WARNING:** this implementation is a polyfill which executes the scalar implemenation."]
    #[inline(always)]
    fn min(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            self.as_array()[0].min(other.as_array()[0]),
            self.as_array()[1].min(other.as_array()[1]),
            self.as_array()[2].min(other.as_array()[2]),
            self.as_array()[3].min(other.as_array()[3]),
        ])
    }
}
impl crate::SimdBase4x<u64> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n #     <\n #             const B3: bool,\n #             const B2: bool,\n #             const B1: bool,\n #             const B0: bool,\n #     >\n # (\n #         &self  ,\n #         if_true  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n         (if B0 { if_true } else { *self }).as_array()[0],\n         (if B1 { if_true } else { *self }).as_array()[1],\n         (if B2 { if_true } else { *self }).as_array()[2],\n         (if B3 { if_true } else { *self }).as_array()[3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_blend_epi32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_blend_epi32)\n\n\n [`VPBLENDD (YMM, YMM, YMM, I8)`](https://felixcloutier.com/x86/VPBLENDD.html): Blend Packed Dwords\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPBLENDD_YMM_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>1</td>\n <td>0.38</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn blend<const B3: bool, const B2: bool, const B1: bool, const B0: bool>(
        &self,
        if_true: U64x4,
    ) -> U64x4 {
        U64x4::from([
            (if B0 { if_true } else { *self }).as_array()[0],
            (if B1 { if_true } else { *self }).as_array()[1],
            (if B2 { if_true } else { *self }).as_array()[2],
            (if B3 { if_true } else { *self }).as_array()[3],
        ])
    }
}
impl crate::SimdBase64<u64> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n # (\n #         &self  ,\n #         other  : U64x4  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     ((self.as_array()[0] as u32) as u64) * ((other.as_array()[0] as u32) as u64),\n     ((self.as_array()[1] as u32) as u64) * ((other.as_array()[1] as u32) as u64),\n     ((self.as_array()[2] as u32) as u64) * ((other.as_array()[2] as u32) as u64),\n     ((self.as_array()[3] as u32) as u64) * ((other.as_array()[3] as u32) as u64),\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_mul_epu32`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_mul_epu32)\n\n\n [`VPMULUDQ (YMM, YMM, YMM)`](https://felixcloutier.com/x86/PMULUDQ.html): Multiply Packed Unsigned Doubleword Integers\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMULUDQ_YMM_YMM_YMM.html#SKL\">Skylake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMULUDQ_YMM_YMM_YMM.html#SKX\">Skylake-AVX512</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPMULUDQ_YMM_YMM_YMM.html#CLX\">Cascade Lake</a></td>\n <td>5</td>\n <td>0.50</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn mul_lo(&self, other: U64x4) -> U64x4 {
        U64x4::from([
            ((self.as_array()[0] as u32) as u64) * ((other.as_array()[0] as u32) as u64),
            ((self.as_array()[1] as u32) as u64) * ((other.as_array()[1] as u32) as u64),
            ((self.as_array()[2] as u32) as u64) * ((other.as_array()[2] as u32) as u64),
            ((self.as_array()[3] as u32) as u64) * ((other.as_array()[3] as u32) as u64),
        ])
    }
}
impl crate::SimdBase4x64<u64> for U64x4 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x4\n # ;}\n # impl SomeTraitForDoc for U64x4 {\n # fn the_doc_function\n #     <\n #             const I3: usize,\n #             const I2: usize,\n #             const I1: usize,\n #             const I0: usize,\n #     >\n # (\n #         &self  ,\n # )  -> U64x4\n # {\n U64x4::from([\n     self.as_array()[I0],\n     self.as_array()[I1],\n     self.as_array()[I2],\n     self.as_array()[I3],\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm256_permute4x64_epi64`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_permute4x64_epi64)\n\n\n [`VPERMQ (YMM, YMM, I8)`](https://felixcloutier.com/x86/VPERMQ.html): Qwords Element Permutation\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPERMQ_YMM_YMM_I8.html#SKL\">Skylake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPERMQ_YMM_YMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/VPERMQ_YMM_YMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>3</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    fn shuffle<const I3: usize, const I2: usize, const I1: usize, const I0: usize>(&self) -> U64x4 {
        U64x4::from([
            self.as_array()[I0],
            self.as_array()[I1],
            self.as_array()[I2],
            self.as_array()[I3],
        ])
    }
}
impl U64x2 {
    #[doc = "\n # Scalar Equivalent:\n ```\n # use vectoreyes::*;\n # trait SomeTraitForDoc {\n # fn the_doc_function\n #     <\n #             const HI_OTHER: bool,\n #             const HI_SELF: bool,\n #     >\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # ;}\n # impl SomeTraitForDoc for U64x2 {\n # fn the_doc_function\n #     <\n #             const HI_OTHER: bool,\n #             const HI_SELF: bool,\n #     >\n # (\n #         &self  ,\n #         other  : U64x2  ,\n # )  -> U64x2\n # {\n  let x = if HI_SELF { self.as_array()[1] } else { self.as_array()[0] };\n  let y = if HI_OTHER { other.as_array()[1] } else { other.as_array()[0] };\n // This software carryless-multplication implementation is from https://github.com/RustCrypto/universal-hashes/blob/2e8a948dbb25bc2ac6c712b4bdc21b158527ca70/polyval/src/backend/soft64.rs\n // That code is MIT/Apache dual-licensed.\n #[inline(always)]\n fn bmul64(x: u64, y: u64) -> u64 {\n     use std::num::Wrapping;\n     let x0 = Wrapping(x & 0x1111_1111_1111_1111);\n     let x1 = Wrapping(x & 0x2222_2222_2222_2222);\n     let x2 = Wrapping(x & 0x4444_4444_4444_4444);\n     let x3 = Wrapping(x & 0x8888_8888_8888_8888);\n     let y0 = Wrapping(y & 0x1111_1111_1111_1111);\n     let y1 = Wrapping(y & 0x2222_2222_2222_2222);\n     let y2 = Wrapping(y & 0x4444_4444_4444_4444);\n     let y3 = Wrapping(y & 0x8888_8888_8888_8888);\n     let mut z0 = ((x0 * y0) ^ (x1 * y3) ^ (x2 * y2) ^ (x3 * y1)).0;\n     let mut z1 = ((x0 * y1) ^ (x1 * y0) ^ (x2 * y3) ^ (x3 * y2)).0;\n     let mut z2 = ((x0 * y2) ^ (x1 * y1) ^ (x2 * y0) ^ (x3 * y3)).0;\n     let mut z3 = ((x0 * y3) ^ (x1 * y2) ^ (x2 * y1) ^ (x3 * y0)).0;\n     z0 &= 0x1111_1111_1111_1111;\n     z1 &= 0x2222_2222_2222_2222;\n     z2 &= 0x4444_4444_4444_4444;\n     z3 &= 0x8888_8888_8888_8888;\n     z0 | z1 | z2 | z3\n }\n #[inline(always)]\n fn rev64(mut x: u64) -> u64 {\n     x = ((x & 0x5555_5555_5555_5555) << 1) | ((x >> 1) & 0x5555_5555_5555_5555);\n     x = ((x & 0x3333_3333_3333_3333) << 2) | ((x >> 2) & 0x3333_3333_3333_3333);\n     x = ((x & 0x0f0f_0f0f_0f0f_0f0f) << 4) | ((x >> 4) & 0x0f0f_0f0f_0f0f_0f0f);\n     x = ((x & 0x00ff_00ff_00ff_00ff) << 8) | ((x >> 8) & 0x00ff_00ff_00ff_00ff);\n     x = ((x & 0xffff_0000_ffff) << 16) | ((x >> 16) & 0xffff_0000_ffff);\n     (x << 32) | (x >> 32)\n }\n U64x2::from([\n     bmul64(x, y),\n     rev64(bmul64(rev64(x), rev64(y))) >> 1,\n ])\n # }\n # }\n ```\n # Avx2\n <ul>\n <li>\n\n [**`_mm_clmulepi64_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_clmulepi64_si128)\n\n\n [`PCLMULQDQ (XMM, XMM, I8)`](https://felixcloutier.com/x86/PCLMULQDQ.html): Carry-Less Multiplication Quadword\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCLMULQDQ_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>7</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCLMULQDQ_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>7</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/PCLMULQDQ_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>7</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub fn carryless_mul<const HI_OTHER: bool, const HI_SELF: bool>(&self, other: U64x2) -> U64x2 {
        let x = if HI_SELF {
            self.as_array()[1]
        } else {
            self.as_array()[0]
        };
        let y = if HI_OTHER {
            other.as_array()[1]
        } else {
            other.as_array()[0]
        }; // This software carryless-multplication implementation is from https://github.com/RustCrypto/universal-hashes/blob/2e8a948dbb25bc2ac6c712b4bdc21b158527ca70/polyval/src/backend/soft64.rs
           // That code is MIT/Apache dual-licensed.
        #[inline(always)]
        fn bmul64(x: u64, y: u64) -> u64 {
            use std::num::Wrapping;
            let x0 = Wrapping(x & 0x1111_1111_1111_1111);
            let x1 = Wrapping(x & 0x2222_2222_2222_2222);
            let x2 = Wrapping(x & 0x4444_4444_4444_4444);
            let x3 = Wrapping(x & 0x8888_8888_8888_8888);
            let y0 = Wrapping(y & 0x1111_1111_1111_1111);
            let y1 = Wrapping(y & 0x2222_2222_2222_2222);
            let y2 = Wrapping(y & 0x4444_4444_4444_4444);
            let y3 = Wrapping(y & 0x8888_8888_8888_8888);
            let mut z0 = ((x0 * y0) ^ (x1 * y3) ^ (x2 * y2) ^ (x3 * y1)).0;
            let mut z1 = ((x0 * y1) ^ (x1 * y0) ^ (x2 * y3) ^ (x3 * y2)).0;
            let mut z2 = ((x0 * y2) ^ (x1 * y1) ^ (x2 * y0) ^ (x3 * y3)).0;
            let mut z3 = ((x0 * y3) ^ (x1 * y2) ^ (x2 * y1) ^ (x3 * y0)).0;
            z0 &= 0x1111_1111_1111_1111;
            z1 &= 0x2222_2222_2222_2222;
            z2 &= 0x4444_4444_4444_4444;
            z3 &= 0x8888_8888_8888_8888;
            z0 | z1 | z2 | z3
        }
        #[inline(always)]
        fn rev64(mut x: u64) -> u64 {
            x = ((x & 0x5555_5555_5555_5555) << 1) | ((x >> 1) & 0x5555_5555_5555_5555);
            x = ((x & 0x3333_3333_3333_3333) << 2) | ((x >> 2) & 0x3333_3333_3333_3333);
            x = ((x & 0x0f0f_0f0f_0f0f_0f0f) << 4) | ((x >> 4) & 0x0f0f_0f0f_0f0f_0f0f);
            x = ((x & 0x00ff_00ff_00ff_00ff) << 8) | ((x >> 8) & 0x00ff_00ff_00ff_00ff);
            x = ((x & 0xffff_0000_ffff) << 16) | ((x >> 16) & 0xffff_0000_ffff);
            (x << 32) | (x >> 32)
        }
        U64x2::from([bmul64(x, y), rev64(bmul64(rev64(x), rev64(y))) >> 1])
    }
} // TODO: add Aes192
  // This code is based on https://github.com/RustCrypto/block-ciphers/tree/5389542d0306c718eda37bab890bc67772bd1e69/aes
  // That code is MIT/Apache dual-licensed
  // The original MIT license for the AES-NI code is reproduced below:
  // Copyright (c) 2018 Artyom Pavlov
  //
  // Permission is hereby granted, free of charge, to any
  // person obtaining a copy of this software and associated
  // documentation files (the "Software"), to deal in the
  // Software without restriction, including without
  // limitation the rights to use, copy, modify, merge,
  // publish, distribute, sublicense, and/or sell copies of
  // the Software, and to permit persons to whom the Software
  // is furnished to do so, subject to the following
  // conditions:
  //
  // The above copyright notice and this permission notice
  // shall be included in all copies or substantial portions
  // of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF
  // ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
  // TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  // PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT
  // SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  // CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
  // OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
  // IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  // DEALINGS IN THE SOFTWARE.
#[derive(Clone)]
enum Aes128KeySchedule {
    Variable(aes_soft::Aes128), // TODO: if we care a lot about scalar performance, this could be quite slow.
    Fixed,
}
impl From<aes_soft::Aes128> for Aes128KeySchedule {
    #[inline(always)]
    fn from(x: aes_soft::Aes128) -> Self {
        Self::Variable(x)
    }
}
impl Deref for Aes128KeySchedule {
    type Target = aes_soft::Aes128;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        lazy_static::lazy_static! { static ref FIXED_AES_128: aes_soft::Aes128 = { use aes_soft::cipher::{NewBlockCipher, generic_array::GenericArray}; aes_soft::Aes128::new(&GenericArray::from([189, 36, 0, 193, 18, 65, 206, 51, 237, 61, 125, 199, 168, 86, 64, 37])) }; }
        match self {
            Self::Variable(aes) => aes,
            Self::Fixed => FIXED_AES_128.deref(),
        }
    }
}
type Aes128EncryptOnlyKeySchedule = Aes128KeySchedule;
#[derive(Clone)]
pub struct Aes128 {
    key: Aes128KeySchedule,
}
impl std::fmt::Debug for Aes128 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Aes128(...)")
    }
}
impl Aes128 {
    pub(super) const FIXED_KEY: Self = Self {
        key: { Aes128KeySchedule::Fixed },
    };
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesimc_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesimc_si128)\n\n\n [`AESIMC (XMM, XMM)`](https://felixcloutier.com/x86/AESIMC.html): Perform the AES InvMixColumn Transformation\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESIMC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>8</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESIMC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>8</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESIMC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>8</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aeskeygenassist_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aeskeygenassist_si128)\n\n\n [`AESKEYGENASSIST (XMM, XMM, I8)`](https://felixcloutier.com/x86/AESKEYGENASSIST.html): AES Round Key Generation Assist\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn new_with_key(key: U8x16) -> Self {
        use aes_soft::cipher::{generic_array::GenericArray, NewBlockCipher};
        let key_bytes = key.as_array();
        Aes128 {
            key: aes_soft::Aes128::new(&GenericArray::from(key_bytes)).into(),
        }
    }
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesenc_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenc_si128)\n\n\n [`AESENC (XMM, XMM)`](https://felixcloutier.com/x86/AESENC.html): Perform One Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aesenclast_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenclast_si128)\n\n\n [`AESENCLAST (XMM, XMM)`](https://felixcloutier.com/x86/AESENCLAST.html): Perform Last Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn encrypt_many<const N: usize>(&self, blocks: [U8x16; N]) -> [U8x16; N]
    where
        ArrayUnrolledOps: UnrollableArraySize<N>,
    {
        use aes_soft::cipher::{generic_array::GenericArray, BlockCipher}; // TODO: support ParBlocks
        blocks.array_map(
            #[inline(always)]
            |block| {
                let mut block = GenericArray::from(block.as_array());
                (*self.key).encrypt_block(&mut block);
                U8x16::from(<[u8; 16]>::from(block))
            },
        )
    }
}
impl Aes128 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesdec_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesdec_si128)\n\n\n [`AESDEC (XMM, XMM)`](https://felixcloutier.com/x86/AESDEC.html): Perform One Round of an AES Decryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDEC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDEC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDEC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aesdeclast_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesdeclast_si128)\n\n\n [`AESDECLAST (XMM, XMM)`](https://felixcloutier.com/x86/AESDECLAST.html): Perform Last Round of an AES Decryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDECLAST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDECLAST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDECLAST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn decrypt_many<const N: usize>(&self, blocks: [U8x16; N]) -> [U8x16; N]
    where
        ArrayUnrolledOps: UnrollableArraySize<N>,
    {
        use aes_soft::cipher::{generic_array::GenericArray, BlockCipher}; // TODO: support ParBlocks
        blocks.array_map(
            #[inline(always)]
            |block| {
                let mut block = GenericArray::from(block.as_array());
                (*self.key).decrypt_block(&mut block);
                U8x16::from(<[u8; 16]>::from(block))
            },
        )
    }
}
impl From<Aes128> for Aes128EncryptOnly {
    #[doc = "\n # Avx2"]
    #[inline(always)]
    fn from(aes: Aes128) -> Aes128EncryptOnly {
        Aes128EncryptOnly { key: aes.key }
    }
}
#[derive(Clone)]
pub struct Aes128EncryptOnly {
    key: Aes128EncryptOnlyKeySchedule,
}
impl std::fmt::Debug for Aes128EncryptOnly {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Aes128EncryptOnly(...)")
    }
}
impl Aes128EncryptOnly {
    pub(super) const FIXED_KEY: Self = Self {
        key: { Aes128KeySchedule::Fixed },
    };
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aeskeygenassist_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aeskeygenassist_si128)\n\n\n [`AESKEYGENASSIST (XMM, XMM, I8)`](https://felixcloutier.com/x86/AESKEYGENASSIST.html): AES Round Key Generation Assist\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn new_with_key(key: U8x16) -> Self {
        use aes_soft::cipher::{generic_array::GenericArray, NewBlockCipher};
        let key_bytes = key.as_array();
        Aes128EncryptOnly {
            key: aes_soft::Aes128::new(&GenericArray::from(key_bytes)).into(),
        }
    }
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesenc_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenc_si128)\n\n\n [`AESENC (XMM, XMM)`](https://felixcloutier.com/x86/AESENC.html): Perform One Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aesenclast_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenclast_si128)\n\n\n [`AESENCLAST (XMM, XMM)`](https://felixcloutier.com/x86/AESENCLAST.html): Perform Last Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn encrypt_many<const N: usize>(&self, blocks: [U8x16; N]) -> [U8x16; N]
    where
        ArrayUnrolledOps: UnrollableArraySize<N>,
    {
        use aes_soft::cipher::{generic_array::GenericArray, BlockCipher}; // TODO: support ParBlocks
        blocks.array_map(
            #[inline(always)]
            |block| {
                let mut block = GenericArray::from(block.as_array());
                (*self.key).encrypt_block(&mut block);
                U8x16::from(<[u8; 16]>::from(block))
            },
        )
    }
}
#[derive(Clone)]
enum Aes256KeySchedule {
    Variable(aes_soft::Aes256), // TODO: if we care a lot about scalar performance, this could be quite slow.
    Fixed,
}
impl From<aes_soft::Aes256> for Aes256KeySchedule {
    #[inline(always)]
    fn from(x: aes_soft::Aes256) -> Self {
        Self::Variable(x)
    }
}
impl Deref for Aes256KeySchedule {
    type Target = aes_soft::Aes256;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        lazy_static::lazy_static! { static ref FIXED_AES_256: aes_soft::Aes256 = { use aes_soft::cipher::{NewBlockCipher, generic_array::GenericArray}; aes_soft::Aes256::new(&GenericArray::from([156, 63, 253, 81, 157, 52, 243, 206, 213, 76, 200, 118, 144, 71, 141, 110, 23, 19, 106, 206, 52, 29, 51, 6, 102, 136, 149, 40, 59, 234, 162, 127])) }; }
        match self {
            Self::Variable(aes) => aes,
            Self::Fixed => FIXED_AES_256.deref(),
        }
    }
}
type Aes256EncryptOnlyKeySchedule = Aes256KeySchedule;
#[derive(Clone)]
pub struct Aes256 {
    key: Aes256KeySchedule,
}
impl std::fmt::Debug for Aes256 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Aes256(...)")
    }
}
impl Aes256 {
    pub(super) const FIXED_KEY: Self = Self {
        key: { Aes256KeySchedule::Fixed },
    };
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesimc_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesimc_si128)\n\n\n [`AESIMC (XMM, XMM)`](https://felixcloutier.com/x86/AESIMC.html): Perform the AES InvMixColumn Transformation\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESIMC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>8</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESIMC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>8</td>\n <td>2.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESIMC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>8</td>\n <td>2.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aeskeygenassist_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aeskeygenassist_si128)\n\n\n [`AESKEYGENASSIST (XMM, XMM, I8)`](https://felixcloutier.com/x86/AESKEYGENASSIST.html): AES Round Key Generation Assist\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn new_with_key(key: U8x32) -> Self {
        use aes_soft::cipher::{generic_array::GenericArray, NewBlockCipher};
        let key_bytes = key.as_array();
        Aes256 {
            key: aes_soft::Aes256::new(&GenericArray::from(key_bytes)).into(),
        }
    }
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesenc_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenc_si128)\n\n\n [`AESENC (XMM, XMM)`](https://felixcloutier.com/x86/AESENC.html): Perform One Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aesenclast_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenclast_si128)\n\n\n [`AESENCLAST (XMM, XMM)`](https://felixcloutier.com/x86/AESENCLAST.html): Perform Last Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn encrypt_many<const N: usize>(&self, blocks: [U8x16; N]) -> [U8x16; N]
    where
        ArrayUnrolledOps: UnrollableArraySize<N>,
    {
        use aes_soft::cipher::{generic_array::GenericArray, BlockCipher}; // TODO: support ParBlocks
        blocks.array_map(
            #[inline(always)]
            |block| {
                let mut block = GenericArray::from(block.as_array());
                (*self.key).encrypt_block(&mut block);
                U8x16::from(<[u8; 16]>::from(block))
            },
        )
    }
}
impl Aes256 {
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesdec_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesdec_si128)\n\n\n [`AESDEC (XMM, XMM)`](https://felixcloutier.com/x86/AESDEC.html): Perform One Round of an AES Decryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDEC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDEC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDEC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aesdeclast_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesdeclast_si128)\n\n\n [`AESDECLAST (XMM, XMM)`](https://felixcloutier.com/x86/AESDECLAST.html): Perform Last Round of an AES Decryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDECLAST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDECLAST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESDECLAST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn decrypt_many<const N: usize>(&self, blocks: [U8x16; N]) -> [U8x16; N]
    where
        ArrayUnrolledOps: UnrollableArraySize<N>,
    {
        use aes_soft::cipher::{generic_array::GenericArray, BlockCipher}; // TODO: support ParBlocks
        blocks.array_map(
            #[inline(always)]
            |block| {
                let mut block = GenericArray::from(block.as_array());
                (*self.key).decrypt_block(&mut block);
                U8x16::from(<[u8; 16]>::from(block))
            },
        )
    }
}
impl From<Aes256> for Aes256EncryptOnly {
    #[doc = "\n # Avx2"]
    #[inline(always)]
    fn from(aes: Aes256) -> Aes256EncryptOnly {
        Aes256EncryptOnly { key: aes.key }
    }
}
#[derive(Clone)]
pub struct Aes256EncryptOnly {
    key: Aes256EncryptOnlyKeySchedule,
}
impl std::fmt::Debug for Aes256EncryptOnly {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "Aes256EncryptOnly(...)")
    }
}
impl Aes256EncryptOnly {
    pub(super) const FIXED_KEY: Self = Self {
        key: { Aes256KeySchedule::Fixed },
    };
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aeskeygenassist_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aeskeygenassist_si128)\n\n\n [`AESKEYGENASSIST (XMM, XMM, I8)`](https://felixcloutier.com/x86/AESKEYGENASSIST.html): AES Round Key Generation Assist\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKL\">Skylake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#SKX\">Skylake-AVX512</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESKEYGENASSIST_XMM_XMM_I8.html#CLX\">Cascade Lake</a></td>\n <td>7</td>\n <td>12.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn new_with_key(key: U8x32) -> Self {
        use aes_soft::cipher::{generic_array::GenericArray, NewBlockCipher};
        let key_bytes = key.as_array();
        Aes256EncryptOnly {
            key: aes_soft::Aes256::new(&GenericArray::from(key_bytes)).into(),
        }
    }
    #[doc = "\n # Avx2\n <ul>\n <li>\n\n [**`_mm_aesenc_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenc_si128)\n\n\n [`AESENC (XMM, XMM)`](https://felixcloutier.com/x86/AESENC.html): Perform One Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENC_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n <li>\n\n [**`_mm_aesenclast_si128`**](https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_aesenclast_si128)\n\n\n [`AESENCLAST (XMM, XMM)`](https://felixcloutier.com/x86/AESENCLAST.html): Perform Last Round of an AES Encryption Flow\n\n <table style=\"line-height:0.7\">\n <thead><tr>\n <th>Architecture</th><th>Latency (cycles)</th><th>Throughput (CPI)</th>\n </tr></thead><tbody>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKL\">Skylake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#SKX\">Skylake-AVX512</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n <tr>\n <td><a href=\"https://uops.info/html-instr/AESENCLAST_XMM_XMM.html#CLX\">Cascade Lake</a></td>\n <td>4</td>\n <td>1.00</td>\n </tr>\n </tbody></table>\n\n _<span style=\"font-size:0.8em;float:right\">Performance numbers are measurements from [uops.info](https://uops.info/).</span>_ <div style=\"clear:both\"></div>\n </li>\n </ul>"]
    #[inline(always)]
    pub(super) fn encrypt_many<const N: usize>(&self, blocks: [U8x16; N]) -> [U8x16; N]
    where
        ArrayUnrolledOps: UnrollableArraySize<N>,
    {
        use aes_soft::cipher::{generic_array::GenericArray, BlockCipher}; // TODO: support ParBlocks
        blocks.array_map(
            #[inline(always)]
            |block| {
                let mut block = GenericArray::from(block.as_array());
                (*self.key).encrypt_block(&mut block);
                U8x16::from(<[u8; 16]>::from(block))
            },
        )
    }
} // Implement the intrinsics
  // Scalar has no intrinsics
